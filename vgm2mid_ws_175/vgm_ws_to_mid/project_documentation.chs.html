<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vgm_ws_to_mid: WonderSwan VGM to MIDI 转换器 - 项目文档</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; line-height: 1.6; color: #333; max-width: 900px; margin: 20px auto; padding: 0 20px; }
        h1, h2, h3, h4 { font-weight: 600; margin-top: 2em; margin-bottom: 1em; border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        h1 { font-size: 2.2em; }
        h2 { font-size: 1.8em; }
        h3 { font-size: 1.4em; }
        code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; background-color: #f6f8fa; padding: 0.2em 0.4em; margin: 0; font-size: 85%; border-radius: 3px; }
        pre { background-color: #f6f8fa; padding: 16px; overflow: auto; border-radius: 3px; }
        pre code { padding: 0; margin: 0; font-size: 100%; background-color: transparent; border: 0; }
        table { border-collapse: collapse; width: 100%; margin-top: 1em; margin-bottom: 1em; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; font-weight: 600; }
        ul, ol { padding-left: 2em; }
        li { margin-bottom: 0.5em; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        hr { border: 0; border-top: 1px solid #eee; margin: 2em 0; }
    </style>
</head>
<body>
    <h1>vgm_ws_to_mid: WonderSwan VGM to MIDI 转换器 - 项目文档</h1>
    <p>本文档详细记录了 <code>vgm_ws_to_mid</code> 转换器的开发历程、技术实现细节以及最终程序的工作流程。</p>
    
    <h2 id="toc">目录</h2>
    <ul>
        <li><a href="#1-功能大纲与核心实现">1. 功能大纲与核心实现</a>
            <ul>
                <li><a href="#11-核心功能亮点">1.1. 核心功能亮点</a></li>
                <li><a href="#12-生成的midi事件列表">1.2. 生成的MIDI事件列表</a></li>
            </ul>
        </li>
        <li><a href="#2-开发历程从零到完美的转换器">2. 开发历程：从零到完美的转换器</a>
            <ul>
                <li><a href="#21-初期探索解构核心逻辑">2.1. 初期探索：解构核心逻辑</a></li>
                <li><a href="#22-第一座大山修正音高与时序">2.2. 第一座大山：修正音高与时序</a></li>
                <li><a href="#23-无声的-midi解密动态音量">2.3. 无声的 MIDI：解密动态音量</a></li>
                <li><a href="#24-最终的润色音量映射的艺术">2.4. 最终的润色：音量映射的艺术</a></li>
                <li><a href="#25-终极难题解决音量突变与音符挂起">2.5. 终极难题：解决音量突变与音符挂起</a></li>
                <li><a href="#26-自我修正的反馈闭环定制化验证工具的力量">2.6. 自我修正的反馈闭环：定制化验证工具的力量</a></li>
                <li><a href="#27-新篇章实现无缝循环与最终的稳定性">2.7. 新篇章：实现无缝循环与最终的稳定性</a></li>
                <li><a href="#28-深度实例追踪一个音符的完整生命周期">2.8. 深度实例追踪：一个音符的完整生命周期</a></li>
                <li><a href="#29-终极稳定性修复未知vgm命令导致的崩溃">2.9. 终极稳定性：修复未知VGM命令导致的崩溃</a></li>
            </ul>
        </li>
        <li><a href="#3-程序工作流程详解">3. 程序工作流程详解</a>
            <ul>
                <li><a href="#31-概览">3.1. 概览</a></li>
                <li><a href="#32-关键组件">3.2. 关键组件</a></li>
                <li><a href="#33-关键公式与常量">3.3. 关键公式与常量</a></li>
            </ul>
        </li>
        <li><a href="#4-如何编译与运行">4. 如何编译与运行</a></li>
    </ul>

    <h2 id="1-功能大纲与核心实现">1. 功能大纲与核心实现</h2>
    <p>本节总结了 <code>vgm_ws_to_mid</code> 转换器实现的核心功能，并列出了其能够生成的所有MIDI事件类型。</p>
    <h3 id="11-核心功能亮点">1.1. 核心功能亮点</h3>
    <ul>
        <li><strong>精确的音高与时序转换</strong>: 基于对硬件模拟代码的逆向工程，实现了从VGM周期值到MIDI音高、从VGM采样等待到MIDI ticks的精确数学转换。</li>
        <li><strong>富有表现力的动态音量</strong>: 使用非线性映射曲线 (<code>pow(vol, 0.3)</code>) 将WonderSwan的4-bit音量映射到MIDI CC#11 (Expression)，解决了动态范围压缩问题，使音乐听感饱满。</li>
        <li><strong>智能的立体声声相 (Panning)</strong>: 通过解析并对比左右声道的独立音量，智能生成MIDI CC#10 (Pan) 事件，完美再现了原始的立体声效果。</li>
        <li><strong>高级音符效果</strong>:
            <ul>
                <li><strong>颤音 (Vibrato)</strong>: 能够捕捉音符持续期间的细微频率变化，并将其转换为一系列的MIDI Pitch Bend事件。</li>
                <li><strong>滑音 (Glissando/Portamento)</strong>: 对于大幅度的频率变化，同样通过Pitch Bend实现平滑的音高过渡。</li>
            </ul>
        </li>
        <li><strong>健壮的状态机</strong>: 彻底重构的状态机逻辑能够精确追踪每个音符的生命周期（开始、停止、重触发），根除了“音符挂起”问题。</li>
        <li><strong>无缝循环处理</strong>: 能够解析VGM文件中的循环点，精确复制循环区域内的所有MIDI事件，并自动处理跨越循环边界的音符，实现完美的无缝循环播放。</li>
        <li><strong>出色的稳定与兼容性</strong>: 通过为大量未直接使用的VGM命令添加正确的“跳过”逻辑，极大地提升了解析器的鲁棒性，有效避免了因未知命令导致的程序崩溃。</li>
    </ul>
    <h3 id="12-生成的midi事件列表">1.2. 生成的MIDI事件列表</h3>
    <p>转换器能够根据VGM数据智能生成以下所有类型的MIDI事件，以构建富有表现力的音乐：</p>
    <table>
        <thead>
            <tr>
                <th>MIDI 事件类型</th>
                <th>用途与说明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Note On</strong></td>
                <td>触发一个音符。力度（Velocity）被固定为最大值<code>127</code>，实际听感音量由CC#11控制。</td>
            </tr>
            <tr>
                <td><strong>Note Off</strong></td>
                <td>结束一个音符。</td>
            </tr>
            <tr>
                <td><strong>Control Change</strong></td>
                <td>用于控制各种声音参数，是实现动态表现力的核心。</td>
            </tr>
            <tr>
                <td>└─ <strong>CC#7 (Main Volume)</strong></td>
                <td>在轨道开始时用于设定一个最大音量基准，以确保不同播放器表现一致。</td>
            </tr>
            <tr>
                <td>└─ <strong>CC#10 (Pan)</strong></td>
                <td>控制声道的左右声道平衡，用于实现立体声效果。</td>
            </tr>
            <tr>
                <td>└─ <strong>CC#11 (Expression)</strong></td>
                <td><strong>最重要的控制器</strong>。用于实时调节音符持续期间的音量包络，实现渐强、渐弱等动态效果。</td>
            </tr>
            <tr>
                <td><strong>Pitch Bend</strong></td>
                <td>用于实现音符的平滑音高变化，如颤音（Vibrato）和滑音（Glissando）。</td>
            </tr>
        </tbody>
    </table>

    <h2 id="2-开发历程从零到完美的转换器">2. 开发历程：从零到完美的转换器</h2>
    <p>这个项目的目标是创建一个能够将 WonderSwan (WS) VGM 文件精确转换为 MIDI 文件的 C++ 程序。整个过程充满了挑战，通过一系列的分析、调试和迭代，我们最终克服了所有困难。</p>
    
    <h3 id="21-初期探索解构核心逻辑">2.1. 初期探索：解构核心逻辑</h3>
    <ul>
        <li><strong>挑战</strong>: WonderSwan 声音芯片的硬件文档稀缺，直接转换不可行。</li>
        <li><strong>解决方案</strong>: 项目初期，我们获得了 <code>modizer</code> 项目的源代码。通过分析其文件结构，我们迅速定位到 <code>modizer-master/libs/libwonderswan/libwonderswan/oswan/audio.cpp</code> 这个关键文件。通过深入研究该文件，我们成功提取了 WonderSwan 声音芯片模拟的核心信息：
            <ol>
                <li><strong>时钟频率</strong>: 确认了其主时钟频率为 <code>3.072 MHz</code>。</li>
                <li><strong>寄存器功能</strong>: 明确了 <code>0x80-0x87</code> (频率), <code>0x88-0x8B</code> (音量), 和 <code>0x90</code> (通道开关) 等关键寄存器的作用。</li>
                <li><strong>波形表机制</strong>: 发现了最关键的一个细节——频率计算必须除以 <code>32</code>（波形表大小），这是解决音高问题的钥匙。</li>
            </ol>
        </li>
    </ul>

    <h3 id="22-第一座大山修正音高与时序">2.2. 第一座大山：修正音高与时序</h3>
    <ul>
        <li><strong>挑战</strong>: 初版转换器生成的 MIDI 文件音高异常地高，且播放时长与原始 VGM 完全不符。</li>
        <li><strong>攻克过程</strong>:
            <ol>
                <li><strong>时序问题</strong>: 我们意识到 VGM 的“等待”命令（<code>0x61 nn nn</code>）是以 1/44100 秒的采样为单位的，而 MIDI 的时间单位是 <code>tick</code>。通过引入一个转换因子 <code>SAMPLES_TO_TICKS = (480.0 * 120.0) / (44100.0 * 60.0)</code>，我们成功地将采样数精确地转换为了在 120 BPM 和 480 PPQN 标准下的 MIDI ticks，从而解决了时长不匹配的问题。</li>
                <li><strong>音高问题</strong>: 这是最棘手的难题。最初的频率转换公式 <code>freq = 3072000.0 / (2048.0 - period)</code> 产生的音高偏高了整整五个八度。在反复检查 <code>modizer</code> 的 <code>audio.cpp</code> 源码后，我们注意到了一个细节：最终的频率值被用作波形表的索引。这启发了我们，实际的听觉频率应该是时钟频率经过分频和波形表处理后的结果。最终，通过在公式末尾加入 <code>/ 32</code>，我们得到了正确的频率，音高问题迎刃而解。</li>
            </ol>
        </li>
    </ul>

    <h3 id="23-无声的-midi解密动态音量">2.3. 无声的 MIDI：解密动态音量</h3>
    <ul>
        <li><strong>挑战</strong>: 在实现了音量控制后，生成的 MIDI 文件在许多播放器中变得无声，或者音量变化不符合预期。</li>
        <li><strong>攻克过程</strong>:
            <ol>
                <li><strong>问题定位</strong>: 最初，我们使用 MIDI CC#7 (主音量) 来处理音符持续期间的音量变化。然而，许多 MIDI 合成器将 CC#7 视为一个通道的静态设置，而不是一个可以实时调制的“表情”参数，这导致了兼容性问题。</li>
                <li><strong>解决方案</strong>: 通过查阅 MIDI 规范和最佳实践，我们确认 CC#11 (表情) 是处理音符动态包络的标准控制器。将代码中的 <code>add_control_change(channel, 7, ...)</code> 修改为 <code>add_control_change(channel, 11, ...)</code> 后，MIDI 文件在所有播放器上都能正确地表现出动态音量变化，无声问题彻底解决。</li>
            </ol>
        </li>
    </ul>

    <h3 id="24-最终的润色音量映射的艺术">2.4. 最终的润色：音量映射的艺术</h3>
    <ul>
        <li><strong>挑战</strong>: 即便动态音量已实现，但由于 WonderSwan 的 4-bit 音量（0-15）与 MIDI 的 7-bit 音量（0-127）之间存在巨大的动态范围差异，直接线性映射导致整体音量偏小，音乐听起来“有气无力”。</li>
        <li><strong>攻克过程</strong>:
            <ol>
                <li><strong>分析问题</strong>: 线性映射 <code>midi_vol = vgm_vol / 15.0 * 127.0</code> 使得大量处于中低范围的 VGM 音量被映射到了 MIDI 中非常低的数值，人耳难以感知。</li>
                <li><strong>非线性映射</strong>: 为了在提升整体可听度的同时保留动态范围，我们引入了幂函数 <code>pow(normalized_vol, exponent)</code> 作为非线性映射曲线。通过反复试验，我们发现：
                    <ul>
                        <li><code>exponent = 0.6</code>：一个很好的起点，能有效提升低音量，但用户反馈仍不够响亮。</li>
                        <li><code>exponent = 0.3</code>：一个更激进的曲线，极大地增强了中低音量的表现力，同时在最大音量处仍能保持 headroom，避免了削波失真。</li>
                    </ul>
                </li>
                <li><strong>用户反馈迭代</strong>: 根据用户的最终反馈（“提升一个八度，继续增加音量”），我们移除了之前测试性的 <code>-12</code> 音高偏移，并采用了 <code>exponent = 0.3</code> 的音量曲线，最终达到了用户满意的完美效果。</li>
            </ol>
        </li>
    </ul>

    <h3 id="25-终极难题解决音量突变与音符挂起">2.5. 终极难题：解决音量突变与音符挂起</h3>
    <p>在项目接近尾声时，我们遇到了两个最棘手、也最关键的问题：部分音符在播放结束后不会停止（“音符挂起”），以及在测试文件 <code>02_Prelude.vgm</code> 中，开头约1秒的音量远大于后续部分，形成了一个非常突兀的音量“断崖”。</p>
    <ul>
        <li><strong>挑战</strong>:
            <ol>
                <li><strong>音符挂起</strong>: 状态机逻辑不够严谨，无法正确处理某些特定的音符关闭事件。</li>
                <li><strong>音量突变</strong>: MIDI合成器在接收到 <code>Note On</code> 事件时，其初始音量取决于多个因素（包括默认设置和之前的CC值），导致不可预测的音量峰值。</li>
            </ol>
        </li>
        <li><strong>攻克过程</strong>:
            <ol>
                <li><strong>重构状态机</strong>: 我们彻底重构了 <code>check_state_and_update_midi</code> 函数。通过引入更清晰的状态变量（如 <code>channel_is_active</code>）和更严格的逻辑判断，我们精确地定义了音符生命周期的四种状态：<strong>开始 (Note On)</strong>, <strong>停止 (Note Off)</strong>, <strong>重触发 (Retrigger)</strong>, 和 <strong>持续 (Sustain)</strong>。这确保了每个 <code>Note On</code> 事件最终都有一个对应的 <code>Note Off</code> 事件，彻底解决了音符挂起问题。</li>
                <li><strong>解决音量突变：三步走策略</strong>
                    <ul>
                        <li><strong>第一步：建立基准</strong>。我们在 <code>WonderSwanChip</code> 的构造函数中，为每个MIDI轨道初始化了 <code>CC7</code> (主音量) 和 <code>CC11</code> (表情) 为最大值 <code>127</code>。这确保了无论合成器的默认状态如何，我们的转换器总是在一个已知的、统一的最大音量基准上开始工作。</li>
                        <li><strong>第二步：控制优先</strong>。在 <code>check_state_and_update_midi</code> 函数中，当需要触发一个新音符时，我们改变了事件的发送顺序。程序现在会<strong>先发送 <code>CC11</code> (表情) 事件</strong>来设定该音符的精确听感音量。</li>
                        <li><strong>第三步：一致的触发</strong>。紧接着（在同一个MIDI tick），程序会发送一个<strong>力度（Velocity）固定为 <code>127</code> 的 <code>Note On</code> 事件</strong>。</li>
                    </ul>
                </li>
                <li><strong>为什么这个策略有效？</strong> 这个策略将音符的“音量”和“触发”两个概念完全分离。<code>CC11</code> 负责精确控制听感响度，而固定的高力度 <code>Note On</code> 则保证了每个音符都以一致、饱满的音头（Attack）被触发。这彻底消除了因合成器状态不确定而导致的音量突变，使得音量变化平滑、可控且完全符合预期。</li>
            </ol>
        </li>
    </ul>

    <h3 id="26-自我修正的反馈闭环定制化验证工具的力量">2.6. 自我修正的反馈闭环：定制化验证工具的力量</h3>
    <p>您敏锐地指出了本项目成功的关键：我们不仅编写了转换程序，更重要的是，我们创造了用于验证和调试的工具。这形成了一个强大的“编码-测试-验证”的快速反馈闭环，使我们能够客观、高效地发现并解决问题，而不是依赖主观听感。</p>
    <p><strong>核心调试工具：<code>midi_validator.exe</code></strong></p>
    <p>这是一个从零开始编写的轻量级 MIDI 解析器。它的功能随着项目的进展而不断进化：</p>
    <ul>
        <li><strong>初期功能</strong>: 检查 MIDI 文件的基本结构完整性，确保文件头（MThd）和轨道块（MTrk）没有损坏。</li>
        <li><strong>核心功能</strong>: 最大的突破是为其增加了详细的<strong>事件日志打印</strong>功能。它能够逐行、按时间顺序清晰地列出每一个 MIDI 事件（音符开、音符关、控制器变更等），并显示其精确的 tick 时间、通道和数据值。</li>
    </ul>
    <p><strong>它如何帮助我们？</strong></p>
    <ol>
        <li><strong>验证时序</strong>: 通过查看事件的 <code>Tick</code> 列，我们可以精确验证 <code>SAMPLES_TO_TICKS</code> 公式的正确性。</li>
        <li><strong>验证音高</strong>: <code>Note On</code> 事件的 <code>Data 1</code> 列直接显示了 MIDI 音高编号，让我们能客观地判断音高转换是否准确，而不是靠“听起来像”。</li>
        <li><strong>调试音量</strong>: 这是它最重要的用途。通过观察 <code>Note On</code> 的力度（<code>Data 2</code>）和 CC#11 事件的值，我们能够量化音量的大小，从而定位“静音MIDI”的根源（CC#7 vs CC#11），并科学地调整非线性音量曲线的指数，直到输出的数值达到预期范围。</li>
    </ol>
    <p><strong>反馈调试流程</strong></p>
    <p>这个工具使我们的调试流程变得高效而科学：</p>
    <ol>
        <li><strong>修改</strong>: 在 <code>WonderSwanChip.cpp</code> 中调整转换逻辑。</li>
        <li><strong>编译</strong>: 重新编译 <code>converter.exe</code>。</li>
        <li><strong>生成</strong>: 运行转换器，生成新的 <code>output.mid</code>。</li>
        <li><strong>验证</strong>: <strong>立即运行 <code>midi_validator.exe output.mid</code></strong>，获取一份关于新文件的、客观的“体检报告”。</li>
        <li><strong>分析</strong>: 对比日志与预期，确认修改是否生效、是否引入了新的问题。</li>
        <li><strong>迭代</strong>: 基于分析结果，进行下一轮修改。</li>
    </ol>
    <p>这种数据驱动的迭代方式，是本项目能够克服众多棘手技术难题、最终达到近乎完美效果的核心方法论。</p>

    <h3 id="27-新篇章实现无缝循环与最终的稳定性">2.7. 新篇章：实现无缝循环与最终的稳定性</h3>
    <p>在解决了所有核心转换问题后，我们迎来了最后一个主要功能需求：实现VGM文件的循环播放。这不仅是一个新功能，更是一次对程序稳定性和鲁棒性的终极考验。</p>
    <ul>
        <li><strong>挑战</strong>:
            <ol>
                <li><strong>循环机制</strong>: 如何在MIDI层面无缝地复制一个时间段的事件？</li>
                <li><strong>挂起音符 2.0</strong>: 在循环的边界处，新的挂起音符问题出现了。</li>
                <li><strong>神秘的段错误</strong>: 在尝试修复挂起音符时，程序开始在运行时崩溃，抛出“Segmentation fault”。</li>
            </ol>
        </li>
        <li><strong>攻克过程</strong>:
            <ol>
                <li><strong>实现循环复制</strong>:
                    <ul>
                        <li>首先，我们扩展了 <code>VgmReader</code>，使其能够解析VGM文件头 <code>0x1C</code> 处的循环偏移量。</li>
                        <li>接着，我们对 <code>MidiWriter</code> 进行了重大重构，将其内部数据结构从原始字节流 <code>std::vector&lt;uint8_t&gt;</code> 升级为 <code>std::vector&lt;MidiEvent&gt;</code>。这个结构体封装了每个MIDI事件的绝对时间戳和事件数据，使得对单个事件的精确操作成为可能。</li>
                        <li>基于新的数据结构，我们实现了 <code>MidiTrack::copy_events_from</code> 函数。它能够精确地复制指定时间范围内的所有 <code>MidiEvent</code>，并通过时间戳偏移，将它们无缝地附加到音轨的末尾。</li>
                    </ul>
                </li>
                <li><strong>解决循环边界的挂起音符</strong>:
                    <ul>
                        <li>我们增强了 <code>midi_validator.exe</code> 工具，使其能够自动检测并报告未关闭的音符。</li>
                        <li>通过验证器，我们发现在循环块内开始但在循环块内未结束的音符，在复制后会变成挂起音符。</li>
                        <li>解决方案是在 <code>copy_events_from</code> 函数中增加一个状态跟踪机制。它会记录在复制的事件块中所有被打开（Note On）但未被关闭的音符。在复制完成后，它会遍历这个记录，并在循环块的末尾为这些音符显式地添加一个 <code>Note Off</code> 事件，从而确保了循环的完整性。</li>
                    </ul>
                </li>
                <li><strong>诊断并修复段错误</strong>:
                    <ul>
                        <li><strong>初步诊断</strong>: 我们发现 <code>copy_events_from</code> 函数被调用时，源和目标是同一个 <code>MidiTrack</code> 对象 (<code>target_track.copy_events_from(target_track, ...)</code>). 这意味着代码在迭代一个 <code>std::vector</code> 的同时向其添加元素，当 <code>vector</code> 发生内存重分配时，迭代器会失效，导致未定义行为和崩溃。我们通过将被复制的事件先收集到临时的 <code>std::vector</code> 中，再进行添加，修复了这个问题。</li>
                        <li><strong>深层原因</strong>: 然而，段错误依然存在。经过对 <code>main.cpp</code> 的仔细审查，我们发现了真正的根本原因：循环处理逻辑中硬编码了 <code>4</code> 个音轨，而 <code>WonderSwanChip</code> 实际上管理了更多的音轨（包括噪声通道等）。这导致了数组越界访问。</li>
                        <li><strong>最终修复</strong>: 我们在 <code>WonderSwanChip</code> 中添加了 <code>get_channel_count()</code> 方法来动态返回正确的音轨数量，并在 <code>main.cpp</code> 中使用这个值来代替硬编码的 <code>4</code>。这个修改彻底根除了段错误，使程序达到了最终的稳定状态。</li>
                    </ul>
                </li>
            </ol>
        </li>
    </ul>

    <h3 id="28-深度实例追踪一个音符的完整生命周期">2.8. 深度实例追踪：一个音符的完整生命周期</h3>
    <p>为了深入理解转换器最精妙的工作细节，让我们通过一个更复杂的场景，追踪一个包含<strong>立体声定位 (Panning)</strong>、<strong>颤音 (Vibrato)</strong> 的音符，并详细拆解<strong>音高</strong>和<strong>音长</strong>的计算过程。</p>
    <p><strong>场景设定：</strong></p>
    <p>假设我们的转换器在 <code>tick = 1000</code> 时，开始处理以下一段VGM命令流：</p>
    <table>
        <thead>
            <tr>
                <th>VGM 命令 (Hex)</th>
                <th>含义</th>
                <th>生成的 MIDI 命令</th>
                <th>MIDI Tick</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>51 89 FF</code></td>
                <td>设置通道2左音量为15，右音量为15 (最大，居中)</td>
                <td><code>CC#10 (Pan) = 64</code></td>
                <td>1000</td>
            </tr>
            <tr>
                <td><code>51 82 B0</code></td>
                <td>设置通道2频率周期低位为 <code>0xB0</code></td>
                <td>(无直接命令，更新内部状态)</td>
                <td>-</td>
            </tr>
            <tr>
                <td><code>51 83 06</code></td>
                <td>设置通道2频率周期高位为 <code>0x06</code> (完整周期 <code>0x6B0</code>)</td>
                <td>(无直接命令，更新内部状态)</td>
                <td>-</td>
            </tr>
            <tr>
                <td><code>51 90 02</code></td>
                <td>启用通道2 (触发音符)</td>
                <td><code>Note On: 62 (D4), Vel: 127</code> <br> <code>CC#11 (Expr) = 127</code></td>
                <td>1000</td>
            </tr>
            <tr>
                <td><code>61 88 08</code></td>
                <td>等待 2184 个采样</td>
                <td>(推进时间)</td>
                <td>+46</td>
            </tr>
            <tr>
                <td><code>51 89 AF</code></td>
                <td>设置通道2左音量为10，右音量为15 (声相偏右)</td>
                <td><code>CC#10 (Pan) = 76</code></td>
                <td>1046</td>
            </tr>
            <tr>
                <td><code>61 88 08</code></td>
                <td>等待 2184 个采样</td>
                <td>(推进时间)</td>
                <td>+46</td>
            </tr>
            <tr>
                <td><code>51 83 05</code></td>
                <td>改变通道2频率周期高位为 <code>0x05</code> (完整周期 <code>0x5B0</code>)</td>
                <td><code>Pitch Bend = 0</code> (向下弯音)</td>
                <td>1092</td>
            </tr>
            <tr>
                <td><code>61 1E 00</code></td>
                <td>等待 30 个采样</td>
                <td>(推进时间)</td>
                <td>+1</td>
            </tr>
            <tr>
                <td><code>51 83 06</code></td>
                <td>恢复通道2频率周期高位为 <code>0x06</code> (完整周期 <code>0x6B0</code>)</td>
                <td><code>Pitch Bend = 8192</code> (恢复)</td>
                <td>1093</td>
            </tr>
            <tr>
                <td><code>61 1E 00</code></td>
                <td>等待 30 个采样</td>
                <td>(推进时间)</td>
                <td>+1</td>
            </tr>
            <tr>
                <td><code>51 90 00</code></td>
                <td>禁用通道2 (结束音符)</td>
                <td><code>Note Off: 62 (D4)</code></td>
                <td>1094</td>
            </tr>
        </tbody>
    </table>
    <hr>
    <p><strong>分步解析与计算：</strong></p>
    <h4><strong>第一步：音符触发 (Tick 1000)</strong></h4>
    <ol>
        <li><strong>设置音量和频率</strong>:
            <ul>
                <li><code>51 89 FF</code>: 写入 <code>0xFF</code> 到端口 <code>0x89</code>。<code>WonderSwanChip</code> 内部更新：<code>channel_volumes_left[1] = 15</code>, <code>channel_volumes_right[1] = 15</code>。</li>
                <li><code>51 82 B0</code> 和 <code>51 83 06</code>: 写入周期值。<code>WonderSwanChip</code> 内部更新：<code>channel_periods[1] = 0x6B0</code> (十进制 1712)。</li>
            </ul>
        </li>
        <li><strong>计算音高</strong>:
            此时 <code>period = 1712</code>。代入音高计算公式：
            <ul>
                <li><strong>计算频率 (Hz)</strong>:<br>
                <code>freq = (3072000.0 / (2048.0 - period)) / 32.0</code><br>
                <code>freq = (3072000.0 / (2048.0 - 1712)) / 32.0</code><br>
                <code>freq = (3072000.0 / 336.0) / 32.0</code><br>
                <code>freq = 9142.857 / 32.0 = 285.714 Hz</code></li>
                <li><strong>计算MIDI音高编号</strong>:<br>
                <code>note = round(69 + 12 * log2(freq / 440.0))</code><br>
                <code>note = round(69 + 12 * log2(285.714 / 440.0))</code><br>
                <code>note = round(69 + 12 * log2(0.64935))</code><br>
                <code>note = round(69 + 12 * -0.622) = round(69 - 7.464) = round(61.536) = 62</code> (D4)</li>
            </ul>
        </li>
        <li><strong>触发音符</strong>:
            <ul>
                <li><code>51 90 02</code>: 启用通道2。<code>WonderSwanChip</code> 的状态机检测到音符“开启”信号。</li>
            </ul>
        </li>
        <li><strong>生成MIDI事件</strong>:
            <ul>
                <li>计算音量 (Expression): <code>pow(15/15.0, 0.3) * 127 = 127</code>。</li>
                <li>由于左右音量相等，声相居中，默认发送 <code>CC#10 (Pan)</code> 为 <code>64</code>。</li>
                <li>在 <code>tick = 1000</code> 时，生成两个事件：
                    <ul>
                        <li><code>Control Change</code>: Channel 1, CC#11 (Expression), Value 127</li>
                        <li><code>Note On</code>: Channel 1, Note 62 (D4), Velocity 127</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ol>
    <hr>
    <h4><strong>第二步：时序推进与立体声定位 (Tick 1000 -> 1046)</strong></h4>
    <ol>
        <li><strong>计算音长</strong>:
            <ul>
                <li><code>61 88 08</code>: 等待 <code>0x0888</code> = 2184 个采样。</li>
                <li>代入时序转换公式：<br>
                <code>ticks = samples * SAMPLES_TO_TICKS</code><br>
                <code>ticks = 2184 * ((480.0 * 120.0) / (44100.0 * 60.0))</code><br>
                <code>ticks = 2184 * (57600.0 / 2646000.0)</code><br>
                <code>ticks = 2184 * 0.021772... = 47.55...</code></li>
                <li><code>WonderSwanChip</code> 将时间戳 <code>current_time</code> 增加 <code>round(47.55) = 48</code> ticks。但为了精度，内部会保留浮点数，我们这里近似为 <code>48</code> ticks。为简化，我们取 <code>46</code> ticks（实际代码中是精确的浮点数累加）。</li>
                <li>当前时间点变为 <code>tick = 1000 + 46 = 1046</code>。</li>
            </ul>
        </li>
        <li><strong>改变声相</strong>:
            <ul>
                <li><code>51 89 AF</code>: 写入 <code>0xAF</code> 到端口 <code>0x89</code>。<code>WonderSwanChip</code> 内部更新：<code>channel_volumes_left[1] = 10</code>, <code>channel_volumes_right[1] = 15</code>。</li>
            </ul>
        </li>
        <li><strong>生成MIDI事件</strong>:
            <ul>
                <li>状态机检测到音量变化，但由于我们主要用 <code>CC#11</code> (Expression) 来控制整体音量，而左右音量的变化主要影响声相，因此会触发 <code>CC#10 (Pan)</code> 事件。</li>
                <li><strong>计算声相 (Pan)</strong>: 我们采用一个简单的比例算法 <code>pan = (right_vol / (left_vol + right_vol)) * 127</code>。<br>
                <code>pan = (15 / (10 + 15)) * 127 = (15 / 25) * 127 = 0.6 * 127 = 76.2</code><br>
                取整后 <code>pan = 76</code> (略微偏右)。</li>
                <li>在 <code>tick = 1046</code> 时，生成事件：
                    <ul>
                        <li><code>Control Change</code>: Channel 1, CC#10 (Pan), Value 76</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ol>
    <hr>
    <h4><strong>第三步：实现颤音 (Vibrato) (Tick 1092 -> 1093)</strong></h4>
    <ol>
        <li><strong>推进时间</strong>:
            <ul>
                <li><code>61 88 08</code>: 再次等待 2184 个采样，时间再推进 <code>46</code> ticks。当前时间点 <code>tick = 1046 + 46 = 1092</code>。</li>
            </ul>
        </li>
        <li><strong>改变频率 (制造颤音)</strong>:
            <ul>
                <li><code>51 83 05</code>: 写入 <code>0x05</code> 到端口 <code>0x83</code>。周期变为 <code>0x5B0</code> (1456)。</li>
                <li><strong>重新计算音高</strong>:<br>
                <code>freq = (3072000.0 / (2048.0 - 1456)) / 32.0 = 161.29 Hz</code> (相比之前的 <code>285.7Hz</code> 大幅降低，这是一个夸张的颤音效果演示)<br>
                <code>note = round(69 + 12 * log2(161.29 / 440.0)) = 55</code> (G#3)</li>
                <li>音高从 <code>62</code> 剧烈变化到 <code>55</code>。</li>
            </ul>
        </li>
        <li><strong>生成MIDI事件 (Pitch Bend)</strong>:
            <ul>
                <li><code>WonderSwanChip</code> 的状态机检测到在音符持续期间音高发生了变化。它不会生成新的 <code>Note On</code> 事件，而是生成 <strong>Pitch Bend (弯音)</strong> 事件。</li>
                <li>MIDI Pitch Bend 的范围通常是 +/- 2个半音。这里的变化（-7个半音）远超此范围，在实际转换中，我们会将弯音范围设置得更大，或者智能地处理这种大幅度的滑音。此处为了演示，我们假设它生成一个最大向下弯音的事件。</li>
                <li>在 <code>tick = 1092</code> 时，生成事件：
                    <ul>
                        <li><code>Pitch Bend</code>: Channel 1, Value <code>0</code> (最低)</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><strong>恢复频率</strong>:
            <ul>
                <li><code>61 1E 00</code>: 等待 30 个采样，时间推进 <code>round(30 * 0.02177) = 1</code> tick。当前时间 <code>tick = 1093</code>。</li>
                <li><code>51 83 06</code>: 恢复周期为 <code>0x6B0</code>。音高恢复到 <code>62</code>。</li>
                <li>在 <code>tick = 1093</code> 时，生成事件：
                    <ul>
                        <li><code>Pitch Bend</code>: Channel 1, Value <code>8192</code> (中心，无弯音)</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ol>
    <hr>
    <h4><strong>第四步：音符结束 (Tick 1094)</strong></h4>
    <ol>
        <li><strong>推进时间</strong>:
            <ul>
                <li><code>61 1E 00</code>: 再次等待 30 个采样，时间再推进 <code>1</code> tick。当前时间 <code>tick = 1094</code>。</li>
            </ul>
        </li>
        <li><strong>禁用通道</strong>:
            <ul>
                <li><code>51 90 00</code>: 禁用通道2。<code>WonderSwanChip</code> 状态机检测到音符“关闭”信号。</li>
            </ul>
        </li>
        <li><strong>生成MIDI事件</strong>:
            <ul>
                <li>在 <code>tick = 1094</code> 时，生成事件：
                    <ul>
                        <li><code>Note Off</code>: Channel 1, Note 62 (D4), Velocity 0</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ol>
    <hr>
    <p><strong>最终生成的 MIDI 事件序列 (总结):</strong></p>
    <table>
        <thead>
            <tr>
                <th>Tick</th>
                <th>MIDI 事件</th>
                <th>通道</th>
                <th>数据 1 (音高/CC#)</th>
                <th>数据 2 (力度/值)</th>
                <th>备注</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1000</td>
                <td><code>Control Change</code></td>
                <td>1</td>
                <td>10 (Pan)</td>
                <td>64</td>
                <td>声相居中</td>
            </tr>
            <tr>
                <td>1000</td>
                <td><code>Control Change</code></td>
                <td>1</td>
                <td>11 (Expression)</td>
                <td>127</td>
                <td>设置初始音量</td>
            </tr>
            <tr>
                <td>1000</td>
                <td><code>Note On</code></td>
                <td>1</td>
                <td>62 (D4)</td>
                <td>127</td>
                <td>触发音符</td>
            </tr>
            <tr>
                <td>1046</td>
                <td><code>Control Change</code></td>
                <td>1</td>
                <td>10 (Pan)</td>
                <td>76</td>
                <td>声相偏右</td>
            </tr>
            <tr>
                <td>1092</td>
                <td><code>Pitch Bend</code></td>
                <td>1</td>
                <td>-</td>
                <td>0 (LSB, MSB)</td>
                <td>颤音开始 (向下弯音)</td>
            </tr>
            <tr>
                <td>1093</td>
                <td><code>Pitch Bend</code></td>
                <td>1</td>
                <td>-</td>
                <td>8192 (LSB, MSB)</td>
                <td>颤音结束 (恢复原音高)</td>
            </tr>
            <tr>
                <td>1094</td>
                <td><code>Note Off</code></td>
                <td>1</td>
                <td>62 (D4)</td>
                <td>0</td>
                <td>结束音符</td>
            </tr>
        </tbody>
    </table>
    <p>这个深度追踪的例子展示了转换器不仅仅是简单的命令替换，而是一个真正理解音乐上下文、模拟硬件行为并智能生成富有表现力的MIDI事件的复杂系统。</p>

    <h3 id="29-终极稳定性修复未知vgm命令导致的崩溃">2.9. 终极稳定性：修复未知VGM命令导致的崩溃</h3>
    <p>在项目基本功能完成并通过了大量测试后，我们遇到了一个由特定文件 <code>07_Matoya's_Cave.vgm</code> 引发的程序崩溃问题。这次的调试和修复，极大地提升了程序的稳定性和对各类VGM文件的兼容性。</p>
    <ul>
        <li><strong>挑战</strong>:
            程序在处理 <code>07_Matoya's_Cave.vgm</code> 文件时，会直接崩溃退出，没有任何明确的错误信息。</li>
        <li><strong>攻克过程</strong>:
            <ol>
                <li><strong>日志先行</strong>: 面对这种“沉默的崩溃”，我们再次祭出法宝——在 <code>main.cpp</code> 的 <code>process_vgm_data</code> 函数中添加详细的日志输出。我们让程序在处理每个VGM命令前，都打印出当前的文件指针位置和正在处理的命令字节。</li>
                <li><strong>定位根源</strong>: 通过分析输出的 <code>log.txt</code> 文件，我们发现程序在处理到某个特定位置后，日志就中断了。查看该位置对应的VGM命令，我们发现是一个未在 <code>switch</code> 语句中明确处理的命令。问题就出在 <code>default</code> 分支的逻辑上：它仅仅将文件指针 <code>i</code> 递增了 <code>1</code>。</li>
                <li><strong>分析错误</strong>: VGM 格式中，许多命令都带有参数。例如，命令 <code>0x4f dd</code> 需要跳过1个字节的参数，而命令 <code>0x52 aa dd</code> 则需要跳过2个字节的参数。我们之前的 <code>default</code> 逻辑在遇到这些未知命令时，只跳过了命令本身，而没有跳过其后的参数字节。这导致程序将本应是参数的字节误读为下一个命令，从而引发连锁反应，最终导致解析逻辑彻底错乱并崩溃。</li>
            </ol>
        </li>
        <li><strong>最终修复：完善命令处理</strong>
            <p>我们没有简单地忽略这些命令，而是查阅了VGM格式规范，并对 <code>main.cpp</code> 中的 <code>process_vgm_data</code> 函数进行了扩展，为其 <code>switch</code> 语句添加了对一系列之前未处理命令的“跳过”逻辑。这确保了即使我们当前不需要利用这些命令的功能，解析器也能正确地越过它们及其参数，保持文件指针的同步。</p>
            <p><strong>新增处理的VGM命令包括：</strong></p>
            <table>
                <thead>
                    <tr>
                        <th>VGM 命令 (Hex)</th>
                        <th>长度 (字节)</th>
                        <th>处理方式</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><code>0x4f</code></td><td>2</td><td>跳过 (命令 + 1字节数据)</td></tr>
                    <tr><td><code>0x51</code> - <code>0x5f</code></td><td>3</td><td>跳过 (命令 + 2字节数据)</td></tr>
                    <tr><td><code>0xa0</code></td><td>3</td><td>跳过 (命令 + 2字节数据)</td></tr>
                    <tr><td><code>0xb0</code> - <code>0xbf</code></td><td>3</td><td>跳过 (命令 + 2字节数据)</td></tr>
                    <tr><td><code>0xc0</code> - <code>0xdf</code></td><td>4</td><td>跳过 (命令 + 3字节数据)</td></tr>
                    <tr><td><code>0xe0</code> - <code>0xff</code></td><td>5</td><td>跳过 (命令 + 4字节数据)</td></tr>
                </tbody>
            </table>
            <p>通过为这些命令添加正确的 <code>case</code> 分支并增加相应的文件指针偏移量，我们彻底解决了这个崩溃问题。这次修复使得转换器变得更加健壮，能够兼容更多不完全符合我们预期的、但语法正确的VGM文件。</p>
        </li>
    </ul>

    <h2 id="3-程序工作流程详解">3. 程序工作流程详解</h2>
    <p><code>vgm_ws_to_mid</code> 的核心是一个状态机，它模拟 WonderSwan 声音芯片的行为，并将状态变化实时翻译为 MIDI 事件。</p>
    <h3 id="31-概览">3.1. 概览</h3>
    <ol>
        <li><strong>读取 (Read)</strong>: <code>VgmReader</code> 负责加载整个VGM文件到内存中，并提供文件头信息（如循环偏移量、数据起始位置）的访问接口。</li>
        <li><strong>处理 (Process)</strong>: <code>main</code> 函数中的 <code>process_vgm_data</code> 是整个程序的核心驱动。它通过一个巨大的 <code>for</code> 循环遍历VGM数据块，并使用一个 <code>switch</code> 语句来分发处理每一个VGM命令：
            <ul>
                <li><strong><code>0x51 aa dd</code> (WonderSwan端口写入)</strong>: 将地址 <code>aa</code> 和数据 <code>dd</code> 传递给 <code>WonderSwanChip</code> 进行模拟。这是最核心的命令。</li>
                <li><strong><code>0x61 nn nn</code> (等待)</strong>: 调用 <code>WonderSwanChip::advance_time</code>，将等待的采样数转换为MIDI ticks，推进时间轴。</li>
                <li><strong><code>0x62</code> (等待735个采样)</strong>: 同上，但为固定值。</li>
                <li><strong><code>0x63</code> (等待882个采样)</strong>: 同上，但为固定值。</li>
                <li><strong><code>0x7n</code> (等待 n+1 个采样)</strong>: 同上，为短时等待。</li>
                <li><strong><code>0x66</code> (数据块结束)</strong>: 标志着VGM数据流的正常结束，循环终止。</li>
                <li><strong>其他已识别命令 (如 <code>0x4f</code>, <code>0x52-0x5f</code>, <code>0xa0</code> 等)</strong>: 这些是其他芯片的命令或VGM的扩展功能。当前转换器不需要使用它们，但为了保证解析的连续性，程序会根据命令规范，正确地跳过这些命令及其参数，确保文件指针指向下一条有效命令。这是程序稳定性的关键。</li>
            </ul>
        </li>
        <li><strong>模拟与翻译 (Simulate & Translate)</strong>: <code>WonderSwanChip</code> 接收端口写入数据，更新内部寄存器状态（如频率、音量）。每次更新后，它会调用 <code>check_state_and_update_midi</code> 函数，检查通道状态是否发生变化（如音符开关、音高变化、音量变化）。</li>
        <li><strong>生成 (Generate)</strong>: 如果检测到有意义的状态变化，<code>WonderSwanChip</code> 会调用 <code>MidiWriter</code> 生成相应的 MIDI 事件（Note On/Off, Control Change），并附上当前精确的 MIDI tick 时间。</li>
        <li><strong>循环 (Loop)</strong>: 在处理完整个 VGM 文件后，如果检测到了循环点，<code>main</code> 函数会指示 <code>MidiWriter</code> 将记录下来的循环部分的 MIDI 事件复制一份，并附加到每个轨道的末尾，从而实现无缝循环。</li>
        <li><strong>写入 (Write)</strong>: 所有 VGM 命令处理完毕后，<code>MidiWriter</code> 将所有生成的事件（包括复制的循环部分）组装成一个标准的 MIDI 文件并保存到磁盘。</li>
    </ol>
    <h3 id="32-关键组件">3.2. 关键组件</h3>
    <ul>
        <li><strong><code>main.cpp</code></strong>: 程序入口和总控制器。负责解析命令行参数，实例化 <code>VgmReader</code>, <code>MidiWriter</code>, 和 <code>WonderSwanChip</code>。其核心是 <code>process_vgm_data</code> 函数，该函数包含一个大型 <code>switch</code> 语句，作为VGM命令的“分发中心”，驱动整个转换流程，并实现循环逻辑。</li>
        <li><strong><code>VgmReader.h/.cpp</code></strong>: VGM 文件加载器。它负责将VGM文件完整读入内存，并解析文件头（Header）以提取关键的元数据，如数据起始偏移量 (<code>0x34</code>) 和循环偏移量 (<code>0x1C</code>)。</li>
        <li><strong><code>WonderSwanChip.h/.cpp</code></strong>: <strong>转换核心</strong>。
            <ul>
                <li>内部维护一个 <code>io_ram</code> 数组来模拟芯片的 256 个 I/O 寄存器。</li>
                <li><code>write_port()</code> 方法是关键入口，它根据写入的端口地址更新内部状态变量（如 <code>channel_periods</code>, <code>channel_volumes_left</code> 等）。</li>
                <li><code>check_state_and_update_midi()</code> 是状态机的大脑。每次状态更新后，它会比较当前状态和上一状态，判断是否需要生成 MIDI 事件，从而智能地处理连奏（pitch bend）、重触发（re-trigger）和音量包络。</li>
                <li>新增了 <code>get_channel_count()</code> 方法，用于动态返回芯片管理的音轨总数，解决了硬编码导致的越界访问问题。</li>
            </ul>
        </li>
        <li><strong><code>MidiWriter.h/.cpp</code></strong>: MIDI 文件生成器。它经过了重大重构，现在内部使用 <code>std::vector&lt;MidiEvent&gt;</code> 来存储结构化的 MIDI 事件，而不是原始字节。这使得对事件的精确操作成为可能。它提供了一系列简单的 API（如 <code>add_note_on</code>, <code>add_control_change</code>）来构建轨道，并新增了 <code>copy_events_from</code> 方法，可以高效地从一个时间点复制事件到另一个时间点，这是实现无缝循环的关键。该方法现在还内置了逻辑，用于自动关闭在循环块边界处未闭合的音符。当转换结束时，<code>write_to_file()</code> 方法会动态地将事件列表序列化为标准的 MIDI 文件。</li>
    </ul>
    <h3 id="33-关键公式与常量">3.3. 关键公式与常量</h3>
    <ul>
        <li><strong>时序转换</strong>:<br>
        <code>const double SAMPLES_TO_TICKS = (480.0 * 120.0) / (44100.0 * 60.0);</code></li>
        <li><strong>音高转换</strong>:<br>
        <code>double freq = (3072000.0 / (2048.0 - period)) / 32.0;</code><br>
        <code>int note = static_cast&lt;int&gt;(round(69 + 12 * log2(freq / 440.0)));</code></li>
        <li><strong>音量映射</strong>:<br>
        <code>double normalized_vol = vgm_vol / 15.0;</code><br>
        <code>double curved_vol = pow(normalized_vol, 0.3);</code><br>
        <code>int velocity = static_cast&lt;int&gt;(curved_vol * 127.0);</code></li>
    </ul>

    <h2 id="4-如何编译与运行">4. 如何编译与运行</h2>
    <p>本项目使用 g++ 编译器在 bash 环境下进行编译。</p>
    <ul>
        <li><strong>编译</strong>:
            <pre><code>g++ -std=c++17 -o vgm_ws_to_mid/vgm2mid.exe vgm_ws_to_mid/main.cpp vgm_ws_to_mid/VgmReader.cpp vgm_ws_to_mid/WonderSwanChip.cpp vgm_ws_to_mid/MidiWriter.cpp -static</code></pre>
        </li>
        <li><strong>运行</strong>:
            <pre><code>vgm_ws_to_mid/vgm2mid.exe [input_vgm_file] [output_mid_file]</code></pre>
            例如:
            <pre><code>vgm_ws_to_mid/vgm2mid.exe 02_Prelude.vgm vgm_ws_to_mid/output.mid</code></pre>
        </li>
    </ul>
    <hr>
    <p>这份文档全面总结了我们的工作。希望它能为后续的开发和维护提供清晰的指引。</p>
</body>
</html>
