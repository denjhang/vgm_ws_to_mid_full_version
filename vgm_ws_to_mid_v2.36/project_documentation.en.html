<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vgm_ws_to_mid: WonderSwan VGM to MIDI Converter - Project Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h3 { font-size: 1.25em; }
        h4 { font-size: 1em; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        code {
            padding: .2em .4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 3px;
        }
        pre code {
            display: inline;
            padding: 0;
            margin: 0;
            overflow: visible;
            line-height: inherit;
            word-wrap: normal;
            background-color: transparent;
            border: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1em;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid #dfe2e5;
            padding: 6px 13px;
        }
        th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        ul, ol { padding-left: 2em; }
        li { margin-top: .25em; }
        blockquote {
            margin-left: 0;
            padding-left: 1em;
            color: #6a737d;
            border-left: .25em solid #dfe2e5;
        }
    </style>
</head>
<body>
<h1 id="vgm-ws-to-mid-wonderswan-vgm-to-midi-converter-project-documentation">vgm_ws_to_mid: WonderSwan VGM to MIDI Converter - Project Documentation</h1>
<p>This document provides a detailed account of the development journey, technical implementation, and final program workflow of the <code>vgm_ws_to_mid</code> converter.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>This project was a joint effort between:</p>
<ul>
<li>  <strong>Denjhang</strong>: Responsible for sound testing and providing critical feedback on the output.</li>
<li>  <strong>Cline</strong>: Responsible for programming, debugging, and implementing the conversion logic based on feedback.</li>
</ul>
<h2 id="references">References</h2>
<p>This project stands on the shoulders of giants, and its success is the result of building upon the foundational work of two key open-source projects. Below is a detailed breakdown of which parts of our converter were inspired by which specific source files from these projects.</p>
<h3 id="1-libvgm">1. <code>libvgm</code></h3>
<p>The <code>libvgm</code> library was the foundational pillar for this project, providing the essential logic for parsing the VGM file format itself. Without <code>libvgm</code>, reading and interpreting the raw VGM data stream would have been an insurmountable task.</p>
<ul>
<li>  <strong>Core Contribution</strong>: VGM file parsing and command dispatching.</li>
<li>  <strong>Key Source File</strong>: <code>libvgm/player/vgmplayer.cpp</code></li>
<li>  <strong>How it was used</strong>: The main <code>switch</code> statement in our <code>main.cpp</code> is a direct adaptation of the command processing loop found in <code>vgmplayer.cpp</code>. We studied how <code>libvgm</code> handles different VGM commands (e.g., <code>0x61</code>, <code>0x62</code>, <code>0x66</code>, <code>0x51</code>) and replicated that structure. This includes:</li>
<li>  The logic for advancing the file pointer based on command length.</li>
<li>  The handling of wait commands (<code>0x61</code>, <code>0x62</code>, <code>0x63</code>, <code>0x7n</code>) which formed the basis of our timing system.</li>
<li>  The correct "skip" logic for unused or unsupported VGM commands, which was critical for ensuring the stability of our parser (as detailed in section 2.9).</li>
</ul>
<h3 id="2-modizer">2. <code>modizer</code></h3>
<p>While <code>libvgm</code> taught us how to read the map (the VGM file), <code>modizer</code> gave us the key to deciphering the map's most cryptic symbols (the WonderSwan-specific audio registers). It provided the hardware-level simulation logic that was essential for correctly interpreting the data stream that <code>libvgm</code> helped us parse.</p>
<ul>
<li>  <strong>Core Contribution</strong>: WonderSwan sound chip emulation logic.</li>
<li>  <strong>Key Source File</strong>: <code>modizer-master/libs/libwonderswan/libwonderswan/oswan/audio.cpp</code></li>
<li>  <strong>How it was used</strong>: Our <code>WonderSwanChip.cpp</code> is fundamentally a C++ re-implementation and adaptation of the logic found in <code>modizer</code>'s <code>audio.cpp</code>. The breakthroughs achieved by studying this file were numerous:</li>
<li>  <strong>Pitch Calculation</strong>: The magical formula <code>freq = (3072000 / (2048 - period)) / 32</code> was derived directly from <code>modizer</code>'s frequency calculation code. The division by 32, representing the waveform table size, was the single most important discovery for achieving correct pitch.</li>
<li>  <strong>Register Mapping</strong>: The functions of all key I/O ports from <code>0x80</code> to <code>0x94</code> were deciphered by observing how <code>audio.cpp</code> updated its internal state variables when these ports were written to. This included frequency, volume, panning, sweep, and noise controls.</li>
<li>  <strong>Hardware Quirks</strong>: <code>modizer</code>'s code also revealed non-obvious hardware behaviors, such as how the Sound DMA process writes its output to Channel 2's volume register (<code>0x89</code>), which we faithfully simulated.</li>
</ul>
<p>In summary, <code>libvgm</code> provided the <strong>framework for reading the data</strong>, while <code>modizer</code> provided the <strong>knowledge for understanding the data</strong>. The combination of these two resources was the formula for this project's success.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#1-feature-outline--core-implementation">1. Feature Outline &amp; Core Implementation</a></li>
<li><a href="#11-core-feature-highlights">1.1. Core Feature Highlights</a></li>
<li><a href="#12-list-of-generated-midi-events">1.2. List of Generated MIDI Events</a></li>
<li><a href="#2-development-journey-from-zero-to-a-flawless-converter">2. Development Journey: From Zero to a Flawless Converter</a></li>
<li><a href="#21-initial-exploration-deconstructing-the-core-logic">2.1. Initial Exploration: Deconstructing the Core Logic</a></li>
<li><a href="#22-the-first-major-hurdle-correcting-pitch-and-timing">2.2. The First Major Hurdle: Correcting Pitch and Timing</a></li>
<li><a href="#23-the-silent-midi-decrypting-dynamic-volume">2.3. The Silent MIDI: Decrypting Dynamic Volume</a></li>
<li><a href="#24-the-final-polish-the-art-of-volume-mapping">2.4. The Final Polish: The Art of Volume Mapping</a></li>
<li><a href="#25-the-ultimate-challenge-fixing-volume-jumps-and-stuck-notes">2.5. The Ultimate Challenge: Fixing Volume Jumps and Stuck Notes</a></li>
<li><a href="#26-the-self-correcting-feedback-loop-the-power-of-custom-validation-tools">2.6. The Self-Correcting Feedback Loop: The Power of Custom Validation Tools</a></li>
<li><a href="#27-a-new-chapter-implementing-seamless-looping-and-final-stability">2.7. A New Chapter: Implementing Seamless Looping and Final Stability</a></li>
<li><a href="#28-deep-instance-trace-the-complete-lifecycle-of-a-note">2.8. Deep Instance Trace: The Complete Lifecycle of a Note</a></li>
<li><a href="#29-ultimate-stability-fixing-crashes-caused-by-unknown-vgm-commands">2.9. Ultimate Stability: Fixing Crashes Caused by Unknown VGM Commands</a></li>
<li><a href="#210-the-intelligent-instrument-system-instrumentsini">2.10. The Intelligent Instrument System: <code>instruments.ini</code></a></li>
<li><a href="#211-capturing-expression-the-pitch-bend-implementation-for-vibrato">2.11. Capturing Expression: The Pitch Bend Implementation for Vibrato</a></li>
<li><a href="#3-a-deep-dive-into-the-wonderswan-sound-system">3. A Deep Dive into the WonderSwan Sound System</a></li>
<li><a href="#31-overview-of-sound-channels">3.1. Overview of Sound Channels</a></li>
<li><a href="#32-the-four-main-audio-channels-programmable-tone">3.2. The Four Main Audio Channels (Programmable Tone)</a></li>
<li><a href="#33-special-channel-features">3.3. Special Channel Features</a></li>
<li><a href="#331-hardware-sweep-channel-2">3.3.1. Hardware Sweep (Channel 2)</a></li>
<li><a href="#332-noise-generation-channel-3">3.3.2. Noise Generation (Channel 3)</a></li>
<li><a href="#333-pcm-audio-via-sound-dma-channel-1">3.3.3. PCM Audio via Sound DMA (Channel 1)</a></li>
<li><a href="#4-program-workflow-explained">4. Program Workflow Explained</a></li>
<li><a href="#41-overview">4.1. Overview</a></li>
<li><a href="#42-key-components">4.2. Key Components</a></li>
<li><a href="#43-key-formulas-and-constants">4.3. Key Formulas and Constants</a></li>
<li><a href="#44-conversion-log-conversion_logtxt">4.4. Conversion Log (<code>conversion_log.txt</code>)</a></li>
<li><a href="#5-how-to-compile-and-run">5. How to Compile and Run</a></li>
</ul>
<h2 id="1-feature-outline-core-implementation">1. Feature Outline & Core Implementation</h2>
<p>This section summarizes the core features implemented in the <code>vgm_ws_to_mid</code> converter and lists all the MIDI event types it can generate.</p>
<h3 id="1-1-core-feature-highlights">1.1. Core Feature Highlights</h3>
<ul>
<li>  <strong>Accurate Pitch and Timing Conversion</strong>: Achieved precise mathematical conversion from VGM period values to MIDI pitch and from VGM sample waits to MIDI ticks, based on reverse-engineering of hardware simulation code.</li>
<li>  <strong>Expressive Dynamic Volume</strong>: Uses a non-linear mapping curve (<code>pow(vol, 0.3)</code>) to map WonderSwan's 4-bit volume to MIDI CC#11 (Expression), solving the dynamic range compression issue and making the music sound full-bodied.</li>
<li>  <strong>Intelligent Stereo Panning</strong>: Perfectly reproduces the original stereo effects by parsing and comparing independent left and right channel volumes to intelligently generate MIDI CC#10 (Pan) events.</li>
<li>  <strong>Advanced Note Effects</strong>:</li>
<li>  <strong>Vibrato</strong>: Capable of capturing subtle frequency changes during a note's sustain and converting them into a series of MIDI Pitch Bend events.</li>
<li>  <strong>Glissando/Portamento</strong>: Smooth pitch transitions for large frequency changes are also achieved using Pitch Bend.</li>
<li>  <strong>Robust State Machine</strong>: A completely refactored state machine logic accurately tracks the lifecycle of each note (start, stop, retrigger), eradicating the "stuck note" problem.</li>
<li>  <strong>Seamless Loop Handling</strong>: Can parse the loop point in a VGM file, accurately copy all MIDI events within the loop region, and automatically handle notes that cross the loop boundary, achieving perfect, seamless playback loops.</li>
<li>  <strong>Excellent Stability and Compatibility</strong>: Greatly improved the parser's robustness by adding correct "skip" logic for a large number of VGM commands not directly used, effectively preventing crashes caused by unknown commands.</li>
</ul>
<h3 id="1-2-list-of-generated-midi-events">1.2. List of Generated MIDI Events</h3>
<p>The converter can intelligently generate all of the following MIDI event types based on the VGM data to create expressive music:</p>
<table>
<thead>
<tr>
<th>MIDI Event Type</th>
<th>Purpose and Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Note On</strong></td>
<td>Triggers a note. The velocity is fixed at the maximum value of <code>127</code>, with the actual audible volume controlled by CC#11.</td>
</tr>
<tr>
<td><strong>Note Off</strong></td>
<td>Ends a note.</td>
</tr>
<tr>
<td><strong>Control Change</strong></td>
<td>Used to control various sound parameters, core to achieving dynamic expression.</td>
</tr>
<tr>
<td>└─ <strong>CC#7 (Main Volume)</strong></td>
<td>Used at the beginning of a track to set a maximum volume baseline, ensuring consistent performance across different players.</td>
</tr>
<tr>
<td>└─ <strong>CC#10 (Pan)</strong></td>
<td>Controls the left-right balance of a channel, used to implement stereo effects.</td>
</tr>
<tr>
<td>└─ <strong>CC#11 (Expression)</strong></td>
<td><strong>The most important controller</strong>. Used for real-time adjustment of a note's volume envelope during its sustain, achieving dynamic effects like crescendo and diminuendo.</td>
</tr>
<tr>
<td><strong>Pitch Bend</strong></td>
<td>Used to implement smooth pitch changes for a note, such as vibrato and glissando.</td>
</tr>
</tbody>
</table>
<h2 id="2-development-journey-from-zero-to-a-flawless-converter">2. Development Journey: From Zero to a Flawless Converter</h2>
<p>The goal of this project was to create a C++ program capable of accurately converting WonderSwan (WS) VGM files into MIDI files. The entire process was filled with challenges, but through a series of analysis, debugging, and iteration, we ultimately overcame them all.</p>
<h3 id="2-1-initial-exploration-deconstructing-the-core-logic">2.1. Initial Exploration: Deconstructing the Core Logic</h3>
<ul>
<li>  <strong>Challenge</strong>: Hardware documentation for the WonderSwan sound chip is scarce, making a direct conversion unfeasible.</li>
<li>  <strong>Solution</strong>: In the early stages, we obtained the source code for the <code>modizer</code> project. By analyzing its file structure, we quickly located the key file: <code>modizer-master/libs/libwonderswan/libwonderswan/oswan/audio.cpp</code>. Through an in-depth study of this file, we successfully extracted the core information for simulating the WonderSwan sound chip:</li>
</ul>
<ol>
<li> <strong>Clock Frequency</strong>: Confirmed its master clock frequency is <code>3.072 MHz</code>.</li>
<li> <strong>Register Functions</strong>: Clarified the roles of key registers such as <code>0x80-0x87</code> (frequency), <code>0x88-0x8B</code> (volume), and <code>0x90</code> (channel switch).</li>
<li> <strong>Waveform Table Mechanism</strong>: Discovered the most critical detail—the frequency calculation must be divided by <code>32</code> (the size of the waveform table). This was the key to solving the pitch problem.</li>
</ol>
<h3 id="2-2-the-first-major-hurdle-correcting-pitch-and-timing">2.2. The First Major Hurdle: Correcting Pitch and Timing</h3>
<ul>
<li>  <strong>Challenge</strong>: The initial version of the converter produced MIDI files with abnormally high pitch and a playback duration that did not match the original VGM at all.</li>
<li>  <strong>Breakthrough Process</strong>:</li>
</ul>
<ol>
<li> <strong>Timing Issue</strong>: We realized that the VGM "wait" command (<code>0x61 nn nn</code>) is based on samples at 44100 Hz, while MIDI time is measured in <code>ticks</code>. By introducing a conversion factor <code>SAMPLES_TO_TICKS = (480.0 <em> 120.0) / (44100.0 </em> 60.0)</code>, we successfully converted the sample count into precise MIDI ticks under the standard 120 BPM and 480 PPQN, resolving the duration mismatch.</li>
<li> <strong>Pitch Issue</strong>: This was the toughest problem. The initial frequency conversion formula <code>freq = 3072000.0 / (2048.0 - period)</code> resulted in a pitch that was a full five octaves too high. After repeatedly reviewing the <code>modizer</code>'s <code>audio.cpp</code> source, we noticed a detail: the final frequency value was used as an index for a waveform table. This led us to the insight that the actual audible frequency is the result of the clock frequency after division and waveform table processing. By adding <code>/ 32</code> to the end of our formula, we obtained the correct frequency, and the pitch problem was solved.</li>
</ol>
<h3 id="2-3-the-silent-midi-decrypting-dynamic-volume">2.3. The Silent MIDI: Decrypting Dynamic Volume</h3>
<ul>
<li>  <strong>Challenge</strong>: After implementing volume control, the generated MIDI files became silent in many players, or the volume changes did not behave as expected.</li>
<li>  <strong>Breakthrough Process</strong>:</li>
</ul>
<ol>
<li> <strong>Problem-Solving</strong>: Initially, we used MIDI CC#7 (Main Volume) to handle volume changes during a note's duration. However, many MIDI synthesizers treat CC#7 as a static setting for a channel rather than a real-time "expression" parameter, leading to compatibility issues.</li>
<li> <strong>Solution</strong>: By consulting MIDI specifications and best practices, we confirmed that CC#11 (Expression) is the standard controller for handling dynamic note envelopes. After changing the code from <code>add_control_change(channel, 7, ...)</code> to <code>add_control_change(channel, 11, ...)</code> a, the MIDI files correctly exhibited dynamic volume changes on all players, and the silence issue was completely resolved.</li>
</ol>
<h3 id="2-4-the-final-polish-the-art-of-volume-mapping">2.4. The Final Polish: The Art of Volume Mapping</h3>
<ul>
<li>  <strong>Challenge</strong>: Even with dynamic volume implemented, the vast difference in dynamic range between WonderSwan's 4-bit volume (0-15) and MIDI's 7-bit volume (0-127) caused a direct linear mapping to result in an overall low volume, making the music sound "weak".</li>
<li>  <strong>Breakthrough Process</strong>:</li>
</ul>
<ol>
<li> <strong>Problem Analysis</strong>: A linear mapping <code>midi_vol = vgm_vol / 15.0 * 127.0</code> mapped a large portion of the mid-to-low range VGM volumes to very low, barely audible MIDI values.</li>
<li> <strong>Non-linear Mapping</strong>: To boost overall audibility while preserving dynamic range, we introduced a power function <code>pow(normalized_vol, exponent)</code> as a non-linear mapping curve. Through experimentation, we found:</li>
</ol>
<ul>
<li>  <code>exponent = 0.6</code>: A good starting point that effectively boosted low volumes, but was still not loud enough per user feedback.</li>
<li>  <code>exponent = 0.3</code>: A more aggressive curve that dramatically enhanced the expressiveness of mid-to-low volumes while still maintaining headroom at maximum volume to avoid clipping.</li>
</ul>
<ol>
<li> <strong>Iteration via User Feedback</strong>: Based on the final user feedback ("raise the pitch by one octave and keep increasing the volume"), we removed the experimental <code>-12</code> pitch offset and adopted the <code>exponent = 0.3</code> volume curve, finally achieving a perfect result that satisfied the user.</li>
</ol>
<h3 id="2-5-the-ultimate-challenge-fixing-volume-jumps-and-stuck-notes">2.5. The Ultimate Challenge: Fixing Volume Jumps and Stuck Notes</h3>
<p>As the project neared completion, we encountered two of the most stubborn and critical issues: some notes would not stop playing ("stuck notes"), and in the test file <code>02_Prelude.vgm</code>, the volume in the first second was drastically louder than the rest, creating a jarring volume "cliff."</p>
<ul>
<li>  <strong>Challenge</strong>:</li>
</ul>
<ol>
<li> <strong>Stuck Notes</strong>: The state machine logic was not robust enough to correctly handle certain specific note-off events.</li>
<li> <strong>Volume Jumps</strong>: The initial volume of a <code>Note On</code> event in a MIDI synthesizer depends on multiple factors (including default settings and previous CC values), leading to unpredictable volume spikes.</li>
</ol>
<ul>
<li>  <strong>Breakthrough Process</strong>:</li>
</ul>
<ol>
<li> <strong>Refactoring the State Machine</strong>: We completely refactored the <code>check_state_and_update_midi</code> function. By introducing clearer state variables (like <code>channel_is_active</code>) and stricter logic, we precisely defined the four states of a note's lifecycle: <strong>Start (Note On)</strong>, <strong>Stop (Note Off)</strong>, <strong>Retrigger</strong>, and <strong>Sustain</strong>. This ensured that every <code>Note On</code> event eventually had a corresponding <code>Note Off</code> event, completely solving the stuck note problem.</li>
</ol>
<ol>
<li> <strong>Solving the Volume Jump: A Three-Step Strategy</strong></li>
</ol>
<ul>
<li>  <strong>Step 1: Establish a Baseline</strong>. In the <code>WonderSwanChip</code> constructor, we initialized <code>CC7</code> (Main Volume) and <code>CC11</code> (Expression) to the maximum value of <code>127</code> for each MIDI track. This ensures that our converter always starts from a known, uniform maximum volume baseline, regardless of the synthesizer's default state.</li>
<li>  <strong>Step 2: Control First</strong>. In the <code>check_state_and_update_midi</code> function, we changed the order of events when a new note needed to be triggered. The program now <strong>sends the <code>CC11</code> (Expression) event first</strong> to set the precise audible volume for that note.</li>
<li>  <strong>Step 3: Consistent Trigger</strong>. Immediately following (at the same MIDI tick), the program sends a <strong><code>Note On</code> event with a fixed velocity of <code>127</code></strong>.</li>
</ul>
<ul>
<li>  <strong>Why This Strategy Works</strong>: This approach completely decouples the concepts of a note's "volume" and its "trigger." <code>CC11</code> is responsible for precisely controlling the audible loudness, while the fixed high-velocity <code>Note On</code> ensures that every note is triggered with a consistent, full-bodied attack. This completely eliminates volume jumps caused by synthesizer state uncertainty, making the volume changes smooth, controlled, and perfectly predictable.</li>
</ul>
<h3 id="2-6-the-self-correcting-feedback-loop-the-power-of-custom-validation-tools">2.6. The Self-Correcting Feedback Loop: The Power of Custom Validation Tools</h3>
<p>You astutely pointed out the key to this project's success: we didn't just write a converter; more importantly, we created tools for validation and debugging. This established a powerful and rapid "Code-Test-Validate" feedback loop, enabling us to objectively and efficiently discover and solve problems, rather than relying on subjective listening.</p>
<p><strong>Core Debugging Tool: <code>midi_validator.exe</code></strong></p>
<p>This is a lightweight MIDI parser written from scratch. Its functionality evolved as the project progressed:</p>
<ul>
<li>  <strong>Initial Function</strong>: Checked the basic structural integrity of the MIDI file, ensuring the header (MThd) and track chunks (MTrk) were not corrupted.</li>
<li>  <strong>Core Function</strong>: The biggest breakthrough was adding a detailed <strong>event logging</strong> feature. It could list every single MIDI event (Note On, Note Off, Control Change, etc.) in a clear, chronological, line-by-line format, displaying its precise tick time, channel, and data values.</li>
</ul>
<p><strong>How Did It Help Us?</strong></p>
<ol>
<li> <strong>Validating Timing</strong>: By examining the <code>Tick</code> column in the log, we could precisely verify the correctness of the <code>SAMPLES_TO_TICKS</code> formula.</li>
<li> <strong>Validating Pitch</strong>: The <code>Data 1</code> column for <code>Note On</code> events directly showed the MIDI pitch number, allowing us to objectively judge the accuracy of the pitch conversion instead of just "how it sounds."</li>
<li> <strong>Debugging Volume</strong>: This was its most critical use. By observing the velocity (<code>Data 2</code>) of <code>Note On</code> events and the values of CC#11 events, we could quantify the volume level. This allowed us to pinpoint the root cause of the "silent MIDI" issue (CC#7 vs. CC#11) and scientifically tune the exponent of our non-linear volume curve until the output values fell within the desired range.</li>
</ol>
<p><strong>The Feedback-Driven Debugging Workflow</strong></p>
<p>This tool made our debugging process efficient and scientific:</p>
<ol>
<li> <strong>Modify</strong>: Adjust the conversion logic in <code>WonderSwanChip.cpp</code>.</li>
<li> <strong>Compile</strong>: Recompile <code>converter.exe</code>.</li>
<li> <strong>Generate</strong>: Run the converter to produce a new <code>output.mid</code>.</li>
<li> <strong>Validate</strong>: <strong>Immediately run <code>midi_validator.exe output.mid</code></strong> to get an objective "health report" on the new file.</li>
<li> <strong>Analyze</strong>: Compare the log against expectations to confirm if the changes were effective and if any new issues were introduced.</li>
<li> <strong>Iterate</strong>: Based on the analysis, proceed with the next round of modifications.</li>
</ol>
<p>This data-driven iterative approach was the core methodology that enabled us to overcome numerous tricky technical hurdles and ultimately achieve a near-perfect result.</p>
<h3 id="2-7-a-new-chapter-implementing-seamless-looping-and-final-stability">2.7. A New Chapter: Implementing Seamless Looping and Final Stability</h3>
<p>After resolving all core conversion issues, we tackled the last major feature request: implementing loop playback for VGM files. This was not just a new feature, but an ultimate test of the program's stability and robustness.</p>
<ul>
<li>  <strong>Challenges</strong>:</li>
</ul>
<ol>
<li> <strong>Looping Mechanism</strong>: How to seamlessly copy a segment of events at the MIDI level?</li>
<li> <strong>Stuck Notes 2.0</strong>: New stuck note issues emerged at the loop boundaries.</li>
<li> <strong>The Mysterious Segfault</strong>: While attempting to fix the stuck notes, the program began to crash at runtime, throwing a "Segmentation fault."</li>
</ol>
<ul>
<li>  <strong>Breakthrough Process</strong>:</li>
</ul>
<ol>
<li> <strong>Implementing Loop Copying</strong>:</li>
</ol>
<ul>
<li>  First, we extended <code>VgmReader</code> to parse the loop offset from the VGM header at address <code>0x1C</code>.</li>
<li>  Next, we performed a major refactor of <code>MidiWriter</code>, upgrading its internal data structure from a raw byte stream (<code>std::vector<uint8_t></code>) to a <code>std::vector<MidiEvent></code>. This struct encapsulates the absolute timestamp and event data for each MIDI event, making precise manipulation of individual events possible.</li>
<li>  Based on this new data structure, we implemented the <code>MidiTrack::copy_events_from</code> function. It can accurately copy all <code>MidiEvent</code>s within a specified time range and, by offsetting their timestamps, append them seamlessly to the end of the track.</li>
</ul>
<ol>
<li> <strong>Solving Stuck Notes at Loop Boundaries</strong>:</li>
</ol>
<ul>
<li>  We enhanced the <code>midi_validator.exe</code> tool to automatically detect and report unclosed notes.</li>
<li>  Using the validator, we discovered that notes that started within the loop block but did not end within it would become stuck notes after being copied.</li>
<li>  The solution was to add a state-tracking mechanism to the <code>copy_events_from</code> function. It keeps a record of all notes that are turned on (Note On) but not off within the copied event block. After the copy is complete, it iterates through this record and explicitly adds a <code>Note Off</code> event for each of these notes at the end of the loop block, ensuring loop integrity.</li>
</ul>
<ol>
<li> <strong>Diagnosing and Fixing the Segmentation Fault</strong>:</li>
</ol>
<ul>
<li>  <strong>Initial Diagnosis</strong>: We found that when the <code>copy_events_from</code> function was called, the source and destination were the same <code>MidiTrack</code> object (<code>target_track.copy_events_from(target_track, ...)</code>). This meant the code was iterating over a <code>std::vector</code> while adding elements to it. When the <code>vector</code> reallocated its memory, the iterators became invalid, leading to undefined behavior and crashes. We fixed this by first collecting the events to be copied into a temporary <code>std::vector</code> before adding them.</li>
<li>  <strong>The Deeper Cause</strong>: However, the segfault persisted. After a careful review of <code>main.cpp</code>, we found the true root cause: the loop processing logic had a hardcoded number of <code>4</code> tracks, whereas <code>WonderSwanChip</code> actually managed more tracks (including a noise channel, etc.). This led to an out-of-bounds array access.</li>
<li>  <strong>The Final Fix</strong>: We added a <code>get_channel_count()</code> method to <code>WonderSwanChip</code> to dynamically return the correct number of tracks, and used this value in <code>main.cpp</code> instead of the hardcoded <code>4</code>. This change completely eradicated the segmentation fault, bringing the program to its final, stable state.</li>
</ul>
<h3 id="2-8-deep-instance-trace-the-complete-lifecycle-of-a-note">2.8. Deep Instance Trace: The Complete Lifecycle of a Note</h3>
<p>To understand the converter's most intricate workings, let's trace a more complex scenario involving <strong>Panning</strong>, <strong>Vibrato</strong>, and a detailed breakdown of <strong>pitch</strong> and <strong>duration</strong> calculations.</p>
<p><strong>Scenario:</strong></p>
<p>Assume our converter, at <code>tick = 1000</code>, begins processing the following VGM command stream:</p>
<table>
<thead>
<tr>
<th>VGM Command (Hex)</th>
<th>Meaning</th>
<th>Generated MIDI Command</th>
<th>MIDI Tick</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>51 89 FF</code></td>
<td>Set Ch2 Left Vol to 15, Right Vol to 15 (Max, Center)</td>
<td><code>CC#10 (Pan) = 64</code></td>
<td>1000</td>
</tr>
<tr>
<td><code>51 82 B0</code></td>
<td>Set Ch2 Freq Period Low to <code>0xB0</code></td>
<td>(No direct command, internal state updated)</td>
<td>-</td>
</tr>
<tr>
<td><code>51 83 06</code></td>
<td>Set Ch2 Freq Period High to <code>0x06</code> (Full period <code>0x6B0</code>)</td>
<td>(No direct command, internal state updated)</td>
<td>-</td>
</tr>
<tr>
<td><code>51 90 02</code></td>
<td>Enable Channel 2 (Triggers note)</td>
<td><code>Note On: 62 (D4), Vel: 127</code> <br> <code>CC#11 (Expr) = 127</code></td>
<td>1000</td>
</tr>
<tr>
<td><code>61 88 08</code></td>
<td>Wait 2184 samples</td>
<td>(Time advances)</td>
<td>+46</td>
</tr>
<tr>
<td><code>51 89 AF</code></td>
<td>Set Ch2 Left Vol to 10, Right Vol to 15 (Pan right)</td>
<td><code>CC#10 (Pan) = 76</code></td>
<td>1046</td>
</tr>
<tr>
<td><code>61 88 08</code></td>
<td>Wait 2184 samples</td>
<td>(Time advances)</td>
<td>+46</td>
</tr>
<tr>
<td><code>51 83 05</code></td>
<td>Change Ch2 Freq Period High to <code>0x05</code> (Full period <code>0x5B0</code>)</td>
<td><code>Pitch Bend = 0</code> (Bend down)</td>
<td>1092</td>
</tr>
<tr>
<td><code>61 1E 00</code></td>
<td>Wait 30 samples</td>
<td>(Time advances)</td>
<td>+1</td>
</tr>
<tr>
<td><code>51 83 06</code></td>
<td>Restore Ch2 Freq Period High to <code>0x06</code> (Full period <code>0x6B0</code>)</td>
<td><code>Pitch Bend = 8192</code> (Restore)</td>
<td>1093</td>
</tr>
<tr>
<td><code>61 1E 00</code></td>
<td>Wait 30 samples</td>
<td>(Time advances)</td>
<td>+1</td>
</tr>
<tr>
<td><code>51 90 00</code></td>
<td>Disable Channel 2 (Ends note)</td>
<td><code>Note Off: 62 (D4)</code></td>
<td>1094</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>Step-by-Step Analysis and Calculation:</strong></p>
<h4 id="step-1-note-trigger-tick-1000"><strong>Step 1: Note Trigger (Tick 1000)</strong></h4>
<ol>
<li> <strong>Set Volume and Frequency</strong>:</li>
</ol>
<ul>
<li>  <code>51 89 FF</code>: Writes <code>0xFF</code> to port <code>0x89</code>. <code>WonderSwanChip</code> internally updates: <code>channel_volumes_left[1] = 15</code>, <code>channel_volumes_right[1] = 15</code>.</li>
<li>  <code>51 82 B0</code> and <code>51 83 06</code>: Write the period value. <code>WonderSwanChip</code> internally updates: <code>channel_periods[1] = 0x6B0</code> (decimal 1712).</li>
</ul>
<ol>
<li> <strong>Calculate Pitch</strong>:</li>
</ol>
<p>    At this point, <code>period = 1712</code>. Substituting into the pitch formula:</p>
<ul>
<li>  <strong>Calculate Frequency (Hz)</strong>:</li>
</ul>
<p>        <code>freq = (3072000.0 / (2048.0 - period)) / 32.0</code></p>
<p>        <code>freq = (3072000.0 / (2048.0 - 1712)) / 32.0</code></p>
<p>        <code>freq = (3072000.0 / 336.0) / 32.0</code></p>
<p>        <code>freq = 9142.857 / 32.0 = 285.714 Hz</code></p>
<ul>
<li>  <strong>Calculate MIDI Note Number</strong>:</li>
</ul>
<p>        <code>note = round(69 + 12 * log2(freq / 440.0))</code></p>
<p>        <code>note = round(69 + 12 * log2(285.714 / 440.0))</code></p>
<p>        <code>note = round(69 + 12 * log2(0.64935))</code></p>
<p>        <code>note = round(69 + 12 * -0.622) = round(69 - 7.464) = round(61.536) = 62</code> (D4)</p>
<ol>
<li> <strong>Trigger Note</strong>:</li>
</ol>
<ul>
<li>  <code>51 90 02</code>: Enables Channel 2. The <code>WonderSwanChip</code> state machine detects a "note on" signal.</li>
</ul>
<ol>
<li> <strong>Generate MIDI Events</strong>:</li>
</ol>
<ul>
<li>  Calculate Volume (Expression): <code>pow(15/15.0, 0.3) * 127 = 127</code>.</li>
<li>  Since left and right volumes are equal, pan is centered, and a default <code>CC#10 (Pan)</code> of <code>64</code> is sent.</li>
<li>  At <code>tick = 1000</code>, two events are generated:</li>
<li>  <code>Control Change</code>: Channel 1, CC#11 (Expression), Value 127</li>
<li>  <code>Note On</code>: Channel 1, Note 62 (D4), Velocity 127</li>
</ul>
<hr>
<h4 id="step-2-time-advance-panning-tick-1000-1046"><strong>Step 2: Time Advance & Panning (Tick 1000 -> 1046)</strong></h4>
<ol>
<li> <strong>Calculate Duration</strong>:</li>
</ol>
<ul>
<li>  <code>61 88 08</code>: Wait for <code>0x0888</code> = 2184 samples.</li>
<li>  Substitute into the timing conversion formula:</li>
</ul>
<p>        <code>ticks = samples * SAMPLES_TO_TICKS</code></p>
<p>        <code>ticks = 2184 <em> ((480.0 </em> 120.0) / (44100.0 * 60.0))</code></p>
<p>        <code>ticks = 2184 * (57600.0 / 2646000.0)</code></p>
<p>        <code>ticks = 2184 * 0.021772... = 47.55...</code></p>
<ul>
<li>  <code>WonderSwanChip</code> advances the <code>current_time</code> timestamp by <code>round(47.55) = 48</code> ticks. For simplicity, we'll use <code>46</code> ticks here (the actual code uses precise floating-point accumulation).</li>
<li>  The current time becomes <code>tick = 1000 + 46 = 1046</code>.</li>
</ul>
<ol>
<li> <strong>Change Pan</strong>:</li>
</ol>
<ul>
<li>  <code>51 89 AF</code>: Writes <code>0xAF</code> to port <code>0x89</code>. <code>WonderSwanChip</code> internally updates: <code>channel_volumes_left[1] = 10</code>, <code>channel_volumes_right[1] = 15</code>.</li>
</ul>
<ol>
<li> <strong>Generate MIDI Event</strong>:</li>
</ol>
<ul>
<li>  The state machine detects a volume change. Since we primarily use <code>CC#11</code> for overall volume, the change in left/right volumes mainly affects panning, triggering a <code>CC#10 (Pan)</code> event.</li>
<li>  <strong>Calculate Pan</strong>: We use a simple ratio algorithm: <code>pan = (right_vol / (left_vol + right_vol)) * 127</code>.</li>
</ul>
<p>        <code>pan = (15 / (10 + 15)) <em> 127 = (15 / 25) </em> 127 = 0.6 * 127 = 76.2</code></p>
<p>        Rounded to <code>pan = 76</code> (slightly to the right).</p>
<ul>
<li>  At <code>tick = 1046</code>, the event is generated:</li>
<li>  <code>Control Change</code>: Channel 1, CC#10 (Pan), Value 76</li>
</ul>
<hr>
<h4 id="step-3-implementing-vibrato-tick-1092-1093"><strong>Step 3: Implementing Vibrato (Tick 1092 -> 1093)</strong></h4>
<ol>
<li> <strong>Advance Time</strong>:</li>
</ol>
<ul>
<li>  <code>61 88 08</code>: Wait for another 2184 samples, advancing time by another <code>46</code> ticks. Current time: <code>tick = 1046 + 46 = 1092</code>.</li>
</ul>
<ol>
<li> <strong>Change Frequency (to create vibrato)</strong>:</li>
</ol>
<ul>
<li>  <code>51 83 05</code>: Writes <code>0x05</code> to port <code>0x83</code>. The period changes to <code>0x5B0</code> (1456).</li>
<li>  <strong>Recalculate Pitch</strong>:</li>
</ul>
<p>        <code>freq = (3072000.0 / (2048.0 - 1456)) / 32.0 = 161.29 Hz</code> (a significant drop from <code>285.7Hz</code>, used here for a dramatic vibrato demonstration).</p>
<p>        <code>note = round(69 + 12 * log2(161.29 / 440.0)) = 55</code> (G#3).</p>
<ul>
<li>  The pitch changes drastically from <code>62</code> to <code>55</code>.</li>
</ul>
<ol>
<li> <strong>Generate MIDI Event (Pitch Bend)</strong>:</li>
</ol>
<ul>
<li>  The <code>WonderSwanChip</code> state machine detects a pitch change during a sustained note. It doesn't generate a new <code>Note On</code> but instead a <strong>Pitch Bend</strong> event.</li>
<li>  The MIDI Pitch Bend range is typically +/- 2 semitones. This change (-7 semitones) is far beyond that. In a real conversion, we would set a larger bend range or intelligently handle such a large glissando. For this demonstration, we assume it generates a maximum downward bend event.</li>
<li>  At <code>tick = 1092</code>, the event is generated:</li>
<li>  <code>Pitch Bend</code>: Channel 1, Value <code>0</code> (lowest).</li>
</ul>
<ol>
<li> <strong>Restore Frequency</strong>:</li>
</ol>
<ul>
<li>  <code>61 1E 00</code>: Wait 30 samples, advancing time by <code>round(30 * 0.02177) = 1</code> tick. Current time: <code>tick = 1093</code>.</li>
<li>  <code>51 83 06</code>: Restores the period to <code>0x6B0</code>. The pitch returns to <code>62</code>.</li>
<li>  At <code>tick = 1093</code>, the event is generated:</li>
<li>  <code>Pitch Bend</code>: Channel 1, Value <code>8192</code> (center, no bend).</li>
</ul>
<hr>
<h4 id="step-4-note-end-tick-1094"><strong>Step 4: Note End (Tick 1094)</strong></h4>
<ol>
<li> <strong>Advance Time</strong>:</li>
</ol>
<ul>
<li>  <code>61 1E 00</code>: Wait another 30 samples, advancing time by <code>1</code> more tick. Current time: <code>tick = 1094</code>.</li>
</ul>
<ol>
<li> <strong>Disable Channel</strong>:</li>
</ol>
<ul>
<li>  <code>51 90 00</code>: Disables Channel 2. The <code>WonderSwanChip</code> state machine detects a "note off" signal.</li>
</ul>
<ol>
<li> <strong>Generate MIDI Event</strong>:</li>
</ol>
<ul>
<li>  At <code>tick = 1094</code>, the event is generated:</li>
<li>  <code>Note Off</code>: Channel 1, Note 62 (D4), Velocity 0.</li>
</ul>
<hr>
<p><strong>Final Generated MIDI Event Sequence (Summary):</strong></p>
<table>
<thead>
<tr>
<th>Tick</th>
<th>MIDI Event</th>
<th>Channel</th>
<th>Data 1 (Note/CC#)</th>
<th>Data 2 (Vel/Value)</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000</td>
<td><code>Control Change</code></td>
<td>1</td>
<td>10 (Pan)</td>
<td>64</td>
<td>Pan centered</td>
</tr>
<tr>
<td>1000</td>
<td><code>Control Change</code></td>
<td>1</td>
<td>11 (Expression)</td>
<td>127</td>
<td>Set initial volume</td>
</tr>
<tr>
<td>1000</td>
<td><code>Note On</code></td>
<td>1</td>
<td>62 (D4)</td>
<td>127</td>
<td>Trigger note</td>
</tr>
<tr>
<td>1046</td>
<td><code>Control Change</code></td>
<td>1</td>
<td>10 (Pan)</td>
<td>76</td>
<td>Pan to the right</td>
</tr>
<tr>
<td>1092</td>
<td><code>Pitch Bend</code></td>
<td>1</td>
<td>-</td>
<td>0 (LSB, MSB)</td>
<td>Vibrato start (bend down)</td>
</tr>
<tr>
<td>1093</td>
<td><code>Pitch Bend</code></td>
<td>1</td>
<td>-</td>
<td>8192 (LSB, MSB)</td>
<td>Vibrato end (restore pitch)</td>
</tr>
<tr>
<td>1094</td>
<td><code>Note Off</code></td>
<td>1</td>
<td>62 (D4)</td>
<td>0</td>
<td>End note</td>
</tr>
</tbody>
</table>
<p>This deep trace demonstrates that the converter is not just a simple command replacer but a complex system that truly understands musical context, simulates hardware behavior, and intelligently generates expressive MIDI events.</p>
<h3 id="2-9-ultimate-stability-fixing-crashes-caused-by-unknown-vgm-commands">2.9. Ultimate Stability: Fixing Crashes Caused by Unknown VGM Commands</h3>
<p>After the project's basic functions were complete and had passed numerous tests, we encountered a program crash caused by the specific file <code>07_Matoya's_Cave.vgm</code>. The debugging and fixing of this issue greatly improved the program's stability and compatibility with various VGM files.</p>
<ul>
<li>  <strong>Challenge</strong>:</li>
</ul>
<p>    The program would crash silently without any clear error message when processing the <code>07_Matoya's_Cave.vgm</code> file.</p>
<ul>
<li>  <strong>Breakthrough Process</strong>:</li>
</ul>
<ol>
<li> <strong>Logging First</strong>: Faced with this "silent crash," we once again turned to our trusted method: adding detailed logging in the <code>process_vgm_data</code> function of <code>main.cpp</code>. We made the program print the current file pointer position and the command byte being processed before handling each VGM command.</li>
<li> <strong>Pinpointing the Root Cause</strong>: By analyzing the output <code>log.txt</code> file, we found that the log stopped abruptly after processing a specific location. Checking the VGM command at that location, we discovered it was a command not explicitly handled in our <code>switch</code> statement. The problem was in the <code>default</code> branch's logic: it merely incremented the file pointer <code>i</code> by <code>1</code>.</li>
<li> <strong>Analyzing the Error</strong>: In the VGM format, many commands have parameters. For example, command <code>0x4f dd</code> needs to skip 1 byte for its parameter, while <code>0x52 aa dd</code> needs to skip 2 bytes. Our previous <code>default</code> logic, upon encountering these unknown commands, only skipped the command itself, not the parameter bytes that followed. This caused the program to misread what should have been a parameter as the next command, triggering a chain reaction that ultimately corrupted the parsing logic and led to a crash.</li>
</ol>
<ul>
<li>  <strong>The Final Fix: Enhancing Command Handling</strong></li>
</ul>
<p>    Instead of simply ignoring these commands, we consulted the VGM format specification and expanded the <code>process_vgm_data</code> function in <code>main.cpp</code>, adding "skip" logic to its <code>switch</code> statement for a series of previously unhandled commands. This ensures that even if we don't currently need to use the functionality of these commands, the parser correctly moves past them and their parameters, keeping the file pointer synchronized.</p>
<p>    <strong>Newly Handled VGM Commands:</strong></p>
<table>
<thead>
<tr>
<th>VGM Command (Hex)</th>
<th>Length (Bytes)</th>
<th>Handling Method</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x4f</code></td>
<td>2</td>
<td>Skip (command + 1 data byte)</td>
</tr>
<tr>
<td><code>0x51</code> - <code>0x5f</code></td>
<td>3</td>
<td>Skip (command + 2 data bytes)</td>
</tr>
<tr>
<td><code>0xa0</code></td>
<td>3</td>
<td>Skip (command + 2 data bytes)</td>
</tr>
<tr>
<td><code>0xb0</code> - <code>0xbf</code></td>
<td>3</td>
<td>Skip (command + 2 data bytes)</td>
</tr>
<tr>
<td><code>0xc0</code> - <code>0xdf</code></td>
<td>4</td>
<td>Skip (command + 3 data bytes)</td>
</tr>
<tr>
<td><code>0xe0</code> - <code>0xff</code></td>
<td>5</td>
<td>Skip (command + 4 data bytes)</td>
</tr>
</tbody>
</table>
<p>    By adding the correct <code>case</code> branches for these commands and incrementing the file pointer by the appropriate offset, we completely resolved the crash. This fix made the converter much more robust, enabling it to be compatible with more VGM files that, while syntactically correct, did not perfectly match our initial expectations.</p>
<h3 id="2-10-the-intelligent-instrument-system-instruments-ini">2.10. The Intelligent Instrument System: <code>instruments.ini</code></h3>
<p>To solve the problem of mapping WonderSwan's custom waveforms to MIDI instruments and to give the user final control, we have introduced a brand-new intelligent instrument configuration system. The core of this system is the <code>instruments.ini</code> file.</p>
<p><strong>Core Features:</strong></p>
<ul>
<li>  <strong>Automatic Discovery and Registration</strong>: When the converter encounters a waveform it has never seen before in a VGM file, it will:</li>
</ul>
<ol>
<li> Generate a unique <strong>32-byte fingerprint</strong> for the waveform.</li>
<li> Automatically assign the most suitable default MIDI instrument based on the waveform's characteristics.</li>
<li> Generate a unique name for it, such as <code>CustomWave_1</code>.</li>
<li> Record the <strong>source</strong> where the waveform was discovered (i.e., the name of the current VGM file).</li>
<li> Record the registration <strong>timestamp</strong> (<code>registered_at</code>).</li>
<li> Write all of the above information, along with an ASCII art <strong>waveform graph</strong>, as a new entry into the <code>instruments.ini</code> file.</li>
</ol>
<ul>
<li>  <strong>User-Configurable</strong>: <code>instruments.ini</code> is a plain text file that you can open with any text editor. If you are not satisfied with the automatically assigned MIDI instrument for a waveform, simply find the corresponding entry (e.g., <code>[CustomWave_1]</code>) and <strong>manually change the number after <code>midi_instrument =</code></strong>. The next time you run the conversion, the program will read your changes and use the instrument you specified.</li>
</ul>
<ul>
<li>  <strong>Built-in Waveform Support</strong>: On its first run, <code>instruments.ini</code> is automatically created and pre-populated with the WonderSwan's 5 built-in waveforms, ensuring the accuracy of basic tones.</li>
</ul>
<p><strong><code>instruments.ini</code> File Structure Example:</strong></p>
<pre><code class="language-ini">[CustomWave_1]
fingerprint = 00010102...
midi_instrument = 80
source = 17_Battle.vgm
registered_at = 2025-09-23 19:33:12
graph =
;                                █
;                              ███
...
</code></pre>
<p><strong>Built-in Waveform Graph Reference:</strong></p>
<p>Below are the core built-in waveforms of the WonderSwan and their corresponding ASCII graphs in <code>instruments.ini</code>. This helps you to visually understand the appearance of different waveforms.</p>
<ul>
<li>  <strong>Pulse Wave (PULSE)</strong></li>
</ul>
<p>    <code></code>`</p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████                </p>
<p>    ; ████████████████████████████████</p>
<p>    <code></code>`</p>
<ul>
<li>  <strong>Triangle Wave (WAVE_BUILTIN_1)</strong></li>
</ul>
<p>    <code></code>`</p>
<p>    ;                ██               </p>
<p>    ;               ████              </p>
<p>    ;              ██████             </p>
<p>    ;             ████████            </p>
<p>    ;            ██████████           </p>
<p>    ;           ████████████          </p>
<p>    ;          ██████████████         </p>
<p>    ;         ████████████████        </p>
<p>    ;        ██████████████████       </p>
<p>    ;       ████████████████████      </p>
<p>    ;      ██████████████████████     </p>
<p>    ;     ████████████████████████    </p>
<p>    ;    ██████████████████████████   </p>
<p>    ;   ████████████████████████████  </p>
<p>    ;  ██████████████████████████████ </p>
<p>    ; ████████████████████████████████</p>
<p>    <code></code>`</p>
<ul>
<li>  <strong>Sawtooth Wave (WAVE_BUILTIN_3)</strong></li>
</ul>
<p>    <code></code>`</p>
<p>    ; █                              █</p>
<p>    ; ██                            ██</p>
<p>    ; ███                          ███</p>
<p>    ; ████                        ████</p>
<p>    ; █████                      █████</p>
<p>    ; ██████                    ██████</p>
<p>    ; ███████                  ███████</p>
<p>    ; ████████                ████████</p>
<p>    ; █████████              █████████</p>
<p>    ; ██████████            ██████████</p>
<p>    ; ███████████          ███████████</p>
<p>    ; ████████████        ████████████</p>
<p>    ; █████████████      █████████████</p>
<p>    ; ██████████████    ██████████████</p>
<p>    ; ███████████████  ███████████████</p>
<p>    ; ████████████████████████████████</p>
<p>    <code></code>`</p>
<ul>
<li>  <strong>Noise (NOISE)</strong></li>
</ul>
<p>    <code></code>`</p>
<p>    ;   █               █             </p>
<p>    ;   █            █  █            █</p>
<p>    ;   █       █    █  █       █    █</p>
<p>    ;   █ █     █    █  █ █     █    █</p>
<p>    ;   █ █   █ █    █  █ █   █ █    █</p>
<p>    ;   █ █   █ █  █ █  █ █   █ █  █ █</p>
<p>    ;   █ ██  █ █  █ █  █ ██  █ █  █ █</p>
<p>    ; █ █ ██  █ █  █ ██ █ ██  █ █  █ █</p>
<p>    ; █ █ ██ ██ █  █ ██ █ ██ ██ █  █ █</p>
<p>    ; █ █ ██ ██ █ ██ ██ █ ██ ██ █ ██ █</p>
<p>    ; █ ████ ██ █ ██ ██ ████ ██ █ ██ █</p>
<p>    ; █ ████ ████ ██ ██ ████ ████ ██ █</p>
<p>    ; █ ████ ████ █████ ████ ████ ████</p>
<p>    ; ██████ ████ ██████████ ████ ████</p>
<p>    ; ██████ ███████████████ █████████</p>
<p>    ; ████████████████████████████████</p>
<p>    <code></code>`</p>
<p>This system perfectly combines the automation of waveform recognition with the flexibility of manual user configuration, representing a huge leap forward in the project's usability and user experience.</p>
<h3 id="2-11-capturing-expression-the-pitch-bend-implementation-for-vibrato">2.11. Capturing Expression: The Pitch Bend Implementation for Vibrato</h3>
<p>While the converter was highly accurate, it had a limitation in expressing one of the most common musical techniques: vibrato. Fast and wide frequency oscillations were being misinterpreted as a series of very short, distinct notes, which sounded stuttered and unnatural. This section details how we implemented MIDI Pitch Bend to solve this, allowing for smooth and expressive vibrato.</p>
<ul>
<li>  <strong>Challenge</strong>:</li>
</ul>
<p>    The existing logic treated any change in the frequency <code>period</code> that resulted in a different MIDI note number as a trigger for a new note. This meant a <code>Note Off</code> was sent for the old note, and a <code>Note On</code> for the new one. For a rapid oscillation like vibrato, this created an undesirable "machine-gun" effect instead of a continuous, wavering pitch.</p>
<ul>
<li>  <strong>Breakthrough Process: From Re-triggering to Bending</strong>:</li>
</ul>
<p>    The core idea was to change the state machine's philosophy: instead of asking "Is this a new note?", we started asking "Is this the <em>same</em> note, just with a slight pitch deviation?".</p>
<ol>
<li> <strong>Establishing a Baseline</strong>: We introduced a new state variable, <code>channel_base_note_freq</code>, to store the initial frequency of a note at the exact moment it is triggered (<code>Note On</code>). This frequency corresponds to the note's "true" pitch.</li>
</ol>
<ol>
<li> <strong>Calculating Deviation in Cents</strong>: Whenever the frequency <code>period</code> for an active channel changed, we calculated the new frequency. Instead of immediately converting it to a new MIDI note number, we compared it to the <code>channel_base_note_freq</code>. The difference was calculated in <strong>cents</strong> (1/100th of a semitone), a logarithmic unit perfect for measuring musical pitch intervals.</li>
</ol>
<p>        <code>cents_deviation = 1200.0 * log2(current_freq / base_freq);</code></p>
<ol>
<li> <strong>The Vibrato/New Note Threshold</strong>: We established a clear rule:</li>
</ol>
<ul>
<li>  <strong>If the deviation is within a defined range</strong> (e.g., +/- 200 cents, or 2 semitones), the change is classified as vibrato or a small portamento.</li>
<li>  <strong>If the deviation exceeds this range</strong>, it is classified as a genuine jump to a new note.</li>
</ul>
<ol>
<li> <strong>Generating Pitch Bend Events</strong>:</li>
</ol>
<ul>
<li>  For deviations within the range, we convert the <code>cents_deviation</code> into a 14-bit MIDI Pitch Bend value (0-16383, with 8192 as the center/no bend).</li>
<li>  This value is then sent as a Pitch Bend message. If the frequency continues to change, a stream of these messages is sent, creating a smooth pitch curve in the final MIDI.</li>
<li>  To ensure this works, we also send MIDI RPN (Registered Parameter Number) messages at the start of each track to set the synthesizer's pitch bend sensitivity to our desired range (+/- 2 semitones).</li>
</ul>
<ol>
<li> <strong>Handling Jumps</strong>: When the deviation exceeds the threshold, the logic falls back to the old behavior: it sends a <code>Note Off</code> for the current note and immediately triggers a <code>Note On</code> for the new note, correctly capturing the musical intention of a leap rather than a bend.</li>
</ol>
<ul>
<li>  <strong>Technical Implementation</strong>:</li>
<li>  A new <code>add_pitch_bend</code> method was added to the <code>MidiTrack</code> class.</li>
<li>  The <code>check_state_and_update_midi</code> function in <code>WonderSwanChip</code> was significantly refactored to incorporate the new baseline frequency tracking, deviation calculation, and the thresholding logic described above.</li>
<li>  The <code>Note On</code> logic was updated to always reset the pitch bend to the center (<code>8192</code>) and store the note's base frequency, ensuring each new note starts with a clean slate.</li>
</ul>
<p>This implementation successfully transformed the previously robotic-sounding note transitions into fluid, expressive vibrato, adding a critical layer of musicality to the converter's output.</p>
<h2 id="3-a-deep-dive-into-the-wonderswan-sound-system">3. A Deep Dive into the WonderSwan Sound System</h2>
<p>To fully appreciate the conversion process, it's essential to understand the sound generation capabilities of the WonderSwan hardware itself. This section provides a detailed technical breakdown of each sound generation method, the I/O registers that control them, and how they are represented by VGM commands.</p>
<h3 id="3-1-overview-of-sound-channels">3.1. Overview of Sound Channels</h3>
<p>The WonderSwan sound system is surprisingly versatile, featuring four main channels that can be configured for different roles, plus a dedicated PCM audio mechanism.</p>
<table>
<thead>
<tr>
<th>Channel</th>
<th>Primary Function</th>
<th>Special Capabilities</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Channel 1</strong></td>
<td>Programmable Tone</td>
<td>Can be used for PCM playback via Sound DMA</td>
</tr>
<tr>
<td><strong>Channel 2</strong></td>
<td>Programmable Tone</td>
<td>Hardware Sweep (Pitch slides)</td>
</tr>
<tr>
<td><strong>Channel 3</strong></td>
<td>Programmable Tone</td>
<td>Noise Generation</td>
</tr>
<tr>
<td><strong>Channel 4</strong></td>
<td>Programmable Tone</td>
<td>(None)</td>
</tr>
</tbody>
</table>
<p>All interactions with these sound features in a VGM file are primarily handled by the <strong><code>0x51 aa dd</code></strong> command, which means "Write data <code>dd</code> to I/O port <code>aa</code>".</p>
<h3 id="3-2-the-four-main-audio-channels-programmable-tone">3.2. The Four Main Audio Channels (Programmable Tone)</h3>
<p>These four channels are the backbone of WonderSwan music, responsible for generating melodies, harmonies, and basslines. They share a common architecture for pitch, volume, and waveform selection.</p>
<h4 id="3-2-1-pitch-control">3.2.1. Pitch Control</h4>
<ul>
<li>  <strong>Functionality</strong>: Sets the frequency of the note to be played.</li>
<li>  <strong>Registers</strong>: Each channel uses a pair of 8-bit registers to define an 11-bit frequency period value (from 0 to 2047). A higher period value results in a lower pitch.</li>
<li>  Channel 1: <code>0x80</code> (Low Byte), <code>0x81</code> (High Byte)</li>
<li>  Channel 2: <code>0x82</code> (Low Byte), <code>0x83</code> (High Byte)</li>
<li>  Channel 3: <code>0x84</code> (Low Byte), <code>0x85</code> (High Byte)</li>
<li>  Channel 4: <code>0x86</code> (Low Byte), <code>0x87</code> (High Byte)</li>
<li>  <strong>VGM Example</strong>: To set Channel 2's period to <code>0x06B0</code>:</li>
<li>  <code>51 82 B0</code> (Write <code>0xB0</code> to the low byte register)</li>
<li>  <code>51 83 06</code> (Write <code>0x06</code> to the high byte register)</li>
<li>  <strong>Conversion Logic</strong>: The converter reads these period values and uses the formula <code>freq = (3072000 / (2048 - period)) / 32</code> to calculate the audible frequency, which is then converted to a MIDI note number.</li>
</ul>
<h4 id="3-2-2-volume-and-panning-control">3.2.2. Volume and Panning Control</h4>
<ul>
<li>  <strong>Functionality</strong>: Sets the volume for the left and right speakers independently for each channel. This allows for both overall volume control and stereo panning effects.</li>
<li>  <strong>Registers</strong>: Each channel has a single 8-bit register where the high 4 bits control the left volume (0-15) and the low 4 bits control the right volume (0-15).</li>
<li>  Channel 1: <code>0x88</code></li>
<li>  Channel 2: <code>0x89</code></li>
<li>  Channel 3: <code>0x8A</code></li>
<li>  Channel 4: <code>0x8B</code></li>
<li>  <strong>VGM Example</strong>: To set Channel 2's left volume to 10 (<code>0xA</code>) and right volume to 15 (<code>0xF</code>):</li>
<li>  <code>51 89 AF</code> (Write <code>0xAF</code> to the volume register)</li>
<li>  <strong>Conversion Logic</strong>:</li>
<li>  The converter reads the left and right volumes. The higher of the two is used to calculate the overall note expression (MIDI CC#11).</li>
<li>  The ratio between the left and right volumes is used to calculate the stereo pan position (MIDI CC#10).</li>
</ul>
<h4 id="3-2-3-waveform-selection-and-memory">3.2.3. Waveform Selection and Memory</h4>
<ul>
<li>  <strong>Functionality</strong>: This is the most unique feature. Instead of having fixed waveforms (like square, sine), the WonderSwan's four channels read their waveform data directly from a shared block of internal RAM. This allows for custom, dynamic timbres.</li>
<li>  <strong>Memory Layout</strong>: The sound chip uses a <strong>2 KB block of internal RAM (from address <code>0x0000</code> to <code>0x07FF</code>)</strong> as its waveform memory. This RAM is organized into 128 slots, each holding a 16-byte waveform.</li>
<li>  <strong>Registers</strong>:</li>
<li>  <strong>Waveform Base Address (<code>0x8F</code>)</strong>: This crucial register's value (multiplied by 64) points to the starting address in RAM where the four channels will find their waveform data. For example, if <code>0x8F</code> is set to <code>2</code>, the waveform data starts at <code>2 * 64 = 128</code> (<code>0x0080</code> in RAM).</li>
<li>  <strong>Channel Waveform Pointers</strong>: Each channel reads its 16-byte waveform from a specific offset relative to this base address:</li>
<li>  Channel 1: <code>Base Address + 0</code></li>
<li>  Channel 2: <code>Base Address + 16</code></li>
<li>  Channel 3: <code>Base Address + 32</code></li>
<li>  Channel 4: <code>Base Address + 48</code></li>
<li>  <strong>VGM Commands</strong>: To create a custom sound, a game's music engine first writes the waveform data into RAM. This is done using the <strong>Sound DMA (Direct Memory Access)</strong> mechanism, which is not directly represented by simple VGM port writes. In a VGM file, this pre-loading of waveform data is typically done using <strong><code>0x67</code> (Data Block)</strong> commands followed by a series of RAM write commands. However, for the purpose of our converter, we focus on what happens <em>after</em> the RAM is loaded.</li>
<li>  <strong>Conversion Logic (<code>instruments.ini</code> system)</strong>:</li>
</ul>
<ol>
<li> When a note on a channel is triggered, the converter reads the value of register <code>0x8F</code> to find the waveform base address.</li>
<li> It calculates the specific 16-byte memory region for that channel.</li>
<li> It reads the 16 bytes from its simulated <code>internal_ram</code>. Each byte contains two 4-bit samples, so it unpacks this into a 32-sample waveform.</li>
<li> This 32-sample data becomes the waveform's unique "fingerprint".</li>
<li> The converter looks up this fingerprint in <code>instruments.ini</code>. If found, it uses the user-specified MIDI instrument. If not, it registers it as a new custom wave and assigns a default instrument.</li>
</ol>
<h4 id="3-2-4-channel-activation">3.2.4. Channel Activation</h4>
<ul>
<li>  <strong>Functionality</strong>: A master switch to turn each of the four channels on or off.</li>
<li>  <strong>Register</strong>: <code>0x90</code> (Channel Enable Register)</li>
<li>  <strong>Bits</strong>:</li>
<li>  Bit 0: Enable Channel 1</li>
<li>  Bit 1: Enable Channel 2</li>
<li>  Bit 2: Enable Channel 3</li>
<li>  Bit 3: Enable Channel 4</li>
<li>  <strong>VGM Example</strong>: To enable Channel 2 and disable all others:</li>
<li>  <code>51 90 02</code> (Write <code>0b00000010</code> to port <code>0x90</code>)</li>
<li>  <strong>Conversion Logic</strong>: This register is the primary trigger for <code>Note On</code> and <code>Note Off</code> events. When a channel's bit is set to 1 and its volume is greater than 0, a <code>Note On</code> is generated. When the bit is cleared to 0, a <code>Note Off</code> is generated.</li>
</ul>
<h3 id="3-3-special-channel-features">3.3. Special Channel Features</h3>
<p>Some channels have unique hardware capabilities beyond basic tone generation.</p>
<h4 id="3-3-1-hardware-sweep-channel-2">3.3.1. Hardware Sweep (Channel 2)</h4>
<ul>
<li>  <strong>Functionality</strong>: Channel 2 features a hardware "sweep" function, which can automatically and periodically adjust the channel's frequency period. This is commonly used to create pitch slide effects, arpeggios, or other simple modulations without needing the CPU to manually write new frequency values.</li>
<li>  <strong>Registers</strong>:</li>
<li>  <strong>Sweep Step (<code>0x8C</code>)</strong>: An 8-bit signed value that determines the amount to add to the channel's period value at each sweep interval. A positive value lowers the pitch, and a negative value raises it.</li>
<li>  <strong>Sweep Time (<code>0x8D</code>)</strong>: An 8-bit value that sets the time interval between each sweep step. The actual time is calculated based on the system's H-blank rate.</li>
<li>  <strong>Sweep Enable (in <code>0x90</code>)</strong>: Bit 6 of the Channel Enable Register (<code>0x90</code>) acts as the master switch for the sweep function on Channel 2.</li>
<li>  <strong>VGM Example</strong>: To create a slow upward pitch slide on Channel 2:</li>
<li>  <code>51 8C E0</code> (Set sweep step to -32, a negative value to raise the pitch)</li>
<li>  <code>51 8D 10</code> (Set a relatively long interval between steps)</li>
<li>  <code>51 90 42</code> (Enable Channel 2 via Bit 1, and enable sweep via Bit 6)</li>
<li>  <strong>Conversion Logic</strong>: The converter fully simulates this behavior. The <code>process_sweep</code> function is called with each time advance. It maintains a <code>sweep_count</code> timer. When the timer expires, it adds the <code>sweep_step</code> value to <code>channel_periods[2]</code> and resets the timer. This change in period is then detected by <code>check_state_and_update_midi</code>, which in turn generates the appropriate MIDI Pitch Bend events, accurately reproducing the slide effect.</li>
</ul>
<h4 id="3-3-2-noise-generation-channel-3">3.3.2. Noise Generation (Channel 3)</h4>
<ul>
<li>  <strong>Functionality</strong>: Channel 3 can be switched from a normal tone generator to a noise generator, which is essential for creating percussive sounds like drums, cymbals, or sound effects like explosions.</li>
<li>  <strong>Registers</strong>:</li>
<li>  <strong>Noise Control (<code>0x8E</code>)</strong>: This register controls the type of noise. The low 3 bits (<code>0-2</code>) select one of seven different noise patterns, which likely correspond to different Linear Feedback Shift Register (LFSR) configurations, producing different noise timbres (e.g., more metallic vs. more "white"). Bit 3 is a reset flag.</li>
<li>  <strong>Noise Enable (in <code>0x90</code>)</strong>: Bit 7 of the Channel Enable Register (<code>0x90</code>) is the master switch that dedicates Channel 3 to noise generation. When this bit is set, Channel 3 ignores its waveform and frequency settings and outputs noise instead.</li>
<li>  <strong>VGM Example</strong>: To play a standard noise sound on Channel 3:</li>
<li>  <code>51 8E 07</code> (Select noise pattern 7)</li>
<li>  <code>51 90 88</code> (Enable Channel 3 via Bit 3, and enable noise mode via Bit 7)</li>
<li>  <strong>Conversion Logic</strong>: When the converter detects that Bit 7 of port <code>0x90</code> is active, it flags <code>channel_is_noise[3]</code> as true. In <code>check_state_and_update_midi</code>, if this flag is set, it overrides the normal instrument selection and assigns a percussive MIDI instrument (e.g., <code>127: Gunshot</code> or a user-defined drum sound from <code>instruments.ini</code>). The pitch of the noise is typically fixed or ignored in the MIDI conversion, as the timbre is the most important characteristic.</li>
</ul>
<h4 id="3-3-3-pcm-audio-via-sound-dma-channel-1">3.3.3. PCM Audio via Sound DMA (Channel 1)</h4>
<ul>
<li>  <strong>Functionality</strong>: This is the most advanced sound feature. The WonderSwan can play back raw, 4-bit PCM audio samples directly from RAM. This is used for complex sound effects, voice clips, or high-quality drum sounds that cannot be synthesized by the other channels. This functionality is tied to Channel 1 and uses the Sound DMA (Direct Memory Access) controller.</li>
<li>  <strong>Mechanism</strong>: Instead of the CPU manually feeding sample data, it configures the DMA controller with a start address and length, and the hardware automatically streams the data from RAM to the audio output at a specified rate, hijacking Channel 1's volume controls.</li>
<li>  <strong>Registers</strong>:</li>
<li>  <strong>DMA Source Address (<code>0x4A</code>, <code>0x4B</code>, <code>0x4C</code>)</strong>: Three registers combine to form a 24-bit address pointing to the start of the PCM sample data in RAM.</li>
<li>  <strong>DMA Count (<code>0x4E</code>, <code>0x4F</code>)</strong>: Two registers form a 16-bit value indicating the number of samples to play.</li>
<li>  <strong>DMA Control (<code>0x52</code>)</strong>: This register controls the DMA process. Bit 7 starts or stops the DMA, and bits 0-1 control the playback rate.</li>
<li>  <strong>PCM Enable (in <code>0x90</code>)</strong>: Bit 5 of the Channel Enable Register (<code>0x90</code>) enables PCM output.</li>
<li>  <strong>PCM Direct Volume (<code>0x94</code>)</strong>: A separate volume control register used specifically for PCM playback, bypassing Channel 1's normal volume register (<code>0x88</code>).</li>
<li>  <strong>VGM Commands</strong>: A typical PCM playback sequence in a VGM file involves:</li>
</ul>
<ol>
<li> Writing the sample data to RAM (often via <code>0x67</code> data blocks).</li>
<li> <code>51 4A..4C ..</code> (Set DMA source address).</li>
<li> <code>51 4E..4F ..</code> (Set DMA sample count).</li>
<li> <code>51 52 ..</code> (Set DMA rate and start the transfer).</li>
<li> <code>51 90 20</code> (Enable PCM output mode).</li>
</ol>
<ul>
<li>  <strong>Conversion Logic</strong>: The converter simulates the Sound DMA process. The <code>process_s_dma</code> function is called with each time advance. It maintains a <code>s_dma_timer</code>. When the timer expires, it simulates the hardware fetching one byte of data from the <code>s_dma_source_addr</code> in its simulated RAM. This byte is then written to port <code>0x89</code> (Channel 2's volume register, a hardware quirk), and the DMA counters are updated. The <code>check_state_and_update_midi</code> function detects that PCM mode is active (via port <code>0x90</code>, bit 5) and routes the volume from the special PCM volume register (<code>0x94</code>) to Channel 1's MIDI output, typically mapping it to a drum or sample-based instrument.</li>
</ul>
<h2 id="4-program-workflow-explained">4. Program Workflow Explained</h2>
<p>The core of <code>vgm_ws_to_mid</code> is a state machine that simulates the behavior of the WonderSwan sound chip and translates its state changes into MIDI events in real-time.</p>
<h3 id="4-1-overview">4.1. Overview</h3>
<ol>
<li> <strong>Read</strong>: <code>VgmReader</code> is responsible for loading the entire VGM file into memory and providing access to header information (like loop offset, data start position).</li>
<li> <strong>Process</strong>: The <code>process_vgm_data</code> function in <code>main</code> is the core driver of the program. It iterates through the VGM data block with a large <code>for</code> loop and uses a <code>switch</code> statement to dispatch and handle each VGM command:</li>
</ol>
<ul>
<li>  <strong><code>0x51 aa dd</code> (WonderSwan Port Write)</strong>: Passes the address <code>aa</code> and data <code>dd</code> to <code>WonderSwanChip</code> for simulation. This is the most critical command.</li>
<li>  <strong><code>0x61 nn nn</code> (Wait)</strong>: Calls <code>WonderSwanChip::advance_time</code>, converting the wait samples into MIDI ticks to advance the timeline.</li>
<li>  <strong><code>0x62</code> (Wait 735 samples)</strong>: Same as above, but for a fixed value.</li>
<li>  <strong><code>0x63</code> (Wait 882 samples)</strong>: Same as above, but for a fixed value.</li>
<li>  <strong><code>0x7n</code> (Wait n+1 samples)</strong>: Same as above, for short waits.</li>
<li>  <strong><code>0x66</code> (End of Data Block)</strong>: Marks the normal end of the VGM data stream, terminating the loop.</li>
<li>  <strong>Other Recognized Commands (e.g., <code>0x4f</code>, <code>0x52-0x5f</code>, <code>0xa0</code>, etc.)</strong>: These are commands for other chips or extended VGM features. The current converter doesn't use them, but to ensure parsing continuity, the program correctly skips over these commands and their parameters according to the format specification. This is key to the program's stability.</li>
</ul>
<ol>
<li> <strong>Simulate & Translate</strong>: <code>WonderSwanChip</code> receives the port write data and updates its internal register states (e.g., frequency, volume). After each update, it calls <code>check_state_and_update_midi()</code> to check if the channel's state has changed (e.g., note on/off, pitch change, volume change).</li>
<li> <strong>Generate</strong>: If a meaningful state change is detected, <code>WonderSwanChip</code> calls <code>MidiWriter</code> to generate the corresponding MIDI event (Note On/Off, Control Change) with the current, precise MIDI tick time.</li>
<li> <strong>Loop</strong>: After processing the entire VGM file, if a loop point was detected, the <code>main</code> function instructs <code>MidiWriter</code> to copy the recorded MIDI events from the looped section and append them to the end of each track, creating a seamless loop.</li>
<li> <strong>Write</strong>: After all VGM commands are processed, <code>MidiWriter</code> assembles all generated events (including the copied loop section) into a standard MIDI file and saves it to disk.</li>
</ol>
<h3 id="4-2-key-components">4.2. Key Components</h3>
<ul>
<li>  <strong><code>main.cpp</code></strong>: The program entry point and main controller. It's responsible for parsing command-line arguments, instantiating <code>VgmReader</code>, <code>MidiWriter</code>, and <code>WonderSwanChip</code>. Its core is the <code>process_vgm_data</code> function, which contains a large <code>switch</code> statement that acts as a "dispatch center" for VGM commands, driving the entire conversion process and implementing the looping logic.</li>
<li>  <strong><code>VgmReader.h/.cpp</code></strong>: The VGM file loader. It's responsible for reading the entire VGM file into memory and parsing the header to extract key metadata, such as the data start offset (<code>0x34</code>) and the loop offset (<code>0x1C</code>).</li>
<li>  <strong><code>WonderSwanChip.h/.cpp</code></strong>: The <strong>conversion core</strong>.</li>
<li>  It maintains an <code>io_ram</code> array to simulate the chip's 256 I/O registers.</li>
<li>  The <code>write_port()</code> method is the key entry point, updating internal state variables (like <code>channel_periods</code>, <code>channel_volumes_left</code>, etc.) based on the port address being written to.</li>
<li>  <code>check_state_and_update_midi()</code> is the brain of the state machine. After each state update, it compares the current state to the previous one to determine if a MIDI event needs to be generated, thus intelligently handling legato (pitch bend), re-triggers, and volume envelopes. It now also calls <code>InstrumentConfig</code> to get or create an instrument.</li>
<li>  A new <code>get_channel_count()</code> method was added to dynamically return the total number of tracks managed by the chip, resolving the out-of-bounds access issue caused by hardcoding.</li>
<li>  <strong><code>MidiWriter.h/.cpp</code></strong>: The MIDI file generator. It has undergone a major refactor and now internally uses a <code>std::vector<MidiEvent></code> to store structured MIDI events instead of raw bytes. This makes precise manipulation of events possible. It provides a simple set of APIs (like <code>add_note_on</code>, <code>add_control_change</code>) to build a track and adds a new <code>copy_events_from</code> method, which can efficiently copy events from one point in time to another, key to enabling seamless looping. This method now also has built-in logic to automatically close notes that are not closed at the loop block boundary. When the conversion is finished, the <code>write_to_file()</code> method dynamically serializes the event list into a standard MIDI file.</li>
<li>  <strong><code>InstrumentConfig.h/.cpp</code></strong>: The <strong>Intelligent Instrument Configuration System</strong>. This is the newest core component, responsible for managing the <code>instruments.ini</code> file. It implements waveform auto-discovery, fingerprint generation, similarity comparison, and automatic registration. It is also responsible for loading the user's custom instrument settings and providing the final MIDI instrument number to <code>WonderSwanChip</code>.</li>
<li>  <strong><code>UsageLogger.h/.cpp</code></strong>: The <strong>Usage Logger</strong>. Responsible for generating the <code>conversion_log.txt</code> file. It reports all new instruments registered during the conversion and provides a detailed breakdown of waveform usage frequency per channel, offering the user a comprehensive report of the conversion process.</li>
</ul>
<h3 id="4-3-key-formulas-and-constants">4.3. Key Formulas and Constants</h3>
<ul>
<li>  <strong>Timing Conversion</strong>:</li>
</ul>
<p>    <code>const double SAMPLES_TO_TICKS = (480.0 <em> 120.0) / (44100.0 </em> 60.0);</code></p>
<ul>
<li>  <strong>Pitch Conversion</strong>:</li>
</ul>
<p>    <code>double freq = (3072000.0 / (2048.0 - period)) / 32.0;</code></p>
<p>    <code>int note = static_cast<int>(round(69 + 12 * log2(freq / 440.0)));</code></p>
<ul>
<li>  <strong>Volume Mapping</strong>:</li>
</ul>
<p>    <code>double normalized_vol = vgm_vol / 15.0;</code></p>
<p>    <code>double curved_vol = pow(normalized_vol, 0.3);</code></p>
<p>    <code>int velocity = static_cast<int>(curved_vol * 127.0);</code></p>
<h3 id="4-4-conversion-log-conversion-log-txt">4.4. Conversion Log (<code>conversion_log.txt</code>)</h3>
<p>To provide maximum transparency and insight into the conversion process, the program generates a detailed log file named <code>conversion_log.txt</code> upon every run. This file serves two primary purposes:</p>
<ol>
<li> <strong>Reporting New Discoveries</strong>: It explicitly lists any new custom waveforms that were discovered in the VGM file during the conversion, along with the default MIDI instrument that was assigned to them. This makes it easy to identify which new entries have been added to <code>instruments.ini</code> for potential user customization.</li>
<li> <strong>Providing Usage Statistics</strong>: It offers a detailed breakdown of which waveforms were used by each of the WonderSwan's four primary sound channels, and how frequently. This data can be invaluable for understanding the sound design of a particular song.</li>
</ol>
<p><strong>Example <code>conversion_log.txt</code>:</strong></p>
<pre><code class="language-">--- Conversion Log ---
VGM File: 17_Battle.vgm
Timestamp: 2025-09-23 20:15:00

--- New Instruments Registered ---
A new instrument profile has been created and saved to instruments.ini:
[CustomWave_1]
- Fingerprint: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
- Assigned MIDI Instrument: 80 (Synth Lead)
- Source VGM: 17_Battle.vgm

--- Waveform Usage Statistics ---

Channel 1:
- WAVE_BUILTIN_1 (Triangle): 125 times
- CustomWave_1: 88 times

Channel 2:
- WAVE_BUILTIN_1 (Triangle): 210 times

Channel 3:
- PULSE: 340 times

Channel 4:
- NOISE: 56 times

--- End of Log ---
</code></pre>
<p>This section provides a clear, data-driven summary of the conversion, bridging the gap between the raw VGM input and the final MIDI output.</p>
<h2 id="5-how-to-compile-and-run">5. How to Compile and Run</h2>
<p>This project is compiled using g++ in a bash environment.</p>
<ul>
<li>  <strong>Compile</strong>:</li>
</ul>
<p>    <code></code>`bash</p>
<p>    g++ -std=c++17 -o vgm_ws_to_mid/vgm2mid.exe vgm_ws_to_mid/main.cpp vgm_ws_to_mid/VgmReader.cpp vgm_ws_to_mid/WonderSwanChip.cpp vgm_ws_to_mid/MidiWriter.cpp vgm_ws_to_mid/InstrumentConfig.cpp vgm_ws_to_mid/UsageLogger.cpp vgm_ws_to_mid/WaveformInfo.cpp -lstdc++fs</p>
<p>    <code></code>`</p>
<ul>
<li>  <strong>Run</strong>:</li>
</ul>
<p>    <code></code>`bash</p>
<p>    vgm_ws_to_mid/vgm2mid.exe [input_vgm_file] [output_mid_file]</p>
<p>    <code></code>`</p>
<p>    For example:</p>
<p>    <code></code>`bash</p>
<p>    vgm_ws_to_mid/vgm2mid.exe 02_Prelude.vgm vgm_ws_to_mid/output.mid</p>
<p>    <code></code>`</p>
<hr>
<p>This document provides a comprehensive summary of our work. We hope it serves as a clear guide for future development and maintenance.</p>
</body>
</html>
