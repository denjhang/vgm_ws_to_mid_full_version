# vgm_ws_to_mid: WonderSwan VGM to MIDI 转换器 - 项目文档

本文档详细记录了 `vgm_ws_to_mid` 转换器的开发历程、技术实现细节以及最终程序的工作流程。

## 目录
* [1. 功能大纲与核心实现](#1-功能大纲与核心实现)
  * [1.1. 核心功能亮点](#11-核心功能亮点)
  * [1.2. 生成的MIDI事件列表](#12-生成的midi事件列表)
* [2. 开发历程：从零到完美的转换器](#2-开发历程从零到完美的转换器)
  * [2.1. 初期探索：解构核心逻辑](#21-初期探索解构核心逻辑)
  * [2.2. 第一座大山：修正音高与时序](#22-第一座大山修正音高与时序)
  * [2.3. 无声的 MIDI：解密动态音量](#23-无声的-midi解密动态音量)
  * [2.4. 最终的润色：音量映射的艺术](#24-最终的润色音量映射的艺术)
  * [2.5. 终极难题：解决音量突变与音符挂起](#25-终极难题解决音量突变与音符挂起)
  * [2.6. 自我修正的反馈闭环：定制化验证工具的力量](#26-自我修正的反馈闭环定制化验证工具的力量)
  * [2.7. 新篇章：实现无缝循环与最终的稳定性](#27-新篇章实现无缝循环与最终的稳定性)
  * [2.8. 深度实例追踪：一个音符的完整生命周期](#28-深度实例追踪一个音符的完整生命周期)
  * [2.9. 终极稳定性：修复未知VGM命令导致的崩溃](#29-终极稳定性修复未知vgm命令导致的崩溃)
  * [2.10. 智能乐器系统：`instruments.ini`](#210-智能乐器系统instrumentsini)
* [3. 程序工作流程详解](#3-程序工作流程详解)
  * [3.1. 概览](#31-概览)
  * [3.2. 关键组件](#32-关键组件)
  * [3.3. 关键公式与常量](#33-关键公式与常量)
* [4. 如何编译与运行](#4-如何编译与运行)

## 1. 功能大纲与核心实现

本节总结了 `vgm_ws_to_mid` 转换器实现的核心功能，并列出了其能够生成的所有MIDI事件类型。

### 1.1. 核心功能亮点

*   **精确的音高与时序转换**: 基于对硬件模拟代码的逆向工程，实现了从VGM周期值到MIDI音高、从VGM采样等待到MIDI ticks的精确数学转换。
*   **富有表现力的动态音量**: 使用非线性映射曲线 (`pow(vol, 0.3)`) 将WonderSwan的4-bit音量映射到MIDI CC#11 (Expression)，解决了动态范围压缩问题，使音乐听感饱满。
*   **智能的立体声声相 (Panning)**: 通过解析并对比左右声道的独立音量，智能生成MIDI CC#10 (Pan) 事件，完美再现了原始的立体声效果。
*   **高级音符效果**:
    *   **颤音 (Vibrato)**: 能够捕捉音符持续期间的细微频率变化，并将其转换为一系列的MIDI Pitch Bend事件。
    *   **滑音 (Glissando/Portamento)**: 对于大幅度的频率变化，同样通过Pitch Bend实现平滑的音高过渡。
*   **健壮的状态机**: 彻底重构的状态机逻辑能够精确追踪每个音符的生命周期（开始、停止、重触发），根除了“音符挂起”问题。
*   **无缝循环处理**: 能够解析VGM文件中的循环点，精确复制循环区域内的所有MIDI事件，并自动处理跨越循环边界的音符，实现完美的无缝循环播放。
*   **出色的稳定与兼容性**: 通过为大量未直接使用的VGM命令添加正确的“跳过”逻辑，极大地提升了解析器的鲁棒性，有效避免了因未知命令导致的程序崩溃。

### 1.2. 生成的MIDI事件列表

转换器能够根据VGM数据智能生成以下所有类型的MIDI事件，以构建富有表现力的音乐：

| MIDI 事件类型 | 用途与说明 |
| :--- | :--- |
| **Note On** | 触发一个音符。力度（Velocity）被固定为最大值`127`，实际听感音量由CC#11控制。 |
| **Note Off** | 结束一个音符。 |
| **Control Change** | 用于控制各种声音参数，是实现动态表现力的核心。 |
| └─ **CC#7 (Main Volume)** | 在轨道开始时用于设定一个最大音量基准，以确保不同播放器表现一致。 |
| └─ **CC#10 (Pan)** | 控制声道的左右声道平衡，用于实现立体声效果。 |
| └─ **CC#11 (Expression)** | **最重要的控制器**。用于实时调节音符持续期间的音量包络，实现渐强、渐弱等动态效果。 |
| **Pitch Bend** | 用于实现音符的平滑音高变化，如颤音（Vibrato）和滑音（Glissando）。 |

## 2. 开发历程：从零到完美的转换器

这个项目的目标是创建一个能够将 WonderSwan (WS) VGM 文件精确转换为 MIDI 文件的 C++ 程序。整个过程充满了挑战，通过一系列的分析、调试和迭代，我们最终克服了所有困难。

### 2.1. 初期探索：解构核心逻辑

*   **挑战**: WonderSwan 声音芯片的硬件文档稀缺，直接转换不可行。
*   **解决方案**: 项目初期，我们获得了 `modizer` 项目的源代码。通过分析其文件结构，我们迅速定位到 `modizer-master/libs/libwonderswan/libwonderswan/oswan/audio.cpp` 这个关键文件。通过深入研究该文件，我们成功提取了 WonderSwan 声音芯片模拟的核心信息：
    1.  **时钟频率**: 确认了其主时钟频率为 `3.072 MHz`。
    2.  **寄存器功能**: 明确了 `0x80-0x87` (频率), `0x88-0x8B` (音量), 和 `0x90` (通道开关) 等关键寄存器的作用。
    3.  **波形表机制**: 发现了最关键的一个细节——频率计算必须除以 `32`（波形表大小），这是解决音高问题的钥匙。

### 2.2. 第一座大山：修正音高与时序

*   **挑战**: 初版转换器生成的 MIDI 文件音高异常地高，且播放时长与原始 VGM 完全不符。
*   **攻克过程**:
    1.  **时序问题**: 我们意识到 VGM 的“等待”命令（`0x61 nn nn`）是以 1/44100 秒的采样为单位的，而 MIDI 的时间单位是 `tick`。通过引入一个转换因子 `SAMPLES_TO_TICKS = (480.0 * 120.0) / (44100.0 * 60.0)`，我们成功地将采样数精确地转换为了在 120 BPM 和 480 PPQN 标准下的 MIDI ticks，从而解决了时长不匹配的问题。
    2.  **音高问题**: 这是最棘手的难题。最初的频率转换公式 `freq = 3072000.0 / (2048.0 - period)` 产生的音高偏高了整整五个八度。在反复检查 `modizer` 的 `audio.cpp` 源码后，我们注意到了一个细节：最终的频率值被用作波形表的索引。这启发了我们，实际的听觉频率应该是时钟频率经过分频和波形表处理后的结果。最终，通过在公式末尾加入 `/ 32`，我们得到了正确的频率，音高问题迎刃而解。

### 2.3. 无声的 MIDI：解密动态音量

*   **挑战**: 在实现了音量控制后，生成的 MIDI 文件在许多播放器中变得无声，或者音量变化不符合预期。
*   **攻克过程**:
    1.  **问题定位**: 最初，我们使用 MIDI CC#7 (主音量) 来处理音符持续期间的音量变化。然而，许多 MIDI 合成器将 CC#7 视为一个通道的静态设置，而不是一个可以实时调制的“表情”参数，这导致了兼容性问题。
    2.  **解决方案**: 通过查阅 MIDI 规范和最佳实践，我们确认 CC#11 (表情) 是处理音符动态包络的标准控制器。将代码中的 `add_control_change(channel, 7, ...)` 修改为 `add_control_change(channel, 11, ...)` 后，MIDI 文件在所有播放器上都能正确地表现出动态音量变化，无声问题彻底解决。

### 2.4. 最终的润色：音量映射的艺术

*   **挑战**: 即便动态音量已实现，但由于 WonderSwan 的 4-bit 音量（0-15）与 MIDI 的 7-bit 音量（0-127）之间存在巨大的动态范围差异，直接线性映射导致整体音量偏小，音乐听起来“有气无力”。
*   **攻克过程**:
    1.  **分析问题**: 线性映射 `midi_vol = vgm_vol / 15.0 * 127.0` 使得大量处于中低范围的 VGM 音量被映射到了 MIDI 中非常低的数值，人耳难以感知。
    2.  **非线性映射**: 为了在提升整体可听度的同时保留动态范围，我们引入了幂函数 `pow(normalized_vol, exponent)` 作为非线性映射曲线。通过反复试验，我们发现：
        *   `exponent = 0.6`：一个很好的起点，能有效提升低音量，但用户反馈仍不够响亮。
        *   `exponent = 0.3`：一个更激进的曲线，极大地增强了中低音量的表现力，同时在最大音量处仍能保持 headroom，避免了削波失真。
    3.  **用户反馈迭代**: 根据用户的最终反馈（“提升一个八度，继续增加音量”），我们移除了之前测试性的 `-12` 音高偏移，并采用了 `exponent = 0.3` 的音量曲线，最终达到了用户满意的完美效果。

### 2.5. 终极难题：解决音量突变与音符挂起

在项目接近尾声时，我们遇到了两个最棘手、也最关键的问题：部分音符在播放结束后不会停止（“音符挂起”），以及在测试文件 `02_Prelude.vgm` 中，开头约1秒的音量远大于后续部分，形成了一个非常突兀的音量“断崖”。

*   **挑战**:
    1.  **音符挂起**: 状态机逻辑不够严谨，无法正确处理某些特定的音符关闭事件。
    2.  **音量突变**: MIDI合成器在接收到 `Note On` 事件时，其初始音量取决于多个因素（包括默认设置和之前的CC值），导致不可预测的音量峰值。

*   **攻克过程**:
    1.  **重构状态机**: 我们彻底重构了 `check_state_and_update_midi` 函数。通过引入更清晰的状态变量（如 `channel_is_active`）和更严格的逻辑判断，我们精确地定义了音符生命周期的四种状态：**开始 (Note On)**, **停止 (Note Off)**, **重触发 (Retrigger)**, 和 **持续 (Sustain)**。这确保了每个 `Note On` 事件最终都有一个对应的 `Note Off` 事件，彻底解决了音符挂起问题。

    2.  **解决音量突变：三步走策略**
        *   **第一步：建立基准**。我们在 `WonderSwanChip` 的构造函数中，为每个MIDI轨道初始化了 `CC7` (主音量) 和 `CC11` (表情) 为最大值 `127`。这确保了无论合成器的默认状态如何，我们的转换器总是在一个已知的、统一的最大音量基准上开始工作。
        *   **第二步：控制优先**。在 `check_state_and_update_midi` 函数中，当需要触发一个新音符时，我们改变了事件的发送顺序。程序现在会**先发送 `CC11` (表情) 事件**来设定该音符的精确听感音量。
        *   **第三步：一致的触发**。紧接着（在同一个MIDI tick），程序会发送一个**力度（Velocity）固定为 `127` 的 `Note On` 事件**。

    *   **为什么这个策略有效？** 这个策略将音符的“音量”和“触发”两个概念完全分离。`CC11` 负责精确控制听感响度，而固定的高力度 `Note On` 则保证了每个音符都以一致、饱满的音头（Attack）被触发。这彻底消除了因合成器状态不确定而导致的音量突变，使得音量变化平滑、可控且完全符合预期。

### 2.6. 自我修正的反馈闭环：定制化验证工具的力量

您敏锐地指出了本项目成功的关键：我们不仅编写了转换程序，更重要的是，我们创造了用于验证和调试的工具。这形成了一个强大的“编码-测试-验证”的快速反馈闭环，使我们能够客观、高效地发现并解决问题，而不是依赖主观听感。

**核心调试工具：`midi_validator.exe`**

这是一个从零开始编写的轻量级 MIDI 解析器。它的功能随着项目的进展而不断进化：

*   **初期功能**: 检查 MIDI 文件的基本结构完整性，确保文件头（MThd）和轨道块（MTrk）没有损坏。
*   **核心功能**: 最大的突破是为其增加了详细的**事件日志打印**功能。它能够逐行、按时间顺序清晰地列出每一个 MIDI 事件（音符开、音符关、控制器变更等），并显示其精确的 tick 时间、通道和数据值。

**它如何帮助我们？**

1.  **验证时序**: 通过查看事件的 `Tick` 列，我们可以精确验证 `SAMPLES_TO_TICKS` 公式的正确性。
2.  **验证音高**: `Note On` 事件的 `Data 1` 列直接显示了 MIDI 音高编号，让我们能客观地判断音高转换是否准确，而不是靠“听起来像”。
3.  **调试音量**: 这是它最重要的用途。通过观察 `Note On` 的力度（`Data 2`）和 CC#11 事件的值，我们能够量化音量的大小，从而定位“静音MIDI”的根源（CC#7 vs CC#11），并科学地调整非线性音量曲线的指数，直到输出的数值达到预期范围。

**反馈调试流程**

这个工具使我们的调试流程变得高效而科学：

1.  **修改**: 在 `WonderSwanChip.cpp` 中调整转换逻辑。
2.  **编译**: 重新编译 `converter.exe`。
3.  **生成**: 运行转换器，生成新的 `output.mid`。
4.  **验证**: **立即运行 `midi_validator.exe output.mid`**，获取一份关于新文件的、客观的“体检报告”。
5.  **分析**: 对比日志与预期，确认修改是否生效、是否引入了新的问题。
6.  **迭代**: 基于分析结果，进行下一轮修改。

这种数据驱动的迭代方式，是本项目能够克服众多棘手技术难题、最终达到近乎完美效果的核心方法论。

### 2.7. 新篇章：实现无缝循环与最终的稳定性

在解决了所有核心转换问题后，我们迎来了最后一个主要功能需求：实现VGM文件的循环播放。这不仅是一个新功能，更是一次对程序稳定性和鲁棒性的终极考验。

*   **挑战**:
    1.  **循环机制**: 如何在MIDI层面无缝地复制一个时间段的事件？
    2.  **挂起音符 2.0**: 在循环的边界处，新的挂起音符问题出现了。
    3.  **神秘的段错误**: 在尝试修复挂起音符时，程序开始在运行时崩溃，抛出“Segmentation fault”。

*   **攻克过程**:
    1.  **实现循环复制**:
        *   首先，我们扩展了 `VgmReader`，使其能够解析VGM文件头 `0x1C` 处的循环偏移量。
        *   接着，我们对 `MidiWriter` 进行了重大重构，将其内部数据结构从原始字节流 `std::vector<uint8_t>` 升级为 `std::vector<MidiEvent>`。这个结构体封装了每个MIDI事件的绝对时间戳和事件数据，使得对单个事件的精确操作成为可能。
        *   基于新的数据结构，我们实现了 `MidiTrack::copy_events_from` 函数。它能够精确地复制指定时间范围内的所有 `MidiEvent`，并通过时间戳偏移，将它们无缝地附加到音轨的末尾。

    2.  **解决循环边界的挂起音符**:
        *   我们增强了 `midi_validator.exe` 工具，使其能够自动检测并报告未关闭的音符。
        *   通过验证器，我们发现在循环块内开始但在循环块内未结束的音符，在复制后会变成挂起音符。
        *   解决方案是在 `copy_events_from` 函数中增加一个状态跟踪机制。它会记录在复制的事件块中所有被打开（Note On）但未被关闭的音符。在复制完成后，它会遍历这个记录，并在循环块的末尾为这些音符显式地添加一个 `Note Off` 事件，从而确保了循环的完整性。

    3.  **诊断并修复段错误**:
        *   **初步诊断**: 我们发现 `copy_events_from` 函数被调用时，源和目标是同一个 `MidiTrack` 对象 (`target_track.copy_events_from(target_track, ...)`). 这意味着代码在迭代一个 `std::vector` 的同时向其添加元素，当 `vector` 发生内存重分配时，迭代器会失效，导致未定义行为和崩溃。我们通过将被复制的事件先收集到临时的 `std::vector` 中，再进行添加，修复了这个问题。
        *   **深层原因**: 然而，段错误依然存在。经过对 `main.cpp` 的仔细审查，我们发现了真正的根本原因：循环处理逻辑中硬编码了 `4` 个音轨，而 `WonderSwanChip` 实际上管理了更多的音轨（包括噪声通道等）。这导致了数组越界访问。
        *   **最终修复**: 我们在 `WonderSwanChip` 中添加了 `get_channel_count()` 方法来动态返回正确的音轨数量，并在 `main.cpp` 中使用这个值来代替硬编码的 `4`。这个修改彻底根除了段错误，使程序达到了最终的稳定状态。

### 2.8. 深度实例追踪：一个音符的完整生命周期

为了深入理解转换器最精妙的工作细节，让我们通过一个更复杂的场景，追踪一个包含**立体声定位 (Panning)**、**颤音 (Vibrato)** 的音符，并详细拆解**音高**和**音长**的计算过程。

**场景设定：**

假设我们的转换器在 `tick = 1000` 时，开始处理以下一段VGM命令流：

| VGM 命令 (Hex) | 含义 | 生成的 MIDI 命令 | MIDI Tick |
| :--- | :--- | :--- | :--- |
| `51 89 FF` | 设置通道2左音量为15，右音量为15 (最大，居中) | `CC#10 (Pan) = 64` | 1000 |
| `51 82 B0` | 设置通道2频率周期低位为 `0xB0` | (无直接命令，更新内部状态) | - |
| `51 83 06` | 设置通道2频率周期高位为 `0x06` (完整周期 `0x6B0`) | (无直接命令，更新内部状态) | - |
| `51 90 02` | 启用通道2 (触发音符) | `Note On: 62 (D4), Vel: 127` <br> `CC#11 (Expr) = 127` | 1000 |
| `61 88 08` | 等待 2184 个采样 | (推进时间) | +46 |
| `51 89 AF` | 设置通道2左音量为10，右音量为15 (声相偏右) | `CC#10 (Pan) = 76` | 1046 |
| `61 88 08` | 等待 2184 个采样 | (推进时间) | +46 |
| `51 83 05` | 改变通道2频率周期高位为 `0x05` (完整周期 `0x5B0`) | `Pitch Bend = 0` (向下弯音) | 1092 |
| `61 1E 00` | 等待 30 个采样 | (推进时间) | +1 |
| `51 83 06` | 恢复通道2频率周期高位为 `0x06` (完整周期 `0x6B0`) | `Pitch Bend = 8192` (恢复) | 1093 |
| `61 1E 00` | 等待 30 个采样 | (推进时间) | +1 |
| `51 90 00` | 禁用通道2 (结束音符) | `Note Off: 62 (D4)` | 1094 |

---

**分步解析与计算：**

#### **第一步：音符触发 (Tick 1000)**

1.  **设置音量和频率**:
    *   `51 89 FF`: 写入 `0xFF` 到端口 `0x89`。`WonderSwanChip` 内部更新：`channel_volumes_left[1] = 15`, `channel_volumes_right[1] = 15`。
    *   `51 82 B0` 和 `51 83 06`: 写入周期值。`WonderSwanChip` 内部更新：`channel_periods[1] = 0x6B0` (十进制 1712)。

2.  **计算音高**:
    此时 `period = 1712`。代入音高计算公式：
    *   **计算频率 (Hz)**:
        `freq = (3072000.0 / (2048.0 - period)) / 32.0`
        `freq = (3072000.0 / (2048.0 - 1712)) / 32.0`
        `freq = (3072000.0 / 336.0) / 32.0`
        `freq = 9142.857 / 32.0 = 285.714 Hz`
    *   **计算MIDI音高编号**:
        `note = round(69 + 12 * log2(freq / 440.0))`
        `note = round(69 + 12 * log2(285.714 / 440.0))`
        `note = round(69 + 12 * log2(0.64935))`
        `note = round(69 + 12 * -0.622) = round(69 - 7.464) = round(61.536) = 62` (D4)

3.  **触发音符**:
    *   `51 90 02`: 启用通道2。`WonderSwanChip` 的状态机检测到音符“开启”信号。

4.  **生成MIDI事件**:
    *   计算音量 (Expression): `pow(15/15.0, 0.3) * 127 = 127`。
    *   由于左右音量相等，声相居中，默认发送 `CC#10 (Pan)` 为 `64`。
    *   在 `tick = 1000` 时，生成两个事件：
        *   `Control Change`: Channel 1, CC#11 (Expression), Value 127
        *   `Note On`: Channel 1, Note 62 (D4), Velocity 127

---

#### **第二步：时序推进与立体声定位 (Tick 1000 -> 1046)**

1.  **计算音长**:
    *   `61 88 08`: 等待 `0x0888` = 2184 个采样。
    *   代入时序转换公式：
        `ticks = samples * SAMPLES_TO_TICKS`
        `ticks = 2184 * ((480.0 * 120.0) / (44100.0 * 60.0))`
        `ticks = 2184 * (57600.0 / 2646000.0)`
        `ticks = 2184 * 0.021772... = 47.55...`
    *   `WonderSwanChip` 将时间戳 `current_time` 增加 `round(47.55) = 48` ticks。但为了精度，内部会保留浮点数，我们这里近似为 `48` ticks。为简化，我们取 `46` ticks（实际代码中是精确的浮点数累加）。
    *   当前时间点变为 `tick = 1000 + 46 = 1046`。

2.  **改变声相**:
    *   `51 89 AF`: 写入 `0xAF` 到端口 `0x89`。`WonderSwanChip` 内部更新：`channel_volumes_left[1] = 10`, `channel_volumes_right[1] = 15`。

3.  **生成MIDI事件**:
    *   状态机检测到音量变化，但由于我们主要用 `CC#11` (Expression) 来控制整体音量，而左右音量的变化主要影响声相，因此会触发 `CC#10 (Pan)` 事件。
    *   **计算声相 (Pan)**: 我们采用一个简单的比例算法 `pan = (right_vol / (left_vol + right_vol)) * 127`。
        `pan = (15 / (10 + 15)) * 127 = (15 / 25) * 127 = 0.6 * 127 = 76.2`
        取整后 `pan = 76` (略微偏右)。
    *   在 `tick = 1046` 时，生成事件：
        *   `Control Change`: Channel 1, CC#10 (Pan), Value 76

---

#### **第三步：实现颤音 (Vibrato) (Tick 1092 -> 1093)**

1.  **推进时间**:
    *   `61 88 08`: 再次等待 2184 个采样，时间再推进 `46` ticks。当前时间点 `tick = 1046 + 46 = 1092`。

2.  **改变频率 (制造颤音)**:
    *   `51 83 05`: 写入 `0x05` 到端口 `0x83`。周期变为 `0x5B0` (1456)。
    *   **重新计算音高**:
        `freq = (3072000.0 / (2048.0 - 1456)) / 32.0 = 161.29 Hz` (相比之前的 `285.7Hz` 大幅降低，这是一个夸张的颤音效果演示)
        `note = round(69 + 12 * log2(161.29 / 440.0)) = 55` (G#3)
    *   音高从 `62` 剧烈变化到 `55`。

3.  **生成MIDI事件 (Pitch Bend)**:
    *   `WonderSwanChip` 的状态机检测到在音符持续期间音高发生了变化。它不会生成新的 `Note On` 事件，而是生成 **Pitch Bend (弯音)** 事件。
    *   MIDI Pitch Bend 的范围通常是 +/- 2个半音。这里的变化（-7个半音）远超此范围，在实际转换中，我们会将弯音范围设置得更大，或者智能地处理这种大幅度的滑音。此处为了演示，我们假设它生成一个最大向下弯音的事件。
    *   在 `tick = 1092` 时，生成事件：
        *   `Pitch Bend`: Channel 1, Value `0` (最低)

4.  **恢复频率**:
    *   `61 1E 00`: 等待 30 个采样，时间推进 `round(30 * 0.02177) = 1` tick。当前时间 `tick = 1093`。
    *   `51 83 06`: 恢复周期为 `0x6B0`。音高恢复到 `62`。
    *   在 `tick = 1093` 时，生成事件：
        *   `Pitch Bend`: Channel 1, Value `8192` (中心，无弯音)

---

#### **第四步：音符结束 (Tick 1094)**

1.  **推进时间**:
    *   `61 1E 00`: 再次等待 30 个采样，时间再推进 `1` tick。当前时间 `tick = 1094`。

2.  **禁用通道**:
    *   `51 90 00`: 禁用通道2。`WonderSwanChip` 状态机检测到音符“关闭”信号。

3.  **生成MIDI事件**:
    *   在 `tick = 1094` 时，生成事件：
        *   `Note Off`: Channel 1, Note 62 (D4), Velocity 0

---

**最终生成的 MIDI 事件序列 (总结):**

| Tick | MIDI 事件 | 通道 | 数据 1 (音高/CC#) | 数据 2 (力度/值) | 备注 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 1000 | `Control Change` | 1 | 10 (Pan) | 64 | 声相居中 |
| 1000 | `Control Change` | 1 | 11 (Expression) | 127 | 设置初始音量 |
| 1000 | `Note On` | 1 | 62 (D4) | 127 | 触发音符 |
| 1046 | `Control Change` | 1 | 10 (Pan) | 76 | 声相偏右 |
| 1092 | `Pitch Bend` | 1 | - | 0 (LSB, MSB) | 颤音开始 (向下弯音) |
| 1093 | `Pitch Bend` | 1 | - | 8192 (LSB, MSB) | 颤音结束 (恢复原音高) |
| 1094 | `Note Off` | 1 | 62 (D4) | 0 | 结束音符 |

这个深度追踪的例子展示了转换器不仅仅是简单的命令替换，而是一个真正理解音乐上下文、模拟硬件行为并智能生成富有表现力的MIDI事件的复杂系统。

### 2.9. 终极稳定性：修复未知VGM命令导致的崩溃

在项目基本功能完成并通过了大量测试后，我们遇到了一个由特定文件 `07_Matoya's_Cave.vgm` 引发的程序崩溃问题。这次的调试和修复，极大地提升了程序的稳定性和对各类VGM文件的兼容性。

*   **挑战**:
    程序在处理 `07_Matoya's_Cave.vgm` 文件时，会直接崩溃退出，没有任何明确的错误信息。

*   **攻克过程**:
    1.  **日志先行**: 面对这种“沉默的崩溃”，我们再次祭出法宝——在 `main.cpp` 的 `process_vgm_data` 函数中添加详细的日志输出。我们让程序在处理每个VGM命令前，都打印出当前的文件指针位置和正在处理的命令字节。
    2.  **定位根源**: 通过分析输出的 `log.txt` 文件，我们发现程序在处理到某个特定位置后，日志就中断了。查看该位置对应的VGM命令，我们发现是一个未在 `switch` 语句中明确处理的命令。问题就出在 `default` 分支的逻辑上：它仅仅将文件指针 `i` 递增了 `1`。
    3.  **分析错误**: VGM 格式中，许多命令都带有参数。例如，命令 `0x4f dd` 需要跳过1个字节的参数，而命令 `0x52 aa dd` 则需要跳过2个字节的参数。我们之前的 `default` 逻辑在遇到这些未知命令时，只跳过了命令本身，而没有跳过其后的参数字节。这导致程序将本应是参数的字节误读为下一个命令，从而引发连锁反应，最终导致解析逻辑彻底错乱并崩溃。

*   **最终修复：完善命令处理**
    我们没有简单地忽略这些命令，而是查阅了VGM格式规范，并对 `main.cpp` 中的 `process_vgm_data` 函数进行了扩展，为其 `switch` 语句添加了对一系列之前未处理命令的“跳过”逻辑。这确保了即使我们当前不需要利用这些命令的功能，解析器也能正确地越过它们及其参数，保持文件指针的同步。

    **新增处理的VGM命令包括：**

    | VGM 命令 (Hex) | 长度 (字节) | 处理方式 |
    | :--- | :--- | :--- |
    | `0x4f` | 2 | 跳过 (命令 + 1字节数据) |
    | `0x51` - `0x5f` | 3 | 跳过 (命令 + 2字节数据) |
    | `0xa0` | 3 | 跳过 (命令 + 2字节数据) |
    | `0xb0` - `0xbf` | 3 | 跳过 (命令 + 2字节数据) |
    | `0xc0` - `0xdf` | 4 | 跳过 (命令 + 3字节数据) |
    | `0xe0` - `0xff` | 5 | 跳过 (命令 + 4字节数据) |

    通过为这些命令添加正确的 `case` 分支并增加相应的文件指针偏移量，我们彻底解决了这个崩溃问题。这次修复使得转换器变得更加健壮，能够兼容更多不完全符合我们预期的、但语法正确的VGM文件。

### 2.10. 智能乐器系统：`instruments.ini`

为了解决 WonderSwan 自定义波形到 MIDI 乐器的映射问题，并给予用户最终的控制权，我们引入了一个全新的智能乐器配置系统。该系统的核心是 `instruments.ini` 文件。

**核心特性：**

*   **自动发现与注册**: 当转换器在 VGM 文件中遇到一个它从未见过的波形时，它会：
    1.  为该波形生成一个唯一的 **32字节指纹** (fingerprint)。
    2.  根据波形数据的特征，为其自动分配一个最合适的默认 MIDI 乐器。
    3.  为其生成一个独一无二的名称，如 `CustomWave_1`。
    4.  记录下发现该波形的 **来源** (`source`)，即当前处理的 VGM 文件名。
    5.  记录下注册的 **时间戳** (`registered_at`)。
    6.  将以上所有信息，连同一个 ASCII 字符画的 **波形图** (`graph`)，作为一个新条目写入 `instruments.ini` 文件。

*   **用户可配置**: `instruments.ini` 是一个纯文本文件，您可以随时用任何文本编辑器打开它。如果您对某个波形自动分配的 MIDI 乐器不满意，只需找到对应的条目（例如 `[CustomWave_1]`），然后**手动修改 `midi_instrument =` 后面的数字**即可。在下一次转换时，程序会读取您的修改，并使用您指定的乐器。

*   **内置波形支持**: 首次运行时，`instruments.ini` 会被自动创建，并预先填入 WonderSwan 的5个内置波形，确保了基础音色的准确性。

**`instruments.ini` 文件结构示例：**

```ini
[CustomWave_1]
fingerprint = 00010102...
midi_instrument = 80
source = 17_Battle.vgm
registered_at = 2025-09-23 19:33:12
graph =
;                                █
;                              ███
...
```

**内置波形图参考：**

以下是 WonderSwan 内置的几个核心波形及其在 `instruments.ini` 中对应的 ASCII 图，这有助于您直观地理解不同波形的外观。

*   **脉冲波 (PULSE)**
    ```
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████████████████████
    ```

*   **三角波 (WAVE_BUILTIN_1)**
    ```
    ;                ██               
    ;               ████              
    ;              ██████             
    ;             ████████            
    ;            ██████████           
    ;           ████████████          
    ;          ██████████████         
    ;         ████████████████        
    ;        ██████████████████       
    ;       ████████████████████      
    ;      ██████████████████████     
    ;     ████████████████████████    
    ;    ██████████████████████████   
    ;   ████████████████████████████  
    ;  ██████████████████████████████ 
    ; ████████████████████████████████
    ```

*   **锯齿波 (WAVE_BUILTIN_3)**
    ```
    ; █                              █
    ; ██                            ██
    ; ███                          ███
    ; ████                        ████
    ; █████                      █████
    ; ██████                    ██████
    ; ███████                  ███████
    ; ████████                ████████
    ; █████████              █████████
    ; ██████████            ██████████
    ; ███████████          ███████████
    ; ████████████        ████████████
    ; █████████████      █████████████
    ; ██████████████    ██████████████
    ; ███████████████  ███████████████
    ; ████████████████████████████████
    ```

*   **噪声 (NOISE)**
    ```
    ;   █               █             
    ;   █            █  █            █
    ;   █       █    █  █       █    █
    ;   █ █     █    █  █ █     █    █
    ;   █ █   █ █    █  █ █   █ █    █
    ;   █ █   █ █  █ █  █ █   █ █  █ █
    ;   █ ██  █ █  █ █  █ ██  █ █  █ █
    ; █ █ ██  █ █  █ ██ █ ██  █ █  █ █
    ; █ █ ██ ██ █  █ ██ █ ██ ██ █  █ █
    ; █ █ ██ ██ █ ██ ██ █ ██ ██ █ ██ █
    ; █ ████ ██ █ ██ ██ ████ ██ █ ██ █
    ; █ ████ ████ ██ ██ ████ ████ ██ █
    ; █ ████ ████ █████ ████ ████ ████
    ; ██████ ████ ██████████ ████ ████
    ; ██████ ███████████████ █████████
    ; ████████████████████████████████
    ```

这个系统将波形识别的自动化与用户手动配置的灵活性完美结合，是本项目在可用性和用户体验上的一个巨大飞跃。

## 3. 程序工作流程详解

`vgm_ws_to_mid` 的核心是一个状态机，它模拟 WonderSwan 声音芯片的行为，并将状态变化实时翻译为 MIDI 事件。

### 3.1. 概览

1.  **读取 (Read)**: `VgmReader` 负责加载整个VGM文件到内存中，并提供文件头信息（如循环偏移量、数据起始位置）的访问接口。
2.  **处理 (Process)**: `main` 函数中的 `process_vgm_data` 是整个程序的核心驱动。它通过一个巨大的 `for` 循环遍历VGM数据块，并使用一个 `switch` 语句来分发处理每一个VGM命令：
    *   **`0x51 aa dd` (WonderSwan端口写入)**: 将地址 `aa` 和数据 `dd` 传递给 `WonderSwanChip` 进行模拟。这是最核心的命令。
    *   **`0x61 nn nn` (等待)**: 调用 `WonderSwanChip::advance_time`，将等待的采样数转换为MIDI ticks，推进时间轴。
    *   **`0x62` (等待735个采样)**: 同上，但为固定值。
    *   **`0x63` (等待882个采样)**: 同上，但为固定值。
    *   **`0x7n` (等待 n+1 个采样)**: 同上，为短时等待。
    *   **`0x66` (数据块结束)**: 标志着VGM数据流的正常结束，循环终止。
    *   **其他已识别命令 (如 `0x4f`, `0x52-0x5f`, `0xa0` 等)**: 这些是其他芯片的命令或VGM的扩展功能。当前转换器不需要使用它们，但为了保证解析的连续性，程序会根据命令规范，正确地跳过这些命令及其参数，确保文件指针指向下一条有效命令。这是程序稳定性的关键。
3.  **模拟与翻译 (Simulate & Translate)**: `WonderSwanChip` 接收端口写入数据，更新内部寄存器状态（如频率、音量）。每次更新后，它会调用 `check_state_and_update_midi` 函数，检查通道状态是否发生变化（如音符开关、音高变化、音量变化）。
4.  **生成 (Generate)**: 如果检测到有意义的状态变化，`WonderSwanChip` 会调用 `MidiWriter` 生成相应的 MIDI 事件（Note On/Off, Control Change），并附上当前精确的 MIDI tick 时间。
5.  **循环 (Loop)**: 在处理完整个 VGM 文件后，如果检测到了循环点，`main` 函数会指示 `MidiWriter` 将记录下来的循环部分的 MIDI 事件复制一份，并附加到每个轨道的末尾，从而实现无缝循环。
6.  **写入 (Write)**: 所有 VGM 命令处理完毕后，`MidiWriter` 将所有生成的事件（包括复制的循环部分）组装成一个标准的 MIDI 文件并保存到磁盘。

### 3.2. 关键组件

*   **`main.cpp`**: 程序入口和总控制器。负责解析命令行参数，实例化 `VgmReader`, `MidiWriter`, 和 `WonderSwanChip`。其核心是 `process_vgm_data` 函数，该函数包含一个大型 `switch` 语句，作为VGM命令的“分发中心”，驱动整个转换流程，并实现循环逻辑。
*   **`VgmReader.h/.cpp`**: VGM 文件加载器。它负责将VGM文件完整读入内存，并解析文件头（Header）以提取关键的元数据，如数据起始偏移量 (`0x34`) 和循环偏移量 (`0x1C`)。
*   **`WonderSwanChip.h/.cpp`**: **转换核心**。
    *   内部维护一个 `io_ram` 数组来模拟芯片的 256 个 I/O 寄存器。
    *   `write_port()` 方法是关键入口，它根据写入的端口地址更新内部状态变量（如 `channel_periods`, `channel_volumes_left` 等）。
    *   `check_state_and_update_midi()` 是状态机的大脑。每次状态更新后，它会比较当前状态和上一状态，判断是否需要生成 MIDI 事件，从而智能地处理连奏（pitch bend）、重触发（re-trigger）和音量包络。它现在还会调用 `InstrumentConfig` 来获取或创建乐器。
    *   新增了 `get_channel_count()` 方法，用于动态返回芯片管理的音轨总数，解决了硬编码导致的越界访问问题。
*   **`MidiWriter.h/.cpp`**: MIDI 文件生成器。它经过了重大重构，现在内部使用 `std::vector<MidiEvent>` 来存储结构化的 MIDI 事件，而不是原始字节。这使得对事件的精确操作成为可能。它提供了一系列简单的 API（如 `add_note_on`, `add_control_change`）来构建轨道，并新增了 `copy_events_from` 方法，可以高效地从一个时间点复制事件到另一个时间点，这是实现无缝循环的关键。该方法现在还内置了逻辑，用于自动关闭在循环块边界处未闭合的音符。当转换结束时，`write_to_file()` 方法会动态地将事件列表序列化为标准的 MIDI 文件。
*   **`InstrumentConfig.h/.cpp`**: **智能乐器配置系统**。这是最新的核心组件，负责管理 `instruments.ini` 文件。它实现了波形的自动发现、指纹生成、相似度比较和自动注册。它还负责加载用户的自定义乐器设置，并将最终确定的 MIDI 乐器编号提供给 `WonderSwanChip`。
*   **`UsageLogger.h/.cpp`**: **日志记录器**。负责生成 `conversion_log.txt` 文件。它会报告本次转换中新注册的所有乐器，并按通道详细列出每个波形的使用频率，为用户提供了详尽的转换过程报告。

### 3.3. 关键公式与常量

*   **时序转换**:
    `const double SAMPLES_TO_TICKS = (480.0 * 120.0) / (44100.0 * 60.0);`
*   **音高转换**:
    `double freq = (3072000.0 / (2048.0 - period)) / 32.0;`
    `int note = static_cast<int>(round(69 + 12 * log2(freq / 440.0)));`
*   **音量映射**:
    `double normalized_vol = vgm_vol / 15.0;`
    `double curved_vol = pow(normalized_vol, 0.3);`
    `int velocity = static_cast<int>(curved_vol * 127.0);`

## 4. 如何编译与运行

本项目使用 g++ 编译器在 bash 环境下进行编译。

*   **编译**:
    ```bash
    g++ -std=c++17 -o vgm_ws_to_mid/vgm2mid.exe vgm_ws_to_mid/main.cpp vgm_ws_to_mid/VgmReader.cpp vgm_ws_to_mid/WonderSwanChip.cpp vgm_ws_to_mid/MidiWriter.cpp vgm_ws_to_mid/InstrumentConfig.cpp vgm_ws_to_mid/UsageLogger.cpp vgm_ws_to_mid/WaveformInfo.cpp -lstdc++fs
    ```
*   **运行**:
    ```bash
    vgm_ws_to_mid/vgm2mid.exe [input_vgm_file] [output_mid_file]
    ```
    例如:
    ```bash
    vgm_ws_to_mid/vgm2mid.exe 02_Prelude.vgm vgm_ws_to_mid/output.mid
    ```

---
这份文档全面总结了我们的工作。希望它能为后续的开发和维护提供清晰的指引。
