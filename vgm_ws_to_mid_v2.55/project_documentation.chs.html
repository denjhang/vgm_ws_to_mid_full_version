<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vgm_ws_to_mid: WonderSwan VGM to MIDI 转换器 - 项目文档</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            padding-bottom: 50px; /* Add padding to prevent content from being hidden by the progress bar */
        }
        #progress-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 8px;
            background-color: #f0f0f0;
            z-index: 1000;
            cursor: pointer;
        }
        #progress-bar {
            height: 100%;
            width: 0;
            background-color: #0366d6;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h3 { font-size: 1.25em; }
        h4 { font-size: 1em; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        code {
            padding: .2em .4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 3px;
        }
        pre code {
            display: inline;
            padding: 0;
            margin: 0;
            overflow: visible;
            line-height: inherit;
            word-wrap: normal;
            background-color: transparent;
            border: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1em;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid #dfe2e5;
            padding: 6px 13px;
        }
        th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        ul, ol { padding-left: 2em; }
        li { margin-top: .25em; }

        /* Hierarchical TOC styles */
        .toc-level-1 { font-weight: 500; }
        .toc-level-2 { margin-left: 1.5em; }
        .toc-level-3 { margin-left: 3em; }
        .toc-level-4 { margin-left: 4.5em; }
        .toc-level-1 > a { font-size: 1.1em; }
        .toc-level-2 > a { font-size: 1.0em; }
        .toc-level-3 > a { font-size: 0.95em; }
        .toc-level-4 > a { font-size: 0.9em; color: #333; }

        blockquote {
            margin-left: 0;
            padding-left: 1em;
            color: #6a737d;
            border-left: .25em solid #dfe2e5;
        }
    </style>
</head>
<body>
<div id="progress-container">
    <div id="progress-bar"></div>
</div>
<h1 id="vgm-ws-to-mid-wonderswan-vgm-to-midi">vgm_ws_to_mid: WonderSwan VGM to MIDI 转换器 - 项目文档</h1>
<p>本文档详细记录了 <code>vgm_ws_to_mid</code> 转换器的开发历程、技术实现细节以及最终程序的工作流程。</p>
<h2 id="">摘要</h2>
<p>本文档全面概述了 <code>vgm_ws_to_mid</code> 项目，这是一个专门用于将 WonderSwan VGM 音乐文件转换为富有表现力的高质量MIDI文件的转换器。该项目是声音测试员和程序员之间合作的成果，通过对 <code>libvgm</code> 和 <code>modizer</code> 项目的逆向工程，克服了官方硬件文档缺失的困难。</p>
<p>文档分为几个关键部分：</p>
<ul>
<li>  <strong>核心功能</strong>: 概述了转换器的主要能力，包括精确的音高/时序转换、动态音量和声相、颤音等高级效果、无缝循环，以及智能乐器系统 (<code>instruments.ini</code>)。</li>
<li>  <strong>开发历程</strong>: 详细叙述了项目的演进过程，记录了重大的技术障碍——如修正音高、修复“音符卡死”问题和实现稳定的循环——以及为克服这些障碍而开发的创新解决方案。本部分强调了定制化验证工具在调试过程中的关键作用。</li>
<li>  <strong>技术深潜</strong>: 提供了对WonderSwan声音架构、程序内部工作流程的深入解释，以及一个复杂音乐段落如何从VGM命令转换为MIDI事件的逐步追踪。</li>
<li>  <strong>使用与编译</strong>: 提供了关于如何编译转换器及其辅助工具的清晰说明，以及如何使用程序的命令行功能进行单文件转换、批量处理和乐器管理。</li>
</ul>
<p>本文档既是用户手册，也是未来开发和维护的详细技术参考。</p>
<h2 id="table-of-contents">目录</h2>
<ul>
<li class="toc-level-1"><a href="#1">1. 项目背景</a></li>
<li class="toc-level-2"><a href="#1-1">1.1. 致谢</a></li>
<li class="toc-level-2"><a href="#1-2">1.2. 参考</a></li>
<li class="toc-level-1"><a href="#2">2. 功能大纲与核心实现</a></li>
<li class="toc-level-2"><a href="#2-1">2.1. 核心功能亮点</a></li>
<li class="toc-level-2"><a href="#2-2">2.2. 生成的MIDI事件列表</a></li>
<li class="toc-level-1"><a href="#3">3. 开发历程：从零到完美的转换器</a></li>
<li class="toc-level-2"><a href="#3-1">3.1. 初期探索：解构核心逻辑</a></li>
<li class="toc-level-2"><a href="#3-2">3.2. 第一座大山：修正音高与时序</a></li>
<li class="toc-level-2"><a href="#3-3">3.3. 无声的 MIDI：解密动态音量</a></li>
<li class="toc-level-2"><a href="#3-4">3.4. 最终的润色：音量映射的艺术</a></li>
<li class="toc-level-2"><a href="#3-5">3.5. 终极难题：解决音量突变与音符挂起</a></li>
<li class="toc-level-2"><a href="#3-6">3.6. 自我修正的反馈闭环：定制化验证工具的力量</a></li>
<li class="toc-level-2"><a href="#3-7">3.7. 新篇章：实现无缝循环与最终的稳定性</a></li>
<li class="toc-level-2"><a href="#3-8">3.8. 深度实例追踪：一个音符的完整生命周期</a></li>
<li class="toc-level-2"><a href="#3-9">3.9. 终极稳定性：修复未知VGM命令导致的崩溃</a></li>
<li class="toc-level-2"><a href="#3-10">3.10. 智能乐器系统：<code>instruments.ini</code></a></li>
<li class="toc-level-2"><a href="#3-11">3.11. 捕捉音乐表现力：为颤音实现弯音轮</a></li>
<li class="toc-level-1"><a href="#4">4. 深入解析 WonderSwan 声音系统</a></li>
<li class="toc-level-2"><a href="#4-1">4.1. 声音通道概览</a></li>
<li class="toc-level-2"><a href="#4-2">4.2. 四个主要音频通道（可编程音调）</a></li>
<li class="toc-level-2"><a href="#4-3">4.3. 特殊通道功能</a></li>
<li class="toc-level-1"><a href="#5">5. 程序工作流程详解</a></li>
<li class="toc-level-2"><a href="#5-1">5.1. 概览</a></li>
<li class="toc-level-2"><a href="#5-2">5.2. 关键组件</a></li>
<li class="toc-level-2"><a href="#5-3">5.3. 关键公式与常量</a></li>
<li class="toc-level-2"><a href="#5-4">5.4. 转换日志 (<code>conversion_log.txt</code>)</a></li>
<li class="toc-level-1"><a href="#6">6. 使用方法</a></li>
<li class="toc-level-2"><a href="#6-1">6.1. 单文件转换</a></li>
<li class="toc-level-2"><a href="#6-2">6.2. 批量转换 (<code>-b</code>)</a></li>
<li class="toc-level-2"><a href="#6-3">6.3. 乐器排序 (<code>-s</code>)</a></li>
<li class="toc-level-2"><a href="#6-4">6.4. 指定循环次数 (<code>-l</code>)</a></li>
<li class="toc-level-1"><a href="#7">7. 如何编译与运行</a></li>
<li class="toc-level-1"><a href="#8">8. 辅助工具</a></li>
<li class="toc-level-2"><a href="#8-1">8.1. MIDI 验证器 (<code>midi_validator.exe</code>)</a></li>
<li class="toc-level-2"><a href="#8-2">8.2. 专用VGM命令转储器 (<code>simple_hex_dump.exe</code>)</a></li>
<li class="toc-level-2"><a href="#8-3">8.3. 通用十六进制转储器 (<code>hex_dumper.exe</code>)</a></li>
<li class="toc-level-2"><a href="#8-4">8.4. Markdown 到 HTML 转换器 (<code>markdown_to_html.exe</code>)</a></li>
</ul>
<hr>
<h2 id="1">1. 项目背景</h2>
<h3 id="1-1">1.1. 致谢</h3>
<p>本项目是我们精诚合作的成果：</p>
<ul>
<li>  <strong>Denjhang</strong>: 负责声音测试，并对输出结果提供关键反馈。</li>
<li>  <strong>Cline</strong>: 负责根据反馈进行编程、调试和实现转换逻辑。</li>
</ul>
<h3 id="1-2">1.2. 参考</h3>
<p>本项目站在巨人的肩膀上，其成功源于对两个关键开源项目的借鉴与整合。以下详细说明了转换器的不同部分分别受到了哪些源文件的启发。</p>
<h4 id="1-2-1">1.2.1. <code>libvgm</code></h4>
<p><code>libvgm</code> 是本项目的基石，它为解析VGM文件格式本身提供了核心逻辑。没有 <code>libvgm</code>，读取和解释原始VGM数据流将是一项几乎不可能完成的任务。</p>
<ul>
<li>  <strong>核心贡献</strong>: VGM文件解析与命令分发。</li>
<li>  <strong>关键源文件</strong>: <code>libvgm/player/vgmplayer.cpp</code></li>
<li>  <strong>如何使用</strong>: 我们 <code>main.cpp</code> 中的主 <code>switch</code> 语句是 <code>vgmplayer.cpp</code> 中命令处理循环的直接改编。我们研究了 <code>libvgm</code> 如何处理不同的VGM命令（例如 <code>0x61</code>, <code>0x62</code>, <code>0x66</code>, <code>0x51</code>）并复制了该结构。这包括：</li>
<li>  根据命令长度推进文件指针的逻辑。</li>
<li>  处理等待命令（<code>0x61</code>, <code>0x62</code>, <code>0x63</code>, <code>0x7n</code>）的逻辑，这构成了我们时序系统的基础。</li>
<li>  对未使用或不支持的VGM命令的正确“跳过”逻辑，这对于确保解析器的稳定性至关重要（如2.9节所述）。</li>
</ul>
<h4 id="1-2-2">1.2.2. <code>modizer</code></h4>
<p>如果说 <code>libvgm</code> 教会了我们如何阅读地图（VGM文件），那么 <code>modizer</code> 则给了我们解密地图上最神秘符号（WonderSwan特定的音频寄存器）的钥匙。它提供了硬件级的模拟逻辑，这对于正确解释 <code>libvgm</code> 帮助我们解析出的数据流至关重要。</p>
<ul>
<li>  <strong>核心贡献</strong>: WonderSwan声音芯片模拟逻辑。</li>
<li>  <strong>关键源文件</strong>: <code>modizer-master/libs/libwonderswan/libwonderswan/oswan/audio.cpp</code></li>
<li>  <strong>如何使用</strong>: 我们的 <code>WonderSwanChip.cpp</code> 本质上是 <code>modizer</code> 的 <code>audio.cpp</code> 中逻辑的C++重新实现和改编。通过研究这个文件，我们取得了众多突破：</li>
<li>  <strong>音高计算</strong>: 神奇的公式 <code>freq = (3072000 / (2048 - period)) / 32</code> 直接源自 <code>modizer</code> 的频率计算代码。除以32（代表波形表大小）是实现正确音高的最重要发现。</li>
<li>  <strong>寄存器映射</strong>: 通过观察 <code>audio.cpp</code> 在写入这些端口时如何更新其内部状态变量，我们破译了从 <code>0x80</code> 到 <code>0x94</code> 的所有关键I/O端口的功能。这包括频率、音量、声相、扫描和噪声控制。</li>
<li>  <strong>硬件怪癖</strong>: <code>modizer</code> 的代码还揭示了非显而易见的硬件行为，例如声音DMA过程如何将其输出写入通道2的音量寄存器（<code>0x89</code>），我们忠实地模拟了这一点。</li>
</ul>
<p>总而言之，<code>libvgm</code> 提供了 <strong>读取数据的框架</strong>，而 <code>modizer</code> 提供了 <strong>理解数据的知识</strong>。这两个资源的结合是本项目成功的秘诀。</p>
<h2 id="2">2. 功能大纲与核心实现</h2>
<p>本节总结了 <code>vgm_ws_to_mid</code> 转换器实现的核心功能，并列出了其能够生成的所有MIDI事件类型。</p>
<h3 id="2-1">2.1. 核心功能亮点</h3>
<ul>
<li>  <strong>精确的音高与时序转换</strong>: 基于对硬件模拟代码的逆向工程，实现了从VGM周期值到MIDI音高、从VGM采样等待到MIDI ticks的精确数学转换。</li>
<li>  <strong>富有表现力的动态音量</strong>: 使用非线性映射曲线 (<code>pow(vol, 0.3)</code>) 将WonderSwan的4-bit音量映射到MIDI CC#11 (Expression)，解决了动态范围压缩问题，使音乐听感饱满。</li>
<li>  <strong>智能的立体声声相 (Panning)</strong>: 通过解析并对比左右声道的独立音量，智能生成MIDI CC#10 (Pan) 事件，完美再现了原始的立体声效果。</li>
<li>  <strong>高级音符效果</strong>:</li>
<li>  <strong>颤音 (Vibrato)</strong>: 能够捕捉音符持续期间的细微频率变化，并将其转换为一系列的MIDI Pitch Bend事件。</li>
<li>  <strong>滑音 (Glissando/Portamento)</strong>: 对于大幅度的频率变化，同样通过Pitch Bend实现平滑的音高过渡。</li>
<li>  <strong>健壮的状态机</strong>: 彻底重构的状态机逻辑能够精确追踪每个音符的生命周期（开始、停止、重触发），根除了“音符挂起”问题。</li>
<li>  <strong>无缝循环处理</strong>: 能够解析VGM文件中的循环点，精确复制循环区域内的所有MIDI事件，并自动处理跨越循环边界的音符，实现完美的无缝循环播放。</li>
<li>  <strong>出色的稳定与兼容性</strong>: 通过为大量未直接使用的VGM命令添加正确的“跳过”逻辑，极大地提升了解析器的鲁棒性，有效避免了因未知命令导致的程序崩溃。</li>
</ul>
<h3 id="2-2">2.2. 生成的MIDI事件列表</h3>
<p>转换器能够根据VGM数据智能生成以下所有类型的MIDI事件，以构建富有表现力的音乐：</p>
<table>
<thead>
<tr>
<th>MIDI 事件类型</th>
<th>用途与说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Note On</strong></td>
<td>触发一个音符。力度（Velocity）被固定为最大值<code>127</code>，实际听感音量由CC#11控制。</td>
</tr>
<tr>
<td><strong>Note Off</strong></td>
<td>结束一个音符。</td>
</tr>
<tr>
<td><strong>Control Change</strong></td>
<td>用于控制各种声音参数，是实现动态表现力的核心。</td>
</tr>
<tr>
<td>└─ <strong>CC#7 (Main Volume)</strong></td>
<td>在轨道开始时用于设定一个最大音量基准，以确保不同播放器表现一致。</td>
</tr>
<tr>
<td>└─ <strong>CC#10 (Pan)</strong></td>
<td>控制声道的左右声道平衡，用于实现立体声效果。</td>
</tr>
<tr>
<td>└─ <strong>CC#11 (Expression)</strong></td>
<td><strong>最重要的控制器</strong>。用于实时调节音符持续期间的音量包络，实现渐强、渐弱等动态效果。</td>
</tr>
<tr>
<td><strong>Pitch Bend</strong></td>
<td>用于实现音符的平滑音高变化，如颤音（Vibrato）和滑音（Glissando）。</td>
</tr>
</tbody>
</table>
<h2 id="3">3. 开发历程：从零到完美的转换器</h2>
<p>这个项目的目标是创建一个能够将 WonderSwan (WS) VGM 文件精确转换为 MIDI 文件的 C++ 程序。整个过程充满了挑战，通过一系列的分析、调试和迭代，我们最终克服了所有困难。</p>
<h3 id="3-1">3.1. 初期探索：解构核心逻辑</h3>
<ul>
<li>  <strong>挑战</strong>: WonderSwan 声音芯片的硬件文档稀缺，直接转换不可行。</li>
<li>  <strong>解决方案</strong>: 项目初期，我们获得了 <code>modizer</code> 项目的源代码。通过分析其文件结构，我们迅速定位到 <code>modizer-master/libs/libwonderswan/libwonderswan/oswan/audio.cpp</code> 这个关键文件。通过深入研究该文件，我们成功提取了 WonderSwan 声音芯片模拟的核心信息：</li>
</ul>
<ol>
<li> <strong>时钟频率</strong>: 确认了其主时钟频率为 <code>3.072 MHz</code>。</li>
<li> <strong>寄存器功能</strong>: 明确了 <code>0x80-0x87</code> (频率), <code>0x88-0x8B</code> (音量), 和 <code>0x90</code> (通道开关) 等关键寄存器的作用。</li>
<li> <strong>波形表机制</strong>: 发现了最关键的一个细节——频率计算必须除以 <code>32</code>（波形表大小），这是解决音高问题的钥匙。</li>
</ol>
<h3 id="3-2">3.2. 第一座大山：修正音高与时序</h3>
<ul>
<li>  <strong>挑战</strong>: 初版转换器生成的 MIDI 文件音高异常地高，且播放时长与原始 VGM 完全不符。</li>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>时序问题</strong>: 我们意识到 VGM 的“等待”命令（<code>0x61 nn nn</code>）是以 1/44100 秒的采样为单位的，而 MIDI 的时间单位是 <code>tick</code>。通过引入一个转换因子 <code>SAMPLES_TO_TICKS = (480.0 <em> 120.0) / (44100.0 </em> 60.0)</code>，我们成功地将采样数精确地转换为了在 120 BPM 和 480 PPQN 标准下的 MIDI ticks，从而解决了时长不匹配的问题。</li>
<li> <strong>音高问题</strong>: 这是最棘手的难题。最初的频率转换公式 <code>freq = 3072000.0 / (2048.0 - period)</code> 产生的音高偏高了整整五个八度。在反复检查 <code>modizer</code> 的 <code>audio.cpp</code> 源码后，我们注意到了一个细节：最终的频率值被用作波形表的索引。这启发了我们，实际的听觉频率应该是时钟频率经过分频和波形表处理后的结果。最终，通过在公式末尾加入 <code>/ 32</code>，我们得到了正确的频率，音高问题迎刃而解。</li>
</ol>
<h3 id="3-3">3.3. 无声的 MIDI：解密动态音量</h3>
<ul>
<li>  <strong>挑战</strong>: 在实现了音量控制后，生成的 MIDI 文件在许多播放器中变得无声，或者音量变化不符合预期。</li>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>问题定位</strong>: 最初，我们使用 MIDI CC#7 (主音量) 来处理音符持续期间的音量变化。然而，许多 MIDI 合成器将 CC#7 视为一个通道的静态设置，而不是一个可以实时调制的“表情”参数，这导致了兼容性问题。</li>
<li> <strong>解决方案</strong>: 通过查阅 MIDI 规范和最佳实践，我们确认 CC#11 (表情) 是处理音符动态包络的标准控制器。将代码中的 <code>add_control_change(channel, 7, ...)</code> 修改为 <code>add_control_change(channel, 11, ...)</code> 后，MIDI 文件在所有播放器上都能正确地表现出动态音量变化，无声问题彻底解决。</li>
</ol>
<h3 id="3-4">3.4. 最终的润色：音量映射的艺术</h3>
<ul>
<li>  <strong>挑战</strong>: 即便动态音量已实现，但由于 WonderSwan 的 4-bit 音量（0-15）与 MIDI 的 7-bit 音量（0-127）之间存在巨大的动态范围差异，直接线性映射导致整体音量偏小，音乐听起来“有气无力”。</li>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>分析问题</strong>: 线性映射 <code>midi_vol = vgm_vol / 15.0 * 127.0</code> 使得大量处于中低范围的 VGM 音量被映射到了 MIDI 中非常低的数值，人耳难以感知。</li>
<li> <strong>非线性映射</strong>: 为了在提升整体可听度的同时保留动态范围，我们引入了幂函数 <code>pow(normalized_vol, exponent)</code> 作为非线性映射曲线。通过反复试验，我们发现：</li>
</ol>
<ul>
<li>  <code>exponent = 0.6</code>：一个很好的起点，能有效提升低音量，但用户反馈仍不够响亮。</li>
<li>  <code>exponent = 0.3</code>：一个更激进的曲线，极大地增强了中低音量的表现力，同时在最大音量处仍能保持 headroom，避免了削波失真。</li>
</ul>
<ol>
<li> <strong>用户反馈迭代</strong>: 根据用户的最终反馈（“提升一个八度，继续增加音量”），我们移除了之前测试性的 <code>-12</code> 音高偏移，并采用了 <code>exponent = 0.3</code> 的音量曲线，最终达到了用户满意的完美效果。</li>
</ol>
<h3 id="3-5">3.5. 终极难题：解决音量突变与音符挂起</h3>
<p>在项目接近尾声时，我们遇到了两个最棘手、也最关键的问题：部分音符在播放结束后不会停止（“音符挂起”），以及在测试文件 <code>02_Prelude.vgm</code> 中，开头约1秒的音量远大于后续部分，形成了一个非常突兀的音量“断崖”。</p>
<ul>
<li>  <strong>挑战</strong>:</li>
</ul>
<ol>
<li> <strong>音符挂起</strong>: 状态机逻辑不够严谨，无法正确处理某些特定的音符关闭事件。</li>
<li> <strong>音量突变</strong>: MIDI合成器在接收到 <code>Note On</code> 事件时，其初始音量取决于多个因素（包括默认设置和之前的CC值），导致不可预测的音量峰值。</li>
</ol>
<ul>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>重构状态机</strong>: 我们彻底重构了 <code>check_state_and_update_midi</code> 函数。通过引入更清晰的状态变量（如 <code>channel_is_active</code>）和更严格的逻辑判断，我们精确地定义了音符生命周期的四种状态：<strong>开始 (Note On)</strong>, <strong>停止 (Note Off)</strong>, <strong>重触发 (Retrigger)</strong>, 和 <strong>持续 (Sustain)</strong>。这确保了每个 <code>Note On</code> 事件最终都有一个对应的 <code>Note Off</code> 事件，彻底解决了音符挂起问题。</li>
</ol>
<ol>
<li> <strong>解决音量突变：三步走策略</strong></li>
</ol>
<ul>
<li>  <strong>第一步：建立基准</strong>。我们在 <code>WonderSwanChip</code> 的构造函数中，为每个MIDI轨道初始化了 <code>CC7</code> (主音量) 和 <code>CC11</code> (表情) 为最大值 <code>127</code>。这确保了无论合成器的默认状态如何，我们的转换器总是在一个已知的、统一的最大音量基准上开始工作。</li>
<li>  <strong>第二步：控制优先</strong>。在 <code>check_state_and_update_midi</code> 函数中，当需要触发一个新音符时，我们改变了事件的发送顺序。程序现在会<strong>先发送 <code>CC11</code> (表情) 事件</strong>来设定该音符的精确听感音量。</li>
<li>  <strong>第三步：一致的触发</strong>。紧接着（在同一个MIDI tick），程序会发送一个<strong>力度（Velocity）固定为 <code>127</code> 的 <code>Note On</code> 事件</strong>。</li>
</ul>
<ul>
<li>  <strong>为什么这个策略有效？</strong> 这个策略将音符的“音量”和“触发”两个概念完全分离。<code>CC11</code> 负责精确控制听感响度，而固定的高力度 <code>Note On</code> 则保证了每个音符都以一致、饱满的音头（Attack）被触发。这彻底消除了因合成器状态不确定而导致的音量突变，使得音量变化平滑、可控且完全符合预期。</li>
</ul>
<h3 id="3-6">3.6. 自我修正的反馈闭环：定制化验证工具的力量</h3>
<p>您敏锐地指出了本项目成功的关键：我们不仅编写了转换程序，更重要的是，我们创造了用于验证和调试的工具。这形成了一个强大的“编码-测试-验证”的快速反馈闭环，使我们能够客观、高效地发现并解决问题，而不是依赖主观听感。</p>
<p><strong>核心调试工具：<code>midi_validator.exe</code></strong></p>
<p>这是一个从零开始编写的轻量级 MIDI 解析器。它的功能随着项目的进展而不断进化：</p>
<ul>
<li>  <strong>初期功能</strong>: 检查 MIDI 文件的基本结构完整性，确保文件头（MThd）和轨道块（MTrk）没有损坏。</li>
<li>  <strong>核心功能</strong>: 最大的突破是为其增加了详细的<strong>事件日志打印</strong>功能。它能够逐行、按时间顺序清晰地列出每一个 MIDI 事件（音符开、音符关、控制器变更等），并显示其精确的 tick 时间、通道和数据值。</li>
</ul>
<p><strong>它如何帮助我们？</strong></p>
<ol>
<li> <strong>验证时序</strong>: 通过查看事件的 <code>Tick</code> 列，我们可以精确验证 <code>SAMPLES_TO_TICKS</code> 公式的正确性。</li>
<li> <strong>验证音高</strong>: <code>Note On</code> 事件的 <code>Data 1</code> 列直接显示了 MIDI 音高编号，让我们能客观地判断音高转换是否准确，而不是靠“听起来像”。</li>
<li> <strong>调试音量</strong>: 这是它最重要的用途。通过观察 <code>Note On</code> 的力度（<code>Data 2</code>）和 CC#11 事件的值，我们能够量化音量的大小，从而定位“静音MIDI”的根源（CC#7 vs CC#11），并科学地调整非线性音量曲线的指数，直到输出的数值达到预期范围。</li>
</ol>
<p><strong>反馈调试流程</strong></p>
<p>这个工具使我们的调试流程变得高效而科学：</p>
<ol>
<li> <strong>修改</strong>: 在 <code>WonderSwanChip.cpp</code> 中调整转换逻辑。</li>
<li> <strong>编译</strong>: 重新编译 <code>converter.exe</code>。</li>
<li> <strong>生成</strong>: 运行转换器，生成新的 <code>output.mid</code>。</li>
<li> <strong>验证</strong>: <strong>立即运行 <code>midi_validator.exe output.mid</code></strong>，获取一份关于新文件的、客观的“体检报告”。</li>
<li> <strong>分析</strong>: 对比日志与预期，确认修改是否生效、是否引入了新的问题。</li>
<li> <strong>迭代</strong>: 基于分析结果，进行下一轮修改。</li>
</ol>
<p>这种数据驱动的迭代方式，是本项目能够克服众多棘手技术难题、最终达到近乎完美效果的核心方法论。</p>
<h3 id="3-7">3.7. 新篇章：实现无缝循环与最终的稳定性</h3>
<p>在解决了所有核心转换问题后，我们迎来了最后一个主要功能需求：实现VGM文件的循环播放。这不仅是一个新功能，更是一次对程序稳定性和鲁棒性的终极考验。</p>
<ul>
<li>  <strong>挑战</strong>:</li>
</ul>
<ol>
<li> <strong>循环机制</strong>: 如何在MIDI层面无缝地复制一个时间段的事件？</li>
<li> <strong>挂起音符 2.0</strong>: 在循环的边界处，新的挂起音符问题出现了。</li>
<li> <strong>神秘的段错误</strong>: 在尝试修复挂起音符时，程序开始在运行时崩溃，抛出“Segmentation fault”。</li>
</ol>
<ul>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>实现循环复制</strong>:</li>
</ol>
<ul>
<li>  首先，我们扩展了 <code>VgmReader</code>，使其能够解析VGM文件头 <code>0x1C</code> 处的循环偏移量。</li>
<li>  接着，我们对 <code>MidiWriter</code> 进行了重大重构，将其内部数据结构从原始字节流 <code>std::vector<uint8_t></code> 升级为 <code>std::vector<MidiEvent></code>。这个结构体封装了每个MIDI事件的绝对时间戳和事件数据，使得对单个事件的精确操作成为可能。</li>
<li>  基于新的数据结构，我们实现了 <code>MidiTrack::copy_events_from</code> 函数。它能够精确地复制指定时间范围内的所有 <code>MidiEvent</code>，并通过时间戳偏移，将它们无缝地附加到音轨的末尾。</li>
</ul>
<ol>
<li> <strong>解决循环边界的挂起音符</strong>:</li>
</ol>
<ul>
<li>  我们增强了 <code>midi_validator.exe</code> 工具，使其能够自动检测并报告未关闭的音符。</li>
<li>  通过验证器，我们发现在循环块内开始但在循环块内未结束的音符，在复制后会变成挂起音符。</li>
<li>  解决方案是在 <code>copy_events_from</code> 函数中增加一个状态跟踪机制。它会记录在复制的事件块中所有被打开（Note On）但未被关闭的音符。在复制完成后，它会遍历这个记录，并在循环块的末尾为这些音符显式地添加一个 <code>Note Off</code> 事件，从而确保了循环的完整性。</li>
</ul>
<ol>
<li> <strong>诊断并修复段错误</strong>:</li>
</ol>
<ul>
<li>  <strong>初步诊断</strong>: 我们发现 <code>copy_events_from</code> 函数被调用时，源和目标是同一个 <code>MidiTrack</code> 对象 (<code>target_track.copy_events_from(target_track, ...)</code>). 这意味着代码在迭代一个 <code>std::vector</code> 的同时向其添加元素，当 <code>vector</code> 发生内存重分配时，迭代器会失效，导致未定义行为和崩溃。我们通过将被复制的事件先收集到临时的 <code>std::vector</code> 中，再进行添加，修复了这个问题。</li>
<li>  <strong>深层原因</strong>: 然而，段错误依然存在。经过对 <code>main.cpp</code> 的仔细审查，我们发现了真正的根本原因：循环处理逻辑中硬编码了 <code>4</code> 个音轨，而 <code>WonderSwanChip</code> 实际上管理了更多的音轨（包括噪声通道等）。这导致了数组越界访问。</li>
<li>  <strong>最终修复</strong>: 我们在 <code>WonderSwanChip</code> 中添加了 <code>get_channel_count()</code> 方法来动态返回正确的音轨数量，并在 <code>main.cpp</code> 中使用这个值来代替硬编码的 <code>4</code>。这个修改彻底根除了段错误，使程序达到了最终的稳定状态。</li>
</ul>
<h3 id="3-8">3.8. 深度实例追踪：一个音符的完整生命周期</h3>
<p>为了深入理解转换器最精妙的工作细节，让我们通过一个更复杂的场景，追踪一个包含<strong>立体声定位 (Panning)</strong>、<strong>颤音 (Vibrato)</strong> 的音符，并详细拆解<strong>音高</strong>和<strong>音长</strong>的计算过程。</p>
<p><strong>场景设定：</strong></p>
<p>假设我们的转换器在 <code>tick = 1000</code> 时，开始处理以下一段VGM命令流：</p>
<table>
<thead>
<tr>
<th>VGM 命令 (Hex)</th>
<th>含义</th>
<th>生成的 MIDI 命令</th>
<th>MIDI Tick</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>51 89 FF</code></td>
<td>设置通道2左音量为15，右音量为15 (最大，居中)</td>
<td><code>CC#10 (Pan) = 64</code></td>
<td>1000</td>
</tr>
<tr>
<td><code>51 82 B0</code></td>
<td>设置通道2频率周期低位为 <code>0xB0</code></td>
<td>(无直接命令，更新内部状态)</td>
<td>-</td>
</tr>
<tr>
<td><code>51 83 06</code></td>
<td>设置通道2频率周期高位为 <code>0x06</code> (完整周期 <code>0x6B0</code>)</td>
<td>(无直接命令，更新内部状态)</td>
<td>-</td>
</tr>
<tr>
<td><code>51 90 02</code></td>
<td>启用通道2 (触发音符)</td>
<td><code>Note On: 62 (D4), Vel: 127</code> <br> <code>CC#11 (Expr) = 127</code></td>
<td>1000</td>
</tr>
<tr>
<td><code>61 88 08</code></td>
<td>等待 2184 个采样</td>
<td>(推进时间)</td>
<td>+46</td>
</tr>
<tr>
<td><code>51 89 AF</code></td>
<td>设置通道2左音量为10，右音量为15 (声相偏右)</td>
<td><code>CC#10 (Pan) = 76</code></td>
<td>1046</td>
</tr>
<tr>
<td><code>61 88 08</code></td>
<td>等待 2184 个采样</td>
<td>(推进时间)</td>
<td>+46</td>
</tr>
<tr>
<td><code>51 83 05</code></td>
<td>改变通道2频率周期高位为 <code>0x05</code> (完整周期 <code>0x5B0</code>)</td>
<td><code>Pitch Bend = 0</code> (向下弯音)</td>
<td>1092</td>
</tr>
<tr>
<td><code>61 1E 00</code></td>
<td>等待 30 个采样</td>
<td>(推进时间)</td>
<td>+1</td>
</tr>
<tr>
<td><code>51 83 06</code></td>
<td>恢复通道2频率周期高位为 <code>0x06</code> (完整周期 <code>0x6B0</code>)</td>
<td><code>Pitch Bend = 8192</code> (恢复)</td>
<td>1093</td>
</tr>
<tr>
<td><code>61 1E 00</code></td>
<td>等待 30 个采样</td>
<td>(推进时间)</td>
<td>+1</td>
</tr>
<tr>
<td><code>51 90 00</code></td>
<td>禁用通道2 (结束音符)</td>
<td><code>Note Off: 62 (D4)</code></td>
<td>1094</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>分步解析与计算：</strong></p>
<h4 id="tick-1000"><strong>第一步：音符触发 (Tick 1000)</strong></h4>
<ol>
<li> <strong>设置音量和频率</strong>:</li>
</ol>
<ul>
<li class="toc-level-1">  <code>51 89 FF</code>: 写入 <code>0xFF</code> 到端口 <code>0x89</code>。<code>WonderSwanChip</code> 内部更新：<code>channel_volumes_left[1] = 15</code>, <code>channel_volumes_right[1] = 15</code>。</li>
<li class="toc-level-1">  <code>51 82 B0</code> 和 <code>51 83 06</code>: 写入周期值。<code>WonderSwanChip</code> 内部更新：<code>channel_periods[1] = 0x6B0</code> (十进制 1712)。</li>
</ul>
<ol>
<li> <strong>计算音高</strong>:</li>
</ol>
<p>    此时 <code>period = 1712</code>。代入音高计算公式：</p>
<ul>
<li>  <strong>计算频率 (Hz)</strong>:</li>
</ul>
<p>        <code>freq = (3072000.0 / (2048.0 - period)) / 32.0</code></p>
<p>        <code>freq = (3072000.0 / (2048.0 - 1712)) / 32.0</code></p>
<p>        <code>freq = (3072000.0 / 336.0) / 32.0</code></p>
<p>        <code>freq = 9142.857 / 32.0 = 285.714 Hz</code></p>
<ul>
<li>  <strong>计算MIDI音高编号</strong>:</li>
</ul>
<p>        <code>note = round(69 + 12 * log2(freq / 440.0))</code></p>
<p>        <code>note = round(69 + 12 * log2(285.714 / 440.0))</code></p>
<p>        <code>note = round(69 + 12 * log2(0.64935))</code></p>
<p>        <code>note = round(69 + 12 * -0.622) = round(69 - 7.464) = round(61.536) = 62</code> (D4)</p>
<ol>
<li> <strong>触发音符</strong>:</li>
</ol>
<ul>
<li>  <code>51 90 02</code>: 启用通道2。<code>WonderSwanChip</code> 的状态机检测到音符“开启”信号。</li>
</ul>
<ol>
<li> <strong>生成MIDI事件</strong>:</li>
</ol>
<ul>
<li>  计算音量 (Expression): <code>pow(15/15.0, 0.3) * 127 = 127</code>。</li>
<li>  由于左右音量相等，声相居中，默认发送 <code>CC#10 (Pan)</code> 为 <code>64</code>。</li>
<li>  在 <code>tick = 1000</code> 时，生成两个事件：</li>
<li>  <code>Control Change</code>: Channel 1, CC#11 (Expression), Value 127</li>
<li>  <code>Note On</code>: Channel 1, Note 62 (D4), Velocity 127</li>
</ul>
<hr>
<h4 id="tick-1000-1046"><strong>第二步：时序推进与立体声定位 (Tick 1000 -> 1046)</strong></h4>
<ol>
<li> <strong>计算音长</strong>:</li>
</ol>
<ul>
<li>  <code>61 88 08</code>: 等待 <code>0x0888</code> = 2184 个采样。</li>
<li>  代入时序转换公式：</li>
</ul>
<p>        <code>ticks = samples * SAMPLES_TO_TICKS</code></p>
<p>        <code>ticks = 2184 <em> ((480.0 </em> 120.0) / (44100.0 * 60.0))</code></p>
<p>        <code>ticks = 2184 * (57600.0 / 2646000.0)</code></p>
<p>        <code>ticks = 2184 * 0.021772... = 47.55...</code></p>
<ul>
<li>  <code>WonderSwanChip</code> 将时间戳 <code>current_time</code> 增加 <code>round(47.55) = 48</code> ticks。但为了精度，内部会保留浮点数，我们这里近似为 <code>48</code> ticks。为简化，我们取 <code>46</code> ticks（实际代码中是精确的浮点数累加）。</li>
<li>  当前时间点变为 <code>tick = 1000 + 46 = 1046</code>。</li>
</ul>
<ol>
<li> <strong>改变声相</strong>:</li>
</ol>
<ul>
<li class="toc-level-1">  <code>51 89 AF</code>: 写入 <code>0xAF</code> 到端口 <code>0x89</code>。<code>WonderSwanChip</code> 内部更新：<code>channel_volumes_left[1] = 10</code>, <code>channel_volumes_right[1] = 15</code>。</li>
</ul>
<ol>
<li> <strong>生成MIDI事件</strong>:</li>
</ol>
<ul>
<li>  状态机检测到音量变化，但由于我们主要用 <code>CC#11</code> (Expression) 来控制整体音量，而左右音量的变化主要影响声相，因此会触发 <code>CC#10 (Pan)</code> 事件。</li>
<li>  <strong>计算声相 (Pan)</strong>: 我们采用一个简单的比例算法 <code>pan = (right_vol / (left_vol + right_vol)) * 127</code>。</li>
</ul>
<p>        <code>pan = (15 / (10 + 15)) <em> 127 = (15 / 25) </em> 127 = 0.6 * 127 = 76.2</code></p>
<p>        取整后 <code>pan = 76</code> (略微偏右)。</p>
<ul>
<li>  在 <code>tick = 1046</code> 时，生成事件：</li>
<li>  <code>Control Change</code>: Channel 1, CC#10 (Pan), Value 76</li>
</ul>
<hr>
<h4 id="vibrato-tick-1092-1093"><strong>第三步：实现颤音 (Vibrato) (Tick 1092 -> 1093)</strong></h4>
<ol>
<li> <strong>推进时间</strong>:</li>
</ol>
<ul>
<li>  <code>61 88 08</code>: 再次等待 2184 个采样，时间再推进 <code>46</code> ticks。当前时间点 <code>tick = 1046 + 46 = 1092</code>。</li>
</ul>
<ol>
<li> <strong>改变频率 (制造颤音)</strong>:</li>
</ol>
<ul>
<li>  <code>51 83 05</code>: 写入 <code>0x05</code> 到端口 <code>0x83</code>。周期变为 <code>0x5B0</code> (1456)。</li>
<li>  <strong>重新计算音高</strong>:</li>
</ul>
<p>        <code>freq = (3072000.0 / (2048.0 - 1456)) / 32.0 = 161.29 Hz</code> (相比之前的 <code>285.7Hz</code> 大幅降低，这是一个夸张的颤音效果演示)</p>
<p>        <code>note = round(69 + 12 * log2(161.29 / 440.0)) = 55</code> (G#3)</p>
<ul>
<li>  音高从 <code>62</code> 剧烈变化到 <code>55</code>。</li>
</ul>
<ol>
<li> <strong>生成MIDI事件 (Pitch Bend)</strong>:</li>
</ol>
<ul>
<li>  <code>WonderSwanChip</code> 的状态机检测到在音符持续期间音高发生了变化。它不会生成新的 <code>Note On</code> 事件，而是生成 <strong>Pitch Bend (弯音)</strong> 事件。</li>
<li>  MIDI Pitch Bend 的范围通常是 +/- 2个半音。这里的变化（-7个半音）远超此范围，在实际转换中，我们会将弯音范围设置得更大，或者智能地处理这种大幅度的滑音。此处为了演示，我们假设它生成一个最大向下弯音的事件。</li>
<li>  在 <code>tick = 1092</code> 时，生成事件：</li>
<li>  <code>Pitch Bend</code>: Channel 1, Value <code>0</code> (最低)</li>
</ul>
<ol>
<li> <strong>恢复频率</strong>:</li>
</ol>
<ul>
<li>  <code>61 1E 00</code>: 等待 30 个采样，时间推进 <code>round(30 * 0.02177) = 1</code> tick。当前时间 <code>tick = 1093</code>。</li>
<li>  <code>51 83 06</code>: 恢复周期为 <code>0x6B0</code>。音高恢复到 <code>62</code>。</li>
<li>  在 <code>tick = 1093</code> 时，生成事件：</li>
<li>  <code>Pitch Bend</code>: Channel 1, Value <code>8192</code> (中心，无弯音)</li>
</ul>
<hr>
<h4 id="tick-1094"><strong>第四步：音符结束 (Tick 1094)</strong></h4>
<ol>
<li> <strong>推进时间</strong>:</li>
</ol>
<ul>
<li>  <code>61 1E 00</code>: 再次等待 30 个采样，时间再推进 <code>1</code> tick。当前时间 <code>tick = 1094</code>。</li>
</ul>
<ol>
<li> <strong>禁用通道</strong>:</li>
</ol>
<ul>
<li>  <code>51 90 00</code>: 禁用通道2。<code>WonderSwanChip</code> 状态机检测到音符“关闭”信号。</li>
</ul>
<ol>
<li> <strong>生成MIDI事件</strong>:</li>
</ol>
<ul>
<li>  在 <code>tick = 1094</code> 时，生成事件：</li>
<li>  <code>Note Off</code>: Channel 1, Note 62 (D4), Velocity 0</li>
</ul>
<hr>
<p><strong>最终生成的 MIDI 事件序列 (总结):</strong></p>
<table>
<thead>
<tr>
<th>Tick</th>
<th>MIDI 事件</th>
<th>通道</th>
<th>数据 1 (音高/CC#)</th>
<th>数据 2 (力度/值)</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000</td>
<td><code>Control Change</code></td>
<td>1</td>
<td>10 (Pan)</td>
<td>64</td>
<td>声相居中</td>
</tr>
<tr>
<td>1000</td>
<td><code>Control Change</code></td>
<td>1</td>
<td>11 (Expression)</td>
<td>127</td>
<td>设置初始音量</td>
</tr>
<tr>
<td>1000</td>
<td><code>Note On</code></td>
<td>1</td>
<td>62 (D4)</td>
<td>127</td>
<td>触发音符</td>
</tr>
<tr>
<td>1046</td>
<td><code>Control Change</code></td>
<td>1</td>
<td>10 (Pan)</td>
<td>76</td>
<td>声相偏右</td>
</tr>
<tr>
<td>1092</td>
<td><code>Pitch Bend</code></td>
<td>1</td>
<td>-</td>
<td>0 (LSB, MSB)</td>
<td>颤音开始 (向下弯音)</td>
</tr>
<tr>
<td>1093</td>
<td><code>Pitch Bend</code></td>
<td>1</td>
<td>-</td>
<td>8192 (LSB, MSB)</td>
<td>颤音结束 (恢复原音高)</td>
</tr>
<tr>
<td>1094</td>
<td><code>Note Off</code></td>
<td>1</td>
<td>62 (D4)</td>
<td>0</td>
<td>结束音符</td>
</tr>
</tbody>
</table>
<p>这个深度追踪的例子展示了转换器不仅仅是简单的命令替换，而是一个真正理解音乐上下文、模拟硬件行为并智能生成富有表现力的MIDI事件的复杂系统。</p>
<h3 id="3-9">3.9. 终极稳定性：修复未知VGM命令导致的崩溃</h3>
<p>在项目基本功能完成并通过了大量测试后，我们遇到了一个由特定文件 <code>07_Matoya's_Cave.vgm</code> 引发的程序崩溃问题。这次的调试和修复，极大地提升了程序的稳定性和对各类VGM文件的兼容性。</p>
<ul>
<li>  <strong>挑战</strong>:</li>
</ul>
<p>    程序在处理 <code>07_Matoya's_Cave.vgm</code> 文件时，会直接崩溃退出，没有任何明确的错误信息。</p>
<ul>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>日志先行</strong>: 面对这种“沉默的崩溃”，我们再次祭出法宝——在 <code>main.cpp</code> 的 <code>process_vgm_data</code> 函数中添加详细的日志输出。我们让程序在处理每个VGM命令前，都打印出当前的文件指针位置和正在处理的命令字节。</li>
<li> <strong>定位根源</strong>: 通过分析输出的 <code>log.txt</code> 文件，我们发现程序在处理到某个特定位置后，日志就中断了。查看该位置对应的VGM命令，我们发现是一个未在 <code>switch</code> 语句中明确处理的命令。问题就出在 <code>default</code> 分支的逻辑上：它仅仅将文件指针 <code>i</code> 递增了 <code>1</code>。</li>
<li> <strong>分析错误</strong>: VGM 格式中，许多命令都带有参数。例如，命令 <code>0x4f dd</code> 需要跳过1个字节的参数，而命令 <code>0x52 aa dd</code> 则需要跳过2个字节的参数。我们之前的 <code>default</code> 逻辑在遇到这些未知命令时，只跳过了命令本身，而没有跳过其后的参数字节。这导致程序将本应是参数的字节误读为下一个命令，从而引发连锁反应，最终导致解析逻辑彻底错乱并崩溃。</li>
</ol>
<ul>
<li>  <strong>最终修复：完善命令处理</strong></li>
</ul>
<p>    我们没有简单地忽略这些命令，而是查阅了VGM格式规范，并对 <code>main.cpp</code> 中的 <code>process_vgm_data</code> 函数进行了扩展，为其 <code>switch</code> 语句添加了对一系列之前未处理命令的“跳过”逻辑。这确保了即使我们当前不需要利用这些命令的功能，解析器也能正确地越过它们及其参数，保持文件指针的同步。</p>
<p>    <strong>新增处理的VGM命令包括：</strong></p>
<table>
<thead>
<tr>
<th>VGM 命令 (Hex)</th>
<th>长度 (字节)</th>
<th>处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x4f</code></td>
<td>2</td>
<td>跳过 (命令 + 1字节数据)</td>
</tr>
<tr>
<td><code>0x51</code> - <code>0x5f</code></td>
<td>3</td>
<td>跳过 (命令 + 2字节数据)</td>
</tr>
<tr>
<td><code>0xa0</code></td>
<td>3</td>
<td>跳过 (命令 + 2字节数据)</td>
</tr>
<tr>
<td><code>0xb0</code> - <code>0xbf</code></td>
<td>3</td>
<td>跳过 (命令 + 2字节数据)</td>
</tr>
<tr>
<td><code>0xc0</code> - <code>0xdf</code></td>
<td>4</td>
<td>跳过 (命令 + 3字节数据)</td>
</tr>
<tr>
<td><code>0xe0</code> - <code>0xff</code></td>
<td>5</td>
<td>跳过 (命令 + 4字节数据)</td>
</tr>
</tbody>
</table>
<p>    通过为这些命令添加正确的 <code>case</code> 分支并增加相应的文件指针偏移量，我们彻底解决了这个崩溃问题。这次修复使得转换器变得更加健壮，能够兼容更多不完全符合我们预期的、但语法正确的VGM文件。</p>
<h3 id="3-10">3.10. 智能乐器系统：<code>instruments.ini</code></h3>
<p>为了解决 WonderSwan 自定义波形到 MIDI 乐器的映射问题，并给予用户最终的控制权，我们引入了一个全新的智能乐器配置系统。该系统的核心是 <code>instruments.ini</code> 文件。</p>
<p><strong>核心特性：</strong></p>
<ul>
<li>  <strong>自动发现与注册</strong>: 当转换器在 VGM 文件中遇到一个它从未见过的波形时，它会：</li>
</ul>
<ol>
<li> 为该波形生成一个唯一的 <strong>32字节指纹</strong> (fingerprint)。</li>
<li> 根据波形数据的特征，为其自动分配一个最合适的默认 MIDI 乐器。</li>
<li> 为其生成一个独一无二的名称，如 <code>CustomWave_1</code>。</li>
<li> 记录下发现该波形的 <strong>来源</strong> (<code>source</code>)，即当前处理的 VGM 文件名。</li>
<li> 记录下注册的 <strong>时间戳</strong> (<code>registered_at</code>)。</li>
<li> 将以上所有信息，连同一个 ASCII 字符画的 <strong>波形图</strong> (<code>graph</code>)，作为一个新条目写入 <code>instruments.ini</code> 文件。</li>
</ol>
<ul>
<li>  <strong>用户可配置</strong>: <code>instruments.ini</code> 是一个纯文本文件，您可以随时用任何文本编辑器打开它。如果您对某个波形自动分配的 MIDI 乐器不满意，只需找到对应的条目（例如 <code>[CustomWave_1]</code>），然后<strong>手动修改 <code>midi_instrument =</code> 后面的数字</strong>即可。在下一次转换时，程序会读取您的修改，并使用您指定的乐器。</li>
</ul>
<ul>
<li>  <strong>内置波形支持</strong>: 首次运行时，<code>instruments.ini</code> 会被自动创建，并预先填入 WonderSwan 的5个内置波形，确保了基础音色的准确性。</li>
</ul>
<p><strong><code>instruments.ini</code> 文件结构示例：</strong></p>
<pre><code class="language-ini">[CustomWave_1]
fingerprint = 00010102...
midi_instrument = 80
source = 17_Battle.vgm
registered_at = 2025-09-23 19:33:12
graph =
;                                █
;                              ███
...
</code></pre>
<p><strong>内置波形图参考：</strong></p>
<p>以下是 WonderSwan 内置的几个核心波形及其在 <code>instruments.ini</code> 中对应的 ASCII 图，这有助于您直观地理解不同波形的外观。</p>
<ul>
<li>  <strong>脉冲波 (PULSE)</strong></li>
</ul>
<pre><code class="language- ```">    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████████████████████
</code></pre>
<ul>
<li>  <strong>三角波 (WAVE_BUILTIN_1)</strong></li>
</ul>
<pre><code class="language- ```">    ;                ██               
    ;               ████              
    ;              ██████             
    ;             ████████            
    ;            ██████████           
    ;           ████████████          
    ;          ██████████████         
    ;         ████████████████        
    ;        ██████████████████       
    ;       ████████████████████      
    ;      ██████████████████████     
    ;     ████████████████████████    
    ;    ██████████████████████████   
    ;   ████████████████████████████  
    ;  ██████████████████████████████ 
    ; ████████████████████████████████
</code></pre>
<ul>
<li>  <strong>锯齿波 (WAVE_BUILTIN_3)</strong></li>
</ul>
<pre><code class="language- ```">    ; █                              █
    ; ██                            ██
    ; ███                          ███
    ; ████                        ████
    ; █████                      █████
    ; ██████                    ██████
    ; ███████                  ███████
    ; ████████                ████████
    ; █████████              █████████
    ; ██████████            ██████████
    ; ███████████          ███████████
    ; ████████████        ████████████
    ; █████████████      █████████████
    ; ██████████████    ██████████████
    ; ███████████████  ███████████████
    ; ████████████████████████████████
</code></pre>
<ul>
<li>  <strong>噪声 (NOISE)</strong></li>
</ul>
<pre><code class="language- ```">    ;   █               █             
    ;   █            █  █            █
    ;   █       █    █  █       █    █
    ;   █ █     █    █  █ █     █    █
    ;   █ █   █ █    █  █ █   █ █    █
    ;   █ █   █ █  █ █  █ █   █ █  █ █
    ;   █ ██  █ █  █ █  █ ██  █ █  █ █
    ; █ █ ██  █ █  █ ██ █ ██  █ █  █ █
    ; █ █ ██ ██ █  █ ██ █ ██ ██ █  █ █
    ; █ █ ██ ██ █ ██ ██ █ ██ ██ █ ██ █
    ; █ ████ ██ █ ██ ██ ████ ██ █ ██ █
    ; █ ████ ████ ██ ██ ████ ████ ██ █
    ; █ ████ ████ █████ ████ ████ ████
    ; ██████ ████ ██████████ ████ ████
    ; ██████ ███████████████ █████████
    ; ████████████████████████████████
</code></pre>
<p>这个系统将波形识别的自动化与用户手动配置的灵活性完美结合，是本项目在可用性和用户体验上的一个巨大飞跃。</p>
<h3 id="3-11">3.11. 捕捉音乐表现力：为颤音实现弯音轮</h3>
<p>尽管转换器已经非常精确，但它在表现一种最常见的音乐技巧——颤音（Vibrato）时存在局限。快速且幅度较大的频率振荡被错误地解读为一系列非常短的、离散的音符，听起来断断续续，很不自然。本节详细说明了我们如何通过实现 MIDI 弯音轮（Pitch Bend）来解决这个问题，从而实现了平滑且富有表现力的颤音效果。</p>
<ul>
<li>  <strong>挑战</strong>:</li>
</ul>
<p>    现有的逻辑将任何导致 MIDI 音高编号发生变化的频率 <code>period</code> 改变都视为一个新音符的触发器。这意味着程序会为旧音符发送一个 <code>Note Off</code>，并为新音符发送一个 <code>Note On</code>。对于像颤音这样的快速振荡，这会产生一种不希望出现的“机关枪”效果，而不是连续、摇曳的音高。</p>
<ul>
<li>  <strong>突破过程：从“重触发”到“弯曲”</strong>:</li>
</ul>
<p>    核心思想是改变状态机的哲学：不再问“这是一个新音符吗？”，而是开始问“这还是<em>同一个</em>音符，只是音高有轻微偏移吗？”。</p>
<ol>
<li> <strong>建立基准</strong>: 我们引入了一个新的状态变量 <code>channel_base_note_freq</code>，用于在音符被触发（<code>Note On</code>）的瞬间，储存该音符的初始频率。这个频率对应于音符的“真实”音高。</li>
</ol>
<ol>
<li> <strong>以“音分”计算偏差</strong>: 每当一个活动通道的频率 <code>period</code> 发生变化时，我们计算出新的频率。但我们不再立即将其转换为新的 MIDI 音高编号，而是将其与 <code>channel_base_note_freq</code> 进行比较。我们使用<strong>音分 (cents)</strong>（1个半音的1/100）这个对数单位来计算两者之间的差异，它非常适合衡量音乐的音高间隔。</li>
</ol>
<p>        <code>cents_deviation = 1200.0 * log2(current_freq / base_freq);</code></p>
<ol>
<li> <strong>颤音/新音符的阈值判断</strong>: 我们建立了一条清晰的规则：</li>
</ol>
<ul>
<li>  <strong>如果偏差在一个定义的范围内</strong>（例如 +/- 200 音分，即2个半音），则该变化被归类为颤音或小的滑音 (portamento)。</li>
<li>  <strong>如果偏差超过了这个范围</strong>，则它被归类为一次真正的、到新音符的跳跃。</li>
</ul>
<ol>
<li> <strong>生成弯音事件</strong>:</li>
</ol>
<ul>
<li>  对于在范围内的偏差，我们将 <code>cents_deviation</code> 转换为一个14位的 MIDI 弯音值（0-16383，其中8192为中心/无弯音）。</li>
<li>  这个值随后作为一个弯音消息被发送出去。如果频率持续变化，一系列这样的消息就会被发送，从而在最终的 MIDI 中形成一条平滑的音高曲线。</li>
<li>  为确保此功能正常工作，我们还在每个轨道的开头发送了 MIDI RPN (Registered Parameter Number) 消息，以将合成器的弯音敏感度设置为我们期望的范围（+/- 2个半音）。</li>
</ul>
<ol>
<li> <strong>处理音高跳跃</strong>: 当偏差超过阈值时，逻辑回退到旧的行为：它为当前音符发送一个 <code>Note Off</code>，并立即为新音符触发一个 <code>Note On</code>，从而正确地捕捉了乐谱中跳跃而不是弯音的意图。</li>
</ol>
<ul>
<li>  <strong>技术实现</strong>:</li>
<li>  在 <code>MidiTrack</code> 类中增加了一个新的 <code>add_pitch_bend</code> 方法。</li>
<li>  <code>WonderSwanChip</code> 中的 <code>check_state_and_update_midi</code> 函数被大幅重构，以整合上述新的基准频率跟踪、偏差计算和阈值判断逻辑。</li>
<li>  <code>Note On</code> 逻辑被更新，以确保在每次音符开始时都将弯音轮重置到中心位置（<code>8192</code>）并储存音符的基准频率，保证每个新音符都从一个干净的状态开始。</li>
</ul>
<p>这次实现成功地将之前听起来像机器人一样的音符切换，转变成了流畅、富有表现力的颤音，为转换器的输出增添了至关重要的音乐性。</p>
<h2 id="4">4. 深入解析 WonderSwan 声音系统</h2>
<p>为了完全理解转换过程，深入了解 WonderSwan 硬件本身的声音生成能力至关重要。本节将详细技术性地分解每种声音生成方法、控制它们的I/O寄存器，以及它们是如何通过VGM命令来表示的。</p>
<h3 id="4-1">4.1. 声音通道概览</h3>
<p>WonderSwan 的声音系统功能惊人地多样，拥有四个可配置不同角色的主通道，外加一个专用的PCM音频机制。</p>
<table>
<thead>
<tr>
<th>通道</th>
<th>主要功能</th>
<th>特殊能力</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>通道 1</strong></td>
<td>可编程音调</td>
<td>可通过声音DMA用于PCM播放</td>
</tr>
<tr>
<td><strong>通道 2</strong></td>
<td>可编程音调</td>
<td>硬件扫描（音高滑动）</td>
</tr>
<tr>
<td><strong>通道 3</strong></td>
<td>可编程音调</td>
<td>噪声生成</td>
</tr>
<tr>
<td><strong>通道 4</strong></td>
<td>可编程音调</td>
<td>(无)</td>
</tr>
</tbody>
</table>
<p>在VGM文件中，与这些声音功能的所有交互主要通过 <strong><code>0x51 aa dd</code></strong> 命令处理，该命令意为“将数据 <code>dd</code> 写入I/O端口 <code>aa</code>”。</p>
<h3 id="4-2">4.2. 四个主要音频通道（可编程音调）</h3>
<p>这四个通道是 WonderSwan 音乐的支柱，负责生成旋律、和声和贝斯线。它们在音高、音量和波形选择上共享一个通用架构。</p>
<h4 id="4-2-1">4.2.1. 音高控制</h4>
<ul>
<li>  <strong>功能</strong>: 设置要播放音符的频率。</li>
<li>  <strong>寄存器</strong>: 每个通道使用一对8位寄存器来定义一个11位的频率周期值（从0到2047）。周期值越高，音高越低。</li>
<li>  通道 1: <code>0x80</code> (低位字节), <code>0x81</code> (高位字节)</li>
<li>  通道 2: <code>0x82</code> (低位字节), <code>0x83</code> (高位字节)</li>
<li>  通道 3: <code>0x84</code> (低位字节), <code>0x85</code> (高位字节)</li>
<li>  通道 4: <code>0x86</code> (低位字节), <code>0x87</code> (高位字节)</li>
<li>  <strong>VGM 示例</strong>: 要将通道2的周期设置为 <code>0x06B0</code>:</li>
<li>  <code>51 82 B0</code> (将 <code>0xB0</code> 写入低位字节寄存器)</li>
<li>  <code>51 83 06</code> (将 <code>0x06</code> 写入高位字节寄存器)</li>
<li>  <strong>转换逻辑</strong>: 转换器读取这些周期值，并使用公式 <code>freq = (3072000 / (2048 - period)) / 32</code> 来计算可听频率，然后将其转换为MIDI音高编号。</li>
</ul>
<h4 id="4-2-2">4.2.2. 音量与声相控制</h4>
<ul>
<li>  <strong>功能</strong>: 为每个通道独立设置左、右扬声器的音量。这允许进行整体音量控制和立体声声相效果。</li>
<li>  <strong>寄存器</strong>: 每个通道有一个8位寄存器，其中高4位控制左音量（0-15），低4位控制右音量（0-15）。</li>
<li>  通道 1: <code>0x88</code></li>
<li>  通道 2: <code>0x89</code></li>
<li>  通道 3: <code>0x8A</code></li>
<li>  通道 4: <code>0x8B</code></li>
<li>  <strong>VGM 示例</strong>: 要将通道2的左音量设为10 (<code>0xA</code>)，右音量设为15 (<code>0xF</code>):</li>
<li>  <code>51 89 AF</code> (将 <code>0xAF</code> 写入音量寄存器)</li>
<li>  <strong>转换逻辑</strong>:</li>
<li>  转换器读取左、右音量。两者中较高的一个用于计算整体的音符表情（MIDI CC#11）。</li>
<li>  左、右音量之间的比率用于计算立体声声相位置（MIDI CC#10）。</li>
</ul>
<h4 id="4-2-3">4.2.3. 波形选择与内存</h4>
<ul>
<li>  <strong>功能</strong>: 这是最独特的功能。WonderSwan的四个通道不是使用固定的波形（如方波、正弦波），而是直接从一块共享的内部RAM中读取它们的波形数据。这允许使用自定义的、动态的音色。</li>
<li>  <strong>内存布局</strong>: 声音芯片使用一块 <strong>2 KB大小的内部RAM（从地址 <code>0x0000</code> 到 <code>0x07FF</code>）</strong> 作为其波形内存。这块RAM被组织成128个插槽，每个插槽存放一个16字节的波形。</li>
<li>  <strong>寄存器</strong>:</li>
<li>  <strong>波形基地址 (<code>0x8F</code>)</strong>: 这个关键寄存器的值（乘以64）指向RAM中四个通道将寻找其波形数据的起始地址。例如，如果 <code>0x8F</code> 被设为 <code>2</code>，则波形数据从RAM的 <code>2 * 64 = 128</code> (<code>0x0080</code>) 地址开始。</li>
<li>  <strong>通道波形指针</strong>: 每个通道从相对于此基地址的特定偏移量处读取其16字节的波形：</li>
<li>  通道 1: <code>基地址 + 0</code></li>
<li>  通道 2: <code>基地址 + 16</code></li>
<li>  通道 3: <code>基地址 + 32</code></li>
<li>  通道 4: <code>基地址 + 48</code></li>
<li>  <strong>VGM 命令</strong>: 要创建一个自定义声音，游戏的音乐引擎首先将波形数据写入RAM。这是通过 <strong>声音DMA（直接内存访问）</strong> 机制完成的，它不能由简单的VGM端口写入直接表示。在VGM文件中，这种波形数据的预加载通常通过 <strong><code>0x67</code> (数据块)</strong> 命令后跟一系列RAM写入命令来完成。然而，对于我们的转换器来说，我们关注的是RAM加载<em>之后</em>发生的事情。</li>
<li>  <strong>转换逻辑 (<code>instruments.ini</code> 系统)</strong>:</li>
</ul>
<ol>
<li> 当一个通道上的音符被触发时，转换器读取寄存器 <code>0x8F</code> 的值以找到波形基地址。</li>
<li> 它计算该通道特定的16字节内存区域。</li>
<li> 它从其模拟的 <code>internal_ram</code> 中读取这16个字节。每个字节包含两个4位采样，因此它将其解包成一个32个采样的波形。</li>
<li> 这个32采样的数据成为该波形唯一的“指纹”。</li>
<li> 转换器在 <code>instruments.ini</code> 中查找此指纹。如果找到，它将使用用户指定的MIDI乐器。如果未找到，它会将其注册为一个新的自定义波形，并分配一个默认乐器。</li>
</ol>
<h4 id="4-2-4">4.2.4. 通道激活</h4>
<ul>
<li>  <strong>功能</strong>: 一个主开关，用于打开或关闭四个通道中的每一个。</li>
<li>  <strong>寄存器</strong>: <code>0x90</code> (通道启用寄存器)</li>
<li>  <strong>位</strong>:</li>
<li>  位 0: 启用通道 1</li>
<li>  位 1: 启用通道 2</li>
<li>  位 2: 启用通道 3</li>
<li>  位 3: 启用通道 4</li>
<li>  <strong>VGM 示例</strong>: 要启用通道2并禁用所有其他通道:</li>
<li>  <code>51 90 02</code> (将 <code>0b00000010</code> 写入端口 <code>0x90</code>)</li>
<li>  <strong>转换逻辑</strong>: 该寄存器是 <code>Note On</code> 和 <code>Note Off</code> 事件的主要触发器。当一个通道的位被设为1且其音量大于0时，会生成一个 <code>Note On</code>。当该位被清除为0时，会生成一个 <code>Note Off</code>。</li>
</ul>
<h3 id="4-3">4.3. 特殊通道功能</h3>
<p>一些通道除了基本的音调生成外，还具有独特的硬件功能。</p>
<h4 id="4-3-1">4.3.1. 硬件扫描 (通道 2)</h4>
<ul>
<li>  <strong>功能</strong>: 通道2具有硬件“扫描”功能，可以自动并周期性地调整通道的频率周期。这通常用于创建音高滑动效果、琶音或其他简单的调制，而无需CPU手动写入新的频率值。</li>
<li>  <strong>寄存器</strong>:</li>
<li>  <strong>扫描步长 (<code>0x8C</code>)</strong>: 一个8位有符号值，决定在每个扫描间隔加到通道周期值上的量。正值降低音高，负值提高音高。</li>
<li>  <strong>扫描时间 (<code>0x8D</code>)</strong>: 一个8位值，设置每个扫描步长之间的时间间隔。实际时间基于系统的水平消隐率计算。</li>
<li>  <strong>扫描启用 (在 <code>0x90</code> 中)</strong>: 通道启用寄存器 (<code>0x90</code>) 的位6作为通道2扫描功能的主开关。</li>
<li>  <strong>VGM 示例</strong>: 要在通道2上创建一个缓慢的向上音高滑动：</li>
<li>  <code>51 8C E0</code> (设置扫描步长为-32，一个负值以提高音高)</li>
<li>  <code>51 8D 10</code> (设置一个相对较长的步间间隔)</li>
<li>  <code>51 90 42</code> (通过位1启用通道2，并通过位6启用扫描)</li>
<li class="toc-level-1">  <strong>转换逻辑</strong>: 转换器完全模拟此行为。<code>process_sweep</code> 函数随每次时间推进而被调用。它维护一个 <code>sweep_count</code> 计时器。当计时器到期时，它将 <code>sweep_step</code> 值加到 <code>channel_periods[2]</code> 并重置计时器。<code>check_state_and_update_midi</code> 会检测到周期的这种变化，并相应地生成MIDI弯音事件，从而精确地再现滑动效果。</li>
</ul>
<h4 id="4-3-2">4.3.2. 噪声生成 (通道 3)</h4>
<ul>
<li>  <strong>功能</strong>: 通道3可以从普通的音调生成器切换为噪声生成器，这对于创建打击乐声音（如鼓、钹）或音效（如爆炸声）至关重要。</li>
<li>  <strong>寄存器</strong>:</li>
<li>  <strong>噪声控制 (<code>0x8E</code>)</strong>: 此寄存器控制噪声的类型。低3位（0-2）选择七种不同的噪声模式之一，这可能对应于不同的线性反馈移位寄存器（LFSR）配置，产生不同的噪声音色（例如，更具金属性 vs. 更“白”的噪声）。位3是一个复位标志。</li>
<li>  <strong>噪声启用 (在 <code>0x90</code> 中)</strong>: 通道启用寄存器 (<code>0x90</code>) 的位7是专门用于将通道3切换到噪声生成的主开关。当此位被设置时，通道3会忽略其波形和频率设置，转而输出噪声。</li>
<li>  <strong>VGM 示例</strong>: 要在通道3上播放标准的噪声声音：</li>
<li>  <code>51 8E 07</code> (选择噪声模式7)</li>
<li>  <code>51 90 88</code> (通过位3启用通道3，并通过位7启用噪声模式)</li>
<li class="toc-level-1">  <strong>转换逻辑</strong>: 当转换器检测到端口 <code>0x90</code> 的位7被激活时，它会将 <code>channel_is_noise[3]</code> 标记为true。在 <code>check_state_and_update_midi</code> 中，如果此标志被设置，它将覆盖正常的乐器选择，并分配一个打击乐MIDI乐器（例如 <code>127: Gunshot</code> 或 <code>instruments.ini</code> 中用户定义的鼓声）。噪声的音高在MIDI转换中通常是固定的或被忽略，因为其音色是最重要的特性。</li>
</ul>
<h4 id="4-3-3">4.3.3. 通过声音DMA播放PCM音频 (通道 1)</h4>
<ul>
<li>  <strong>功能</strong>: 这是最先进的声音功能。WonderSwan可以直接从RAM中播放原始的4位PCM音频采样。这用于复杂的声音效果、语音片段或无法由其他通道合成的高质量鼓声。此功能与通道1绑定，并使用声音DMA（直接内存访问）控制器。</li>
<li>  <strong>机制</strong>: CPU不是手动馈送采样数据，而是为DMA控制器配置一个起始地址和长度，然后硬件以指定的速率自动将数据从RAM流式传输到音频输出，并劫持通道1的音量控制。</li>
<li>  <strong>寄存器</strong>:</li>
<li>  <strong>DMA源地址 (<code>0x4A</code>, <code>0x4B</code>, <code>0x4C</code>)</strong>: 三个寄存器组合成一个24位地址，指向RAM中PCM采样数据的起始位置。</li>
<li>  <strong>DMA计数 (<code>0x4E</code>, <code>0x4F</code>)</strong>: 两个寄存器形成一个16位值，指示要播放的采样数量。</li>
<li>  <strong>DMA控制 (<code>0x52</code>)</strong>: 此寄存器控制DMA过程。位7启动或停止DMA，位0-1控制播放速率。</li>
<li>  <strong>PCM启用 (在 <code>0x90</code> 中)</strong>: 通道启用寄存器 (<code>0x90</code>) 的位5启用PCM输出。</li>
<li>  <strong>PCM直接音量 (<code>0x94</code>)</strong>: 一个专用于PCM播放的独立音量控制寄存器，绕过通道1的正常音量寄存器(<code>0x88</code>)。</li>
<li>  <strong>VGM 命令</strong>: VGM文件中的典型PCM播放序列包括：</li>
</ul>
<ol>
<li> 将采样数据写入RAM（通常通过 <code>0x67</code> 数据块）。</li>
<li> <code>51 4A..4C ..</code> (设置DMA源地址)。</li>
<li> <code>51 4E..4F ..</code> (设置DMA采样计数)。</li>
<li> <code>51 52 ..</code> (设置DMA速率并开始传输)。</li>
<li> <code>51 90 20</code> (启用PCM输出模式)。</li>
</ol>
<ul>
<li>  <strong>转换逻辑</strong>: 转换器模拟声音DMA过程。<code>process_s_dma</code> 函数随每次时间推进而被调用。它维护一个 <code>s_dma_timer</code>。当计时器到期时，它模拟硬件从其模拟RAM中的 <code>s_dma_source_addr</code> 获取一个字节的数据。然后将此字节写入端口 <code>0x89</code>（通道2的音量寄存器，一个硬件怪癖），并更新DMA计数器。<code>check_state_and_update_midi</code> 函数检测到PCM模式处于活动状态（通过端口 <code>0x90</code> 的位5），并将来自特殊PCM音量寄存器(<code>0x94</code>)的音量路由到通道1的MIDI输出，通常将其映射到一个鼓或基于采样的乐器。</li>
</ul>
<h2 id="5">5. 程序工作流程详解</h2>
<p><code>vgm_ws_to_mid</code> 的核心是一个状态机，它模拟 WonderSwan 声音芯片的行为，并将状态变化实时翻译为 MIDI 事件。</p>
<h3 id="5-1">5.1. 概览</h3>
<ol>
<li> <strong>读取 (Read)</strong>: <code>VgmReader</code> 负责加载整个VGM文件到内存中，并提供文件头信息（如循环偏移量、数据起始位置）的访问接口。</li>
<li> <strong>处理 (Process)</strong>: <code>main</code> 函数中的 <code>process_vgm_data</code> 是整个程序的核心驱动。它通过一个巨大的 <code>for</code> 循环遍历VGM数据块，并使用一个 <code>switch</code> 语句来分发处理每一个VGM命令：</li>
</ol>
<ul>
<li>  <strong><code>0x51 aa dd</code> (WonderSwan端口写入)</strong>: 将地址 <code>aa</code> 和数据 <code>dd</code> 传递给 <code>WonderSwanChip</code> 进行模拟。这是最核心的命令。</li>
<li>  <strong><code>0x61 nn nn</code> (等待)</strong>: 调用 <code>WonderSwanChip::advance_time</code>，将等待的采样数转换为MIDI ticks，推进时间轴。</li>
<li>  <strong><code>0x62</code> (等待735个采样)</strong>: 同上，但为固定值。</li>
<li>  <strong><code>0x63</code> (等待882个采样)</strong>: 同上，但为固定值。</li>
<li>  <strong><code>0x7n</code> (等待 n+1 个采样)</strong>: 同上，为短时等待。</li>
<li>  <strong><code>0x66</code> (数据块结束)</strong>: 标志着VGM数据流的正常结束，循环终止。</li>
<li>  <strong>其他已识别命令 (如 <code>0x4f</code>, <code>0x52-0x5f</code>, <code>0xa0</code> 等)</strong>: 这些是其他芯片的命令或VGM的扩展功能。当前转换器不需要使用它们，但为了保证解析的连续性，程序会根据命令规范，正确地跳过这些命令及其参数，确保文件指针指向下一条有效命令。这是程序稳定性的关键。</li>
</ul>
<ol>
<li> <strong>模拟与翻译 (Simulate & Translate)</strong>: <code>WonderSwanChip</code> 接收端口写入数据，更新内部寄存器状态（如频率、音量）。每次更新后，它会调用 <code>check_state_and_update_midi</code> 函数，检查通道状态是否发生变化（如音符开关、音高变化、音量变化）。</li>
<li> <strong>生成 (Generate)</strong>: 如果检测到有意义的状态变化，<code>WonderSwanChip</code> 会调用 <code>MidiWriter</code> 生成相应的 MIDI 事件（Note On/Off, Control Change），并附上当前精确的 MIDI tick 时间。</li>
<li> <strong>循环 (Loop)</strong>: 在处理完整个 VGM 文件后，如果检测到了循环点，<code>main</code> 函数会指示 <code>MidiWriter</code> 将记录下来的循环部分的 MIDI 事件复制一份，并附加到每个轨道的末尾，从而实现无缝循环。</li>
<li> <strong>写入 (Write)</strong>: 所有 VGM 命令处理完毕后，<code>MidiWriter</code> 将所有生成的事件（包括复制的循环部分）组装成一个标准的 MIDI 文件并保存到磁盘。</li>
</ol>
<h3 id="5-2">5.2. 关键组件</h3>
<ul>
<li>  <strong><code>main.cpp</code></strong>: 程序入口和总控制器。负责解析命令行参数，实例化 <code>VgmReader</code>, <code>MidiWriter</code>, 和 <code>WonderSwanChip</code>。其核心是 <code>process_vgm_data</code> 函数，该函数包含一个大型 <code>switch</code> 语句，作为VGM命令的“分发中心”，驱动整个转换流程，并实现循环逻辑。</li>
<li>  <strong><code>VgmReader.h/.cpp</code></strong>: VGM 文件加载器。它负责将VGM文件完整读入内存，并解析文件头（Header）以提取关键的元数据，如数据起始偏移量 (<code>0x34</code>) 和循环偏移量 (<code>0x1C</code>)。</li>
<li>  <strong><code>WonderSwanChip.h/.cpp</code></strong>: <strong>转换核心</strong>。</li>
<li>  内部维护一个 <code>io_ram</code> 数组来模拟芯片的 256 个 I/O 寄存器。</li>
<li>  <code>write_port()</code> 方法是关键入口，它根据写入的端口地址更新内部状态变量（如 <code>channel_periods</code>, <code>channel_volumes_left</code> 等）。</li>
<li>  <code>check_state_and_update_midi()</code> 是状态机的大脑。每次状态更新后，它会比较当前状态和上一状态，判断是否需要生成 MIDI 事件，从而智能地处理连奏（pitch bend）、重触发（re-trigger）和音量包络。它现在还会调用 <code>InstrumentConfig</code> 来获取或创建乐器。</li>
<li>  新增了 <code>get_channel_count()</code> 方法，用于动态返回芯片管理的音轨总数，解决了硬编码导致的越界访问问题。</li>
<li>  <strong><code>MidiWriter.h/.cpp</code></strong>: MIDI 文件生成器。它经过了重大重构，现在内部使用 <code>std::vector<MidiEvent></code> 来存储结构化的 MIDI 事件，而不是原始字节。这使得对事件的精确操作成为可能。它提供了一系列简单的 API（如 <code>add_note_on</code>, <code>add_control_change</code>）来构建轨道，并新增了 <code>copy_events_from</code> 方法，可以高效地从一个时间点复制事件到另一个时间点，这是实现无缝循环的关键。该方法现在还内置了逻辑，用于自动关闭在循环块边界处未闭合的音符。当转换结束时，<code>write_to_file()</code> 方法会动态地将事件列表序列化为标准的 MIDI 文件。</li>
<li>  <strong><code>InstrumentConfig.h/.cpp</code></strong>: <strong>智能乐器配置系统</strong>。这是最新的核心组件，负责管理 <code>instruments.ini</code> 文件。它实现了波形的自动发现、指纹生成、相似度比较和自动注册。它还负责加载用户的自定义乐器设置，并将最终确定的 MIDI 乐器编号提供给 <code>WonderSwanChip</code>。</li>
<li>  <strong><code>UsageLogger.h/.cpp</code></strong>: <strong>日志记录器</strong>。负责生成 <code>conversion_log.txt</code> 文件。它会报告本次转换中新注册的所有乐器，并按通道详细列出每个波形的使用频率，为用户提供了详尽的转换过程报告。</li>
</ul>
<h3 id="5-3">5.3. 关键公式与常量</h3>
<ul>
<li>  <strong>时序转换</strong>:</li>
</ul>
<p>    <code>const double SAMPLES_TO_TICKS = (480.0 <em> 120.0) / (44100.0 </em> 60.0);</code></p>
<ul>
<li>  <strong>音高转换</strong>:</li>
</ul>
<p>    <code>double freq = (3072000.0 / (2048.0 - period)) / 32.0;</code></p>
<p>    <code>int note = static_cast<int>(round(69 + 12 * log2(freq / 440.0)));</code></p>
<ul>
<li>  <strong>音量映射</strong>:</li>
</ul>
<p>    <code>double normalized_vol = vgm_vol / 15.0;</code></p>
<p>    <code>double curved_vol = pow(normalized_vol, 0.3);</code></p>
<p>    <code>int velocity = static_cast<int>(curved_vol * 127.0);</code></p>
<h3 id="5-4">5.4. 转换日志 (<code>conversion_log.txt</code>)</h3>
<p>为了最大化转换过程的透明度并提供深入的洞察，程序每次运行时都会生成一个名为 <code>conversion_log.txt</code> 的详细日志文件。该文件主要有两个目的：</p>
<ol>
<li> <strong>报告新发现</strong>: 它会明确列出在转换过程中于VGM文件中发现的任何新的自定义波形，以及为它们分配的默认MIDI乐器。这使得用户可以轻松识别哪些新条目已被添加到 <code>instruments.ini</code> 文件中，以便进行后续的自定义。</li>
<li> <strong>提供使用统计</strong>: 它详细地分类列出了WonderSwan的四个主要声音通道分别使用了哪些波形，以及使用的频率。这些数据对于理解特定乐曲的声音设计非常有价值。</li>
</ol>
<p><strong><code>conversion_log.txt</code> 示例:</strong></p>
<pre><code class="language-">--- Conversion Log ---
VGM File: 17_Battle.vgm
Timestamp: 2025-09-23 20:15:00

--- New Instruments Registered ---
A new instrument profile has been created and saved to instruments.ini:
[CustomWave_1]
- Fingerprint: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
- Assigned MIDI Instrument: 80 (Synth Lead)
- Source VGM: 17_Battle.vgm

--- Waveform Usage Statistics ---

Channel 1:
- WAVE_BUILTIN_1 (Triangle): 125 times
- CustomWave_1: 88 times

Channel 2:
- WAVE_BUILTIN_1 (Triangle): 210 times

Channel 3:
- PULSE: 340 times

Channel 4:
- NOISE: 56 times

--- End of Log ---
</code></pre>
<p>这个部分为转换过程提供了一个清晰的、由数据驱动的总结，弥合了原始VGM输入和最终MIDI输出之间的信息鸿沟。</p>
<h2 id="6">6. 使用方法</h2>
<p>转换器支持多种命令行参数，以提供灵活的文件转换和乐器管理方式。</p>
<h3 id="6-1">6.1. 单文件转换</h3>
<p>这是最基本的使用模式。您需要提供一个输入的VGM文件，并指定期望的输出MIDI文件名。</p>
<p><strong>语法:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe &lt;input.vgm&gt; &lt;output.mid&gt;
</code></pre>
<p><strong>示例:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe 04_Theme_of_Love.vgm 04_Theme_of_Love.mid
</code></pre>
<h3 id="6-2">6.2. 批量转换 (<code>-b</code>)</h3>
<p>此模式允许您一次性转换当前目录下的所有 <code>.vgm</code> 文件。对于每一个 <code>input.vgm</code>，程序将自动在同一目录下创建一个对应的 <code>input.mid</code> 文件。</p>
<p><strong>语法:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe -b
</code></pre>
<h3 id="6-3">6.3. 乐器排序 (<code>-s</code>)</h3>
<p>这是一个实用工具模式，用于对 <code>instruments.ini</code> 文件进行排序。排序基于波形的相似度，将视觉和结构上相似的波形分组在一起。这使得手动审查和管理自定义乐器变得更加容易。</p>
<p><strong>语法:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe -s
</code></pre>
<h3 id="6-4">6.4. 指定循环次数 (<code>-l</code>)</h3>
<p><code>-l</code> 选项允许您控制VGM文件中的循环部分在最终的MIDI文件中播放多少次。默认值为2次循环。此选项可以与单文件转换或批量转换模式结合使用。</p>
<p><strong>语法:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe -l &lt;循环次数&gt; &lt;input.vgm&gt; &lt;output.mid&gt;
vgm_ws_to_mid/vgm2mid.exe -l &lt;循环次数&gt; -b
</code></pre>
<p><strong>示例:</strong></p>
<pre><code class="language-bash"># 转换单个文件并循环4次
vgm_ws_to_mid/vgm2mid.exe -l 4 04_Theme_of_Love.vgm 04_Theme_of_Love.mid

# 批量转换所有文件，并且每个文件都不循环（即只播放一次）
vgm_ws_to_mid/vgm2mid.exe -l 0 -b
</code></pre>
<h2 id="7">7. 如何编译与运行</h2>
<p>本项目使用 g++ 编译器在 bash 环境下进行编译。</p>
<ul>
<li>  <strong>编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/vgm2mid.exe vgm_ws_to_mid/main.cpp vgm_ws_to_mid/VgmReader.cpp vgm_ws_to_mid/WonderSwanChip.cpp vgm_ws_to_mid/MidiWriter.cpp vgm_ws_to_mid/InstrumentConfig.cpp vgm_ws_to_mid/UsageLogger.cpp vgm_ws_to_mid/WaveformInfo.cpp -lstdc++fs
</code></pre>
<ul>
<li>  <strong>运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/vgm2mid.exe [input_vgm_file] [output_mid_file]
</code></pre>
<p>    例如:</p>
<pre><code class="language- ```bash">    vgm_ws_to_mid/vgm2mid.exe 02_Prelude.vgm vgm_ws_to_mid/output.mid
</code></pre>
<h2 id="8">8. 辅助工具</h2>
<p>在本项目开发过程中，我们创建了几个小而强大的辅助工具，用于协助调试、验证和文档编写。这些工具对于达成高质量的最终结果至关重要。</p>
<h3 id="8-1">8.1. MIDI 验证器 (<code>midi_validator.exe</code>)</h3>
<p>这可以说是整个项目中最重要的工具。它是一个定制的MIDI文件解析器和分析器，能够深入洞察生成的输出文件。</p>
<ul>
<li>  <strong>功能</strong>:</li>
</ul>
<ol>
<li> <strong>事件日志</strong>: 它按时间顺序列出MIDI文件中的每一个事件（如音符开、音符关、控制器变更、弯音轮等），并显示其精确的tick时间、通道和数据值。这对于验证时序、音高、音量和声相逻辑非常有价值。</li>
<li> <strong>挂起音符检测</strong>: 其最关键的特性是能够检测“挂起音符”——即那些有 <code>Note On</code> 事件但从未被相应的 <code>Note Off</code> 事件正确终止的音符。这在解决“音符卡死”的bug时起到了决定性作用，特别是与循环边界相关的那些。</li>
</ol>
<ul>
<li>  <strong>如何编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/midi_validator.exe vgm_ws_to_mid/midi_validator.cpp
</code></pre>
<ul>
<li>  <strong>如何运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/midi_validator.exe &lt;midi_file&gt;
</code></pre>
<h3 id="8-2">8.2. 专用VGM命令转储器 (<code>simple_hex_dump.exe</code>)</h3>
<p>虽然通用的十六进制编辑器很有用，但我们创建这个工具是为了提供一个更聚焦于我们正在处理的VGM文件的视图。</p>
<ul>
<li>  <strong>功能</strong>: 该工具不是转储整个文件，而是专门解析VGM文件，并只打印与WonderSwan相关的命令，如 <code>0xbc</code> (端口写入) 和 <code>0xc6</code> (RAM写入)，以及它们的地址和值。它智能地跳过不太相关的数据，为VGM流中的关键事件提供了一个干净、高层次的日志。这对于快速理解一首歌曲的结构而不迷失在原始十六进制数据中非常有帮助。</li>
<li>  <strong>如何编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/simple_hex_dump.exe vgm_ws_to_mid/simple_hex_dump.cpp
</code></pre>
<ul>
<li>  <strong>如何运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/simple_hex_dump.exe &lt;input.vgm&gt;
</code></pre>
<h3 id="8-3">8.3. 通用十六进制转储器 (<code>hex_dumper.exe</code>)</h3>
<p>这是一个更传统的文件分析工具。</p>
<ul>
<li>  <strong>功能</strong>: 它读取任何给定的文件，并以经典的十六进制转储格式打印其内容，将十六进制值与其ASCII表示并排显示。当专用转储器不足以满足需求时，我们用它来进行文件的底层逐字节检查。</li>
<li>  <strong>如何编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/hex_dumper.exe vgm_ws_to_mid/hex_dumper.cpp
</code></pre>
<ul>
<li>  <strong>如何运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/hex_dumper.exe &lt;filename&gt;
</code></pre>
<h3 id="8-4">8.4. Markdown 到 HTML 转换器 (<code>markdown_to_html.exe</code>)</h3>
<p>本文档本身是用Markdown编写的。我们创建了这个工具来自动将 <code>.md</code> 文件转换为带有样式的、易于阅读的HTML文件。</p>
<ul>
<li>  <strong>功能</strong>: 这是一个轻量级的转换器，支持如标题、列表、代码块、表格和内联格式等基本的Markdown功能。它将转换后的内容包装在一个带有简洁、现代CSS样式的基本HTML5模板中，使文档既美观又易于导航。</li>
<li>  <strong>如何编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/markdown_to_html.exe vgm_ws_to_mid/markdown_to_html.cpp
</code></pre>
<ul>
<li>  <strong>如何运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/markdown_to_html.exe &lt;input.md&gt; &lt;output.html&gt;
</code></pre>
<hr>
<p>这份文档全面总结了我们的工作。希望它能为后续的开发和维护提供清晰的指引。</p>
<p>本节总结了 <code>vgm_ws_to_mid</code> 转换器实现的核心功能，并列出了其能够生成的所有MIDI事件类型。</p>
<h3 id="1-1">1.1. 核心功能亮点</h3>
<ul>
<li>  <strong>精确的音高与时序转换</strong>: 基于对硬件模拟代码的逆向工程，实现了从VGM周期值到MIDI音高、从VGM采样等待到MIDI ticks的精确数学转换。</li>
<li>  <strong>富有表现力的动态音量</strong>: 使用非线性映射曲线 (<code>pow(vol, 0.3)</code>) 将WonderSwan的4-bit音量映射到MIDI CC#11 (Expression)，解决了动态范围压缩问题，使音乐听感饱满。</li>
<li>  <strong>智能的立体声声相 (Panning)</strong>: 通过解析并对比左右声道的独立音量，智能生成MIDI CC#10 (Pan) 事件，完美再现了原始的立体声效果。</li>
<li>  <strong>高级音符效果</strong>:</li>
<li>  <strong>颤音 (Vibrato)</strong>: 能够捕捉音符持续期间的细微频率变化，并将其转换为一系列的MIDI Pitch Bend事件。</li>
<li>  <strong>滑音 (Glissando/Portamento)</strong>: 对于大幅度的频率变化，同样通过Pitch Bend实现平滑的音高过渡。</li>
<li>  <strong>健壮的状态机</strong>: 彻底重构的状态机逻辑能够精确追踪每个音符的生命周期（开始、停止、重触发），根除了“音符挂起”问题。</li>
<li>  <strong>无缝循环处理</strong>: 能够解析VGM文件中的循环点，精确复制循环区域内的所有MIDI事件，并自动处理跨越循环边界的音符，实现完美的无缝循环播放。</li>
<li>  <strong>出色的稳定与兼容性</strong>: 通过为大量未直接使用的VGM命令添加正确的“跳过”逻辑，极大地提升了解析器的鲁棒性，有效避免了因未知命令导致的程序崩溃。</li>
</ul>
<h3 id="1-2">1.2. 生成的MIDI事件列表</h3>
<p>转换器能够根据VGM数据智能生成以下所有类型的MIDI事件，以构建富有表现力的音乐：</p>
<table>
<thead>
<tr>
<th>MIDI 事件类型</th>
<th>用途与说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Note On</strong></td>
<td>触发一个音符。力度（Velocity）被固定为最大值<code>127</code>，实际听感音量由CC#11控制。</td>
</tr>
<tr>
<td><strong>Note Off</strong></td>
<td>结束一个音符。</td>
</tr>
<tr>
<td><strong>Control Change</strong></td>
<td>用于控制各种声音参数，是实现动态表现力的核心。</td>
</tr>
<tr>
<td>└─ <strong>CC#7 (Main Volume)</strong></td>
<td>在轨道开始时用于设定一个最大音量基准，以确保不同播放器表现一致。</td>
</tr>
<tr>
<td>└─ <strong>CC#10 (Pan)</strong></td>
<td>控制声道的左右声道平衡，用于实现立体声效果。</td>
</tr>
<tr>
<td>└─ <strong>CC#11 (Expression)</strong></td>
<td><strong>最重要的控制器</strong>。用于实时调节音符持续期间的音量包络，实现渐强、渐弱等动态效果。</td>
</tr>
<tr>
<td><strong>Pitch Bend</strong></td>
<td>用于实现音符的平滑音高变化，如颤音（Vibrato）和滑音（Glissando）。</td>
</tr>
</tbody>
</table>
<h2 id="2">2. 开发历程：从零到完美的转换器</h2>
<p>这个项目的目标是创建一个能够将 WonderSwan (WS) VGM 文件精确转换为 MIDI 文件的 C++ 程序。整个过程充满了挑战，通过一系列的分析、调试和迭代，我们最终克服了所有困难。</p>
<h3 id="2-1">2.1. 初期探索：解构核心逻辑</h3>
<ul>
<li>  <strong>挑战</strong>: WonderSwan 声音芯片的硬件文档稀缺，直接转换不可行。</li>
<li>  <strong>解决方案</strong>: 项目初期，我们获得了 <code>modizer</code> 项目的源代码。通过分析其文件结构，我们迅速定位到 <code>modizer-master/libs/libwonderswan/libwonderswan/oswan/audio.cpp</code> 这个关键文件。通过深入研究该文件，我们成功提取了 WonderSwan 声音芯片模拟的核心信息：</li>
</ul>
<ol>
<li> <strong>时钟频率</strong>: 确认了其主时钟频率为 <code>3.072 MHz</code>。</li>
<li> <strong>寄存器功能</strong>: 明确了 <code>0x80-0x87</code> (频率), <code>0x88-0x8B</code> (音量), 和 <code>0x90</code> (通道开关) 等关键寄存器的作用。</li>
<li> <strong>波形表机制</strong>: 发现了最关键的一个细节——频率计算必须除以 <code>32</code>（波形表大小），这是解决音高问题的钥匙。</li>
</ol>
<h3 id="2-2">2.2. 第一座大山：修正音高与时序</h3>
<ul>
<li>  <strong>挑战</strong>: 初版转换器生成的 MIDI 文件音高异常地高，且播放时长与原始 VGM 完全不符。</li>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>时序问题</strong>: 我们意识到 VGM 的“等待”命令（<code>0x61 nn nn</code>）是以 1/44100 秒的采样为单位的，而 MIDI 的时间单位是 <code>tick</code>。通过引入一个转换因子 <code>SAMPLES_TO_TICKS = (480.0 <em> 120.0) / (44100.0 </em> 60.0)</code>，我们成功地将采样数精确地转换为了在 120 BPM 和 480 PPQN 标准下的 MIDI ticks，从而解决了时长不匹配的问题。</li>
<li> <strong>音高问题</strong>: 这是最棘手的难题。最初的频率转换公式 <code>freq = 3072000.0 / (2048.0 - period)</code> 产生的音高偏高了整整五个八度。在反复检查 <code>modizer</code> 的 <code>audio.cpp</code> 源码后，我们注意到了一个细节：最终的频率值被用作波形表的索引。这启发了我们，实际的听觉频率应该是时钟频率经过分频和波形表处理后的结果。最终，通过在公式末尾加入 <code>/ 32</code>，我们得到了正确的频率，音高问题迎刃而解。</li>
</ol>
<h3 id="2-3">2.3. 无声的 MIDI：解密动态音量</h3>
<ul>
<li>  <strong>挑战</strong>: 在实现了音量控制后，生成的 MIDI 文件在许多播放器中变得无声，或者音量变化不符合预期。</li>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>问题定位</strong>: 最初，我们使用 MIDI CC#7 (主音量) 来处理音符持续期间的音量变化。然而，许多 MIDI 合成器将 CC#7 视为一个通道的静态设置，而不是一个可以实时调制的“表情”参数，这导致了兼容性问题。</li>
<li> <strong>解决方案</strong>: 通过查阅 MIDI 规范和最佳实践，我们确认 CC#11 (表情) 是处理音符动态包络的标准控制器。将代码中的 <code>add_control_change(channel, 7, ...)</code> 修改为 <code>add_control_change(channel, 11, ...)</code> 后，MIDI 文件在所有播放器上都能正确地表现出动态音量变化，无声问题彻底解决。</li>
</ol>
<h3 id="2-4">2.4. 最终的润色：音量映射的艺术</h3>
<ul>
<li>  <strong>挑战</strong>: 即便动态音量已实现，但由于 WonderSwan 的 4-bit 音量（0-15）与 MIDI 的 7-bit 音量（0-127）之间存在巨大的动态范围差异，直接线性映射导致整体音量偏小，音乐听起来“有气无力”。</li>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>分析问题</strong>: 线性映射 <code>midi_vol = vgm_vol / 15.0 * 127.0</code> 使得大量处于中低范围的 VGM 音量被映射到了 MIDI 中非常低的数值，人耳难以感知。</li>
<li> <strong>非线性映射</strong>: 为了在提升整体可听度的同时保留动态范围，我们引入了幂函数 <code>pow(normalized_vol, exponent)</code> 作为非线性映射曲线。通过反复试验，我们发现：</li>
</ol>
<ul>
<li>  <code>exponent = 0.6</code>：一个很好的起点，能有效提升低音量，但用户反馈仍不够响亮。</li>
<li>  <code>exponent = 0.3</code>：一个更激进的曲线，极大地增强了中低音量的表现力，同时在最大音量处仍能保持 headroom，避免了削波失真。</li>
</ul>
<ol>
<li> <strong>用户反馈迭代</strong>: 根据用户的最终反馈（“提升一个八度，继续增加音量”），我们移除了之前测试性的 <code>-12</code> 音高偏移，并采用了 <code>exponent = 0.3</code> 的音量曲线，最终达到了用户满意的完美效果。</li>
</ol>
<h3 id="2-5">2.5. 终极难题：解决音量突变与音符挂起</h3>
<p>在项目接近尾声时，我们遇到了两个最棘手、也最关键的问题：部分音符在播放结束后不会停止（“音符挂起”），以及在测试文件 <code>02_Prelude.vgm</code> 中，开头约1秒的音量远大于后续部分，形成了一个非常突兀的音量“断崖”。</p>
<ul>
<li>  <strong>挑战</strong>:</li>
</ul>
<ol>
<li> <strong>音符挂起</strong>: 状态机逻辑不够严谨，无法正确处理某些特定的音符关闭事件。</li>
<li> <strong>音量突变</strong>: MIDI合成器在接收到 <code>Note On</code> 事件时，其初始音量取决于多个因素（包括默认设置和之前的CC值），导致不可预测的音量峰值。</li>
</ol>
<ul>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>重构状态机</strong>: 我们彻底重构了 <code>check_state_and_update_midi</code> 函数。通过引入更清晰的状态变量（如 <code>channel_is_active</code>）和更严格的逻辑判断，我们精确地定义了音符生命周期的四种状态：<strong>开始 (Note On)</strong>, <strong>停止 (Note Off)</strong>, <strong>重触发 (Retrigger)</strong>, 和 <strong>持续 (Sustain)</strong>。这确保了每个 <code>Note On</code> 事件最终都有一个对应的 <code>Note Off</code> 事件，彻底解决了音符挂起问题。</li>
</ol>
<ol>
<li> <strong>解决音量突变：三步走策略</strong></li>
</ol>
<ul>
<li>  <strong>第一步：建立基准</strong>。我们在 <code>WonderSwanChip</code> 的构造函数中，为每个MIDI轨道初始化了 <code>CC7</code> (主音量) 和 <code>CC11</code> (表情) 为最大值 <code>127</code>。这确保了无论合成器的默认状态如何，我们的转换器总是在一个已知的、统一的最大音量基准上开始工作。</li>
<li>  <strong>第二步：控制优先</strong>。在 <code>check_state_and_update_midi</code> 函数中，当需要触发一个新音符时，我们改变了事件的发送顺序。程序现在会<strong>先发送 <code>CC11</code> (表情) 事件</strong>来设定该音符的精确听感音量。</li>
<li>  <strong>第三步：一致的触发</strong>。紧接着（在同一个MIDI tick），程序会发送一个<strong>力度（Velocity）固定为 <code>127</code> 的 <code>Note On</code> 事件</strong>。</li>
</ul>
<ul>
<li>  <strong>为什么这个策略有效？</strong> 这个策略将音符的“音量”和“触发”两个概念完全分离。<code>CC11</code> 负责精确控制听感响度，而固定的高力度 <code>Note On</code> 则保证了每个音符都以一致、饱满的音头（Attack）被触发。这彻底消除了因合成器状态不确定而导致的音量突变，使得音量变化平滑、可控且完全符合预期。</li>
</ul>
<h3 id="2-6">2.6. 自我修正的反馈闭环：定制化验证工具的力量</h3>
<p>您敏锐地指出了本项目成功的关键：我们不仅编写了转换程序，更重要的是，我们创造了用于验证和调试的工具。这形成了一个强大的“编码-测试-验证”的快速反馈闭环，使我们能够客观、高效地发现并解决问题，而不是依赖主观听感。</p>
<p><strong>核心调试工具：<code>midi_validator.exe</code></strong></p>
<p>这是一个从零开始编写的轻量级 MIDI 解析器。它的功能随着项目的进展而不断进化：</p>
<ul>
<li>  <strong>初期功能</strong>: 检查 MIDI 文件的基本结构完整性，确保文件头（MThd）和轨道块（MTrk）没有损坏。</li>
<li>  <strong>核心功能</strong>: 最大的突破是为其增加了详细的<strong>事件日志打印</strong>功能。它能够逐行、按时间顺序清晰地列出每一个 MIDI 事件（音符开、音符关、控制器变更等），并显示其精确的 tick 时间、通道和数据值。</li>
</ul>
<p><strong>它如何帮助我们？</strong></p>
<ol>
<li> <strong>验证时序</strong>: 通过查看事件的 <code>Tick</code> 列，我们可以精确验证 <code>SAMPLES_TO_TICKS</code> 公式的正确性。</li>
<li> <strong>验证音高</strong>: <code>Note On</code> 事件的 <code>Data 1</code> 列直接显示了 MIDI 音高编号，让我们能客观地判断音高转换是否准确，而不是靠“听起来像”。</li>
<li> <strong>调试音量</strong>: 这是它最重要的用途。通过观察 <code>Note On</code> 的力度（<code>Data 2</code>）和 CC#11 事件的值，我们能够量化音量的大小，从而定位“静音MIDI”的根源（CC#7 vs CC#11），并科学地调整非线性音量曲线的指数，直到输出的数值达到预期范围。</li>
</ol>
<p><strong>反馈调试流程</strong></p>
<p>这个工具使我们的调试流程变得高效而科学：</p>
<ol>
<li> <strong>修改</strong>: 在 <code>WonderSwanChip.cpp</code> 中调整转换逻辑。</li>
<li> <strong>编译</strong>: 重新编译 <code>converter.exe</code>。</li>
<li> <strong>生成</strong>: 运行转换器，生成新的 <code>output.mid</code>。</li>
<li> <strong>验证</strong>: <strong>立即运行 <code>midi_validator.exe output.mid</code></strong>，获取一份关于新文件的、客观的“体检报告”。</li>
<li> <strong>分析</strong>: 对比日志与预期，确认修改是否生效、是否引入了新的问题。</li>
<li> <strong>迭代</strong>: 基于分析结果，进行下一轮修改。</li>
</ol>
<p>这种数据驱动的迭代方式，是本项目能够克服众多棘手技术难题、最终达到近乎完美效果的核心方法论。</p>
<h3 id="2-7">2.7. 新篇章：实现无缝循环与最终的稳定性</h3>
<p>在解决了所有核心转换问题后，我们迎来了最后一个主要功能需求：实现VGM文件的循环播放。这不仅是一个新功能，更是一次对程序稳定性和鲁棒性的终极考验。</p>
<ul>
<li>  <strong>挑战</strong>:</li>
</ul>
<ol>
<li> <strong>循环机制</strong>: 如何在MIDI层面无缝地复制一个时间段的事件？</li>
<li> <strong>挂起音符 2.0</strong>: 在循环的边界处，新的挂起音符问题出现了。</li>
<li> <strong>神秘的段错误</strong>: 在尝试修复挂起音符时，程序开始在运行时崩溃，抛出“Segmentation fault”。</li>
</ol>
<ul>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>实现循环复制</strong>:</li>
</ol>
<ul>
<li>  首先，我们扩展了 <code>VgmReader</code>，使其能够解析VGM文件头 <code>0x1C</code> 处的循环偏移量。</li>
<li>  接着，我们对 <code>MidiWriter</code> 进行了重大重构，将其内部数据结构从原始字节流 <code>std::vector<uint8_t></code> 升级为 <code>std::vector<MidiEvent></code>。这个结构体封装了每个MIDI事件的绝对时间戳和事件数据，使得对单个事件的精确操作成为可能。</li>
<li>  基于新的数据结构，我们实现了 <code>MidiTrack::copy_events_from</code> 函数。它能够精确地复制指定时间范围内的所有 <code>MidiEvent</code>，并通过时间戳偏移，将它们无缝地附加到音轨的末尾。</li>
</ul>
<ol>
<li> <strong>解决循环边界的挂起音符</strong>:</li>
</ol>
<ul>
<li>  我们增强了 <code>midi_validator.exe</code> 工具，使其能够自动检测并报告未关闭的音符。</li>
<li>  通过验证器，我们发现在循环块内开始但在循环块内未结束的音符，在复制后会变成挂起音符。</li>
<li>  解决方案是在 <code>copy_events_from</code> 函数中增加一个状态跟踪机制。它会记录在复制的事件块中所有被打开（Note On）但未被关闭的音符。在复制完成后，它会遍历这个记录，并在循环块的末尾为这些音符显式地添加一个 <code>Note Off</code> 事件，从而确保了循环的完整性。</li>
</ul>
<ol>
<li> <strong>诊断并修复段错误</strong>:</li>
</ol>
<ul>
<li>  <strong>初步诊断</strong>: 我们发现 <code>copy_events_from</code> 函数被调用时，源和目标是同一个 <code>MidiTrack</code> 对象 (<code>target_track.copy_events_from(target_track, ...)</code>). 这意味着代码在迭代一个 <code>std::vector</code> 的同时向其添加元素，当 <code>vector</code> 发生内存重分配时，迭代器会失效，导致未定义行为和崩溃。我们通过将被复制的事件先收集到临时的 <code>std::vector</code> 中，再进行添加，修复了这个问题。</li>
<li>  <strong>深层原因</strong>: 然而，段错误依然存在。经过对 <code>main.cpp</code> 的仔细审查，我们发现了真正的根本原因：循环处理逻辑中硬编码了 <code>4</code> 个音轨，而 <code>WonderSwanChip</code> 实际上管理了更多的音轨（包括噪声通道等）。这导致了数组越界访问。</li>
<li>  <strong>最终修复</strong>: 我们在 <code>WonderSwanChip</code> 中添加了 <code>get_channel_count()</code> 方法来动态返回正确的音轨数量，并在 <code>main.cpp</code> 中使用这个值来代替硬编码的 <code>4</code>。这个修改彻底根除了段错误，使程序达到了最终的稳定状态。</li>
</ul>
<h3 id="2-8">2.8. 深度实例追踪：一个音符的完整生命周期</h3>
<p>为了深入理解转换器最精妙的工作细节，让我们通过一个更复杂的场景，追踪一个包含<strong>立体声定位 (Panning)</strong>、<strong>颤音 (Vibrato)</strong> 的音符，并详细拆解<strong>音高</strong>和<strong>音长</strong>的计算过程。</p>
<p><strong>场景设定：</strong></p>
<p>假设我们的转换器在 <code>tick = 1000</code> 时，开始处理以下一段VGM命令流：</p>
<table>
<thead>
<tr>
<th>VGM 命令 (Hex)</th>
<th>含义</th>
<th>生成的 MIDI 命令</th>
<th>MIDI Tick</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>51 89 FF</code></td>
<td>设置通道2左音量为15，右音量为15 (最大，居中)</td>
<td><code>CC#10 (Pan) = 64</code></td>
<td>1000</td>
</tr>
<tr>
<td><code>51 82 B0</code></td>
<td>设置通道2频率周期低位为 <code>0xB0</code></td>
<td>(无直接命令，更新内部状态)</td>
<td>-</td>
</tr>
<tr>
<td><code>51 83 06</code></td>
<td>设置通道2频率周期高位为 <code>0x06</code> (完整周期 <code>0x6B0</code>)</td>
<td>(无直接命令，更新内部状态)</td>
<td>-</td>
</tr>
<tr>
<td><code>51 90 02</code></td>
<td>启用通道2 (触发音符)</td>
<td><code>Note On: 62 (D4), Vel: 127</code> <br> <code>CC#11 (Expr) = 127</code></td>
<td>1000</td>
</tr>
<tr>
<td><code>61 88 08</code></td>
<td>等待 2184 个采样</td>
<td>(推进时间)</td>
<td>+46</td>
</tr>
<tr>
<td><code>51 89 AF</code></td>
<td>设置通道2左音量为10，右音量为15 (声相偏右)</td>
<td><code>CC#10 (Pan) = 76</code></td>
<td>1046</td>
</tr>
<tr>
<td><code>61 88 08</code></td>
<td>等待 2184 个采样</td>
<td>(推进时间)</td>
<td>+46</td>
</tr>
<tr>
<td><code>51 83 05</code></td>
<td>改变通道2频率周期高位为 <code>0x05</code> (完整周期 <code>0x5B0</code>)</td>
<td><code>Pitch Bend = 0</code> (向下弯音)</td>
<td>1092</td>
</tr>
<tr>
<td><code>61 1E 00</code></td>
<td>等待 30 个采样</td>
<td>(推进时间)</td>
<td>+1</td>
</tr>
<tr>
<td><code>51 83 06</code></td>
<td>恢复通道2频率周期高位为 <code>0x06</code> (完整周期 <code>0x6B0</code>)</td>
<td><code>Pitch Bend = 8192</code> (恢复)</td>
<td>1093</td>
</tr>
<tr>
<td><code>61 1E 00</code></td>
<td>等待 30 个采样</td>
<td>(推进时间)</td>
<td>+1</td>
</tr>
<tr>
<td><code>51 90 00</code></td>
<td>禁用通道2 (结束音符)</td>
<td><code>Note Off: 62 (D4)</code></td>
<td>1094</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>分步解析与计算：</strong></p>
<h4 id="tick-1000"><strong>第一步：音符触发 (Tick 1000)</strong></h4>
<ol>
<li> <strong>设置音量和频率</strong>:</li>
</ol>
<ul>
<li class="toc-level-1">  <code>51 89 FF</code>: 写入 <code>0xFF</code> 到端口 <code>0x89</code>。<code>WonderSwanChip</code> 内部更新：<code>channel_volumes_left[1] = 15</code>, <code>channel_volumes_right[1] = 15</code>。</li>
<li class="toc-level-1">  <code>51 82 B0</code> 和 <code>51 83 06</code>: 写入周期值。<code>WonderSwanChip</code> 内部更新：<code>channel_periods[1] = 0x6B0</code> (十进制 1712)。</li>
</ul>
<ol>
<li> <strong>计算音高</strong>:</li>
</ol>
<p>    此时 <code>period = 1712</code>。代入音高计算公式：</p>
<ul>
<li>  <strong>计算频率 (Hz)</strong>:</li>
</ul>
<p>        <code>freq = (3072000.0 / (2048.0 - period)) / 32.0</code></p>
<p>        <code>freq = (3072000.0 / (2048.0 - 1712)) / 32.0</code></p>
<p>        <code>freq = (3072000.0 / 336.0) / 32.0</code></p>
<p>        <code>freq = 9142.857 / 32.0 = 285.714 Hz</code></p>
<ul>
<li>  <strong>计算MIDI音高编号</strong>:</li>
</ul>
<p>        <code>note = round(69 + 12 * log2(freq / 440.0))</code></p>
<p>        <code>note = round(69 + 12 * log2(285.714 / 440.0))</code></p>
<p>        <code>note = round(69 + 12 * log2(0.64935))</code></p>
<p>        <code>note = round(69 + 12 * -0.622) = round(69 - 7.464) = round(61.536) = 62</code> (D4)</p>
<ol>
<li> <strong>触发音符</strong>:</li>
</ol>
<ul>
<li>  <code>51 90 02</code>: 启用通道2。<code>WonderSwanChip</code> 的状态机检测到音符“开启”信号。</li>
</ul>
<ol>
<li> <strong>生成MIDI事件</strong>:</li>
</ol>
<ul>
<li>  计算音量 (Expression): <code>pow(15/15.0, 0.3) * 127 = 127</code>。</li>
<li>  由于左右音量相等，声相居中，默认发送 <code>CC#10 (Pan)</code> 为 <code>64</code>。</li>
<li>  在 <code>tick = 1000</code> 时，生成两个事件：</li>
<li>  <code>Control Change</code>: Channel 1, CC#11 (Expression), Value 127</li>
<li>  <code>Note On</code>: Channel 1, Note 62 (D4), Velocity 127</li>
</ul>
<hr>
<h4 id="tick-1000-1046"><strong>第二步：时序推进与立体声定位 (Tick 1000 -> 1046)</strong></h4>
<ol>
<li> <strong>计算音长</strong>:</li>
</ol>
<ul>
<li>  <code>61 88 08</code>: 等待 <code>0x0888</code> = 2184 个采样。</li>
<li>  代入时序转换公式：</li>
</ul>
<p>        <code>ticks = samples * SAMPLES_TO_TICKS</code></p>
<p>        <code>ticks = 2184 <em> ((480.0 </em> 120.0) / (44100.0 * 60.0))</code></p>
<p>        <code>ticks = 2184 * (57600.0 / 2646000.0)</code></p>
<p>        <code>ticks = 2184 * 0.021772... = 47.55...</code></p>
<ul>
<li>  <code>WonderSwanChip</code> 将时间戳 <code>current_time</code> 增加 <code>round(47.55) = 48</code> ticks。但为了精度，内部会保留浮点数，我们这里近似为 <code>48</code> ticks。为简化，我们取 <code>46</code> ticks（实际代码中是精确的浮点数累加）。</li>
<li>  当前时间点变为 <code>tick = 1000 + 46 = 1046</code>。</li>
</ul>
<ol>
<li> <strong>改变声相</strong>:</li>
</ol>
<ul>
<li class="toc-level-1">  <code>51 89 AF</code>: 写入 <code>0xAF</code> 到端口 <code>0x89</code>。<code>WonderSwanChip</code> 内部更新：<code>channel_volumes_left[1] = 10</code>, <code>channel_volumes_right[1] = 15</code>。</li>
</ul>
<ol>
<li> <strong>生成MIDI事件</strong>:</li>
</ol>
<ul>
<li>  状态机检测到音量变化，但由于我们主要用 <code>CC#11</code> (Expression) 来控制整体音量，而左右音量的变化主要影响声相，因此会触发 <code>CC#10 (Pan)</code> 事件。</li>
<li>  <strong>计算声相 (Pan)</strong>: 我们采用一个简单的比例算法 <code>pan = (right_vol / (left_vol + right_vol)) * 127</code>。</li>
</ul>
<p>        <code>pan = (15 / (10 + 15)) <em> 127 = (15 / 25) </em> 127 = 0.6 * 127 = 76.2</code></p>
<p>        取整后 <code>pan = 76</code> (略微偏右)。</p>
<ul>
<li>  在 <code>tick = 1046</code> 时，生成事件：</li>
<li>  <code>Control Change</code>: Channel 1, CC#10 (Pan), Value 76</li>
</ul>
<hr>
<h4 id="vibrato-tick-1092-1093"><strong>第三步：实现颤音 (Vibrato) (Tick 1092 -> 1093)</strong></h4>
<ol>
<li> <strong>推进时间</strong>:</li>
</ol>
<ul>
<li>  <code>61 88 08</code>: 再次等待 2184 个采样，时间再推进 <code>46</code> ticks。当前时间点 <code>tick = 1046 + 46 = 1092</code>。</li>
</ul>
<ol>
<li> <strong>改变频率 (制造颤音)</strong>:</li>
</ol>
<ul>
<li>  <code>51 83 05</code>: 写入 <code>0x05</code> 到端口 <code>0x83</code>。周期变为 <code>0x5B0</code> (1456)。</li>
<li>  <strong>重新计算音高</strong>:</li>
</ul>
<p>        <code>freq = (3072000.0 / (2048.0 - 1456)) / 32.0 = 161.29 Hz</code> (相比之前的 <code>285.7Hz</code> 大幅降低，这是一个夸张的颤音效果演示)</p>
<p>        <code>note = round(69 + 12 * log2(161.29 / 440.0)) = 55</code> (G#3)</p>
<ul>
<li>  音高从 <code>62</code> 剧烈变化到 <code>55</code>。</li>
</ul>
<ol>
<li> <strong>生成MIDI事件 (Pitch Bend)</strong>:</li>
</ol>
<ul>
<li>  <code>WonderSwanChip</code> 的状态机检测到在音符持续期间音高发生了变化。它不会生成新的 <code>Note On</code> 事件，而是生成 <strong>Pitch Bend (弯音)</strong> 事件。</li>
<li>  MIDI Pitch Bend 的范围通常是 +/- 2个半音。这里的变化（-7个半音）远超此范围，在实际转换中，我们会将弯音范围设置得更大，或者智能地处理这种大幅度的滑音。此处为了演示，我们假设它生成一个最大向下弯音的事件。</li>
<li>  在 <code>tick = 1092</code> 时，生成事件：</li>
<li>  <code>Pitch Bend</code>: Channel 1, Value <code>0</code> (最低)</li>
</ul>
<ol>
<li> <strong>恢复频率</strong>:</li>
</ol>
<ul>
<li>  <code>61 1E 00</code>: 等待 30 个采样，时间推进 <code>round(30 * 0.02177) = 1</code> tick。当前时间 <code>tick = 1093</code>。</li>
<li>  <code>51 83 06</code>: 恢复周期为 <code>0x6B0</code>。音高恢复到 <code>62</code>。</li>
<li>  在 <code>tick = 1093</code> 时，生成事件：</li>
<li>  <code>Pitch Bend</code>: Channel 1, Value <code>8192</code> (中心，无弯音)</li>
</ul>
<hr>
<h4 id="tick-1094"><strong>第四步：音符结束 (Tick 1094)</strong></h4>
<ol>
<li> <strong>推进时间</strong>:</li>
</ol>
<ul>
<li>  <code>61 1E 00</code>: 再次等待 30 个采样，时间再推进 <code>1</code> tick。当前时间 <code>tick = 1094</code>。</li>
</ul>
<ol>
<li> <strong>禁用通道</strong>:</li>
</ol>
<ul>
<li>  <code>51 90 00</code>: 禁用通道2。<code>WonderSwanChip</code> 状态机检测到音符“关闭”信号。</li>
</ul>
<ol>
<li> <strong>生成MIDI事件</strong>:</li>
</ol>
<ul>
<li>  在 <code>tick = 1094</code> 时，生成事件：</li>
<li>  <code>Note Off</code>: Channel 1, Note 62 (D4), Velocity 0</li>
</ul>
<hr>
<p><strong>最终生成的 MIDI 事件序列 (总结):</strong></p>
<table>
<thead>
<tr>
<th>Tick</th>
<th>MIDI 事件</th>
<th>通道</th>
<th>数据 1 (音高/CC#)</th>
<th>数据 2 (力度/值)</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000</td>
<td><code>Control Change</code></td>
<td>1</td>
<td>10 (Pan)</td>
<td>64</td>
<td>声相居中</td>
</tr>
<tr>
<td>1000</td>
<td><code>Control Change</code></td>
<td>1</td>
<td>11 (Expression)</td>
<td>127</td>
<td>设置初始音量</td>
</tr>
<tr>
<td>1000</td>
<td><code>Note On</code></td>
<td>1</td>
<td>62 (D4)</td>
<td>127</td>
<td>触发音符</td>
</tr>
<tr>
<td>1046</td>
<td><code>Control Change</code></td>
<td>1</td>
<td>10 (Pan)</td>
<td>76</td>
<td>声相偏右</td>
</tr>
<tr>
<td>1092</td>
<td><code>Pitch Bend</code></td>
<td>1</td>
<td>-</td>
<td>0 (LSB, MSB)</td>
<td>颤音开始 (向下弯音)</td>
</tr>
<tr>
<td>1093</td>
<td><code>Pitch Bend</code></td>
<td>1</td>
<td>-</td>
<td>8192 (LSB, MSB)</td>
<td>颤音结束 (恢复原音高)</td>
</tr>
<tr>
<td>1094</td>
<td><code>Note Off</code></td>
<td>1</td>
<td>62 (D4)</td>
<td>0</td>
<td>结束音符</td>
</tr>
</tbody>
</table>
<p>这个深度追踪的例子展示了转换器不仅仅是简单的命令替换，而是一个真正理解音乐上下文、模拟硬件行为并智能生成富有表现力的MIDI事件的复杂系统。</p>
<h3 id="2-9">2.9. 终极稳定性：修复未知VGM命令导致的崩溃</h3>
<p>在项目基本功能完成并通过了大量测试后，我们遇到了一个由特定文件 <code>07_Matoya's_Cave.vgm</code> 引发的程序崩溃问题。这次的调试和修复，极大地提升了程序的稳定性和对各类VGM文件的兼容性。</p>
<ul>
<li>  <strong>挑战</strong>:</li>
</ul>
<p>    程序在处理 <code>07_Matoya's_Cave.vgm</code> 文件时，会直接崩溃退出，没有任何明确的错误信息。</p>
<ul>
<li>  <strong>攻克过程</strong>:</li>
</ul>
<ol>
<li> <strong>日志先行</strong>: 面对这种“沉默的崩溃”，我们再次祭出法宝——在 <code>main.cpp</code> 的 <code>process_vgm_data</code> 函数中添加详细的日志输出。我们让程序在处理每个VGM命令前，都打印出当前的文件指针位置和正在处理的命令字节。</li>
<li> <strong>定位根源</strong>: 通过分析输出的 <code>log.txt</code> 文件，我们发现程序在处理到某个特定位置后，日志就中断了。查看该位置对应的VGM命令，我们发现是一个未在 <code>switch</code> 语句中明确处理的命令。问题就出在 <code>default</code> 分支的逻辑上：它仅仅将文件指针 <code>i</code> 递增了 <code>1</code>。</li>
<li> <strong>分析错误</strong>: VGM 格式中，许多命令都带有参数。例如，命令 <code>0x4f dd</code> 需要跳过1个字节的参数，而命令 <code>0x52 aa dd</code> 则需要跳过2个字节的参数。我们之前的 <code>default</code> 逻辑在遇到这些未知命令时，只跳过了命令本身，而没有跳过其后的参数字节。这导致程序将本应是参数的字节误读为下一个命令，从而引发连锁反应，最终导致解析逻辑彻底错乱并崩溃。</li>
</ol>
<ul>
<li>  <strong>最终修复：完善命令处理</strong></li>
</ul>
<p>    我们没有简单地忽略这些命令，而是查阅了VGM格式规范，并对 <code>main.cpp</code> 中的 <code>process_vgm_data</code> 函数进行了扩展，为其 <code>switch</code> 语句添加了对一系列之前未处理命令的“跳过”逻辑。这确保了即使我们当前不需要利用这些命令的功能，解析器也能正确地越过它们及其参数，保持文件指针的同步。</p>
<p>    <strong>新增处理的VGM命令包括：</strong></p>
<table>
<thead>
<tr>
<th>VGM 命令 (Hex)</th>
<th>长度 (字节)</th>
<th>处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x4f</code></td>
<td>2</td>
<td>跳过 (命令 + 1字节数据)</td>
</tr>
<tr>
<td><code>0x51</code> - <code>0x5f</code></td>
<td>3</td>
<td>跳过 (命令 + 2字节数据)</td>
</tr>
<tr>
<td><code>0xa0</code></td>
<td>3</td>
<td>跳过 (命令 + 2字节数据)</td>
</tr>
<tr>
<td><code>0xb0</code> - <code>0xbf</code></td>
<td>3</td>
<td>跳过 (命令 + 2字节数据)</td>
</tr>
<tr>
<td><code>0xc0</code> - <code>0xdf</code></td>
<td>4</td>
<td>跳过 (命令 + 3字节数据)</td>
</tr>
<tr>
<td><code>0xe0</code> - <code>0xff</code></td>
<td>5</td>
<td>跳过 (命令 + 4字节数据)</td>
</tr>
</tbody>
</table>
<p>    通过为这些命令添加正确的 <code>case</code> 分支并增加相应的文件指针偏移量，我们彻底解决了这个崩溃问题。这次修复使得转换器变得更加健壮，能够兼容更多不完全符合我们预期的、但语法正确的VGM文件。</p>
<h3 id="2-10">2.10. 智能乐器系统：<code>instruments.ini</code></h3>
<p>为了解决 WonderSwan 自定义波形到 MIDI 乐器的映射问题，并给予用户最终的控制权，我们引入了一个全新的智能乐器配置系统。该系统的核心是 <code>instruments.ini</code> 文件。</p>
<p><strong>核心特性：</strong></p>
<ul>
<li>  <strong>自动发现与注册</strong>: 当转换器在 VGM 文件中遇到一个它从未见过的波形时，它会：</li>
</ul>
<ol>
<li> 为该波形生成一个唯一的 <strong>32字节指纹</strong> (fingerprint)。</li>
<li> 根据波形数据的特征，为其自动分配一个最合适的默认 MIDI 乐器。</li>
<li> 为其生成一个独一无二的名称，如 <code>CustomWave_1</code>。</li>
<li> 记录下发现该波形的 <strong>来源</strong> (<code>source</code>)，即当前处理的 VGM 文件名。</li>
<li> 记录下注册的 <strong>时间戳</strong> (<code>registered_at</code>)。</li>
<li> 将以上所有信息，连同一个 ASCII 字符画的 <strong>波形图</strong> (<code>graph</code>)，作为一个新条目写入 <code>instruments.ini</code> 文件。</li>
</ol>
<ul>
<li>  <strong>用户可配置</strong>: <code>instruments.ini</code> 是一个纯文本文件，您可以随时用任何文本编辑器打开它。如果您对某个波形自动分配的 MIDI 乐器不满意，只需找到对应的条目（例如 <code>[CustomWave_1]</code>），然后<strong>手动修改 <code>midi_instrument =</code> 后面的数字</strong>即可。在下一次转换时，程序会读取您的修改，并使用您指定的乐器。</li>
</ul>
<ul>
<li>  <strong>内置波形支持</strong>: 首次运行时，<code>instruments.ini</code> 会被自动创建，并预先填入 WonderSwan 的5个内置波形，确保了基础音色的准确性。</li>
</ul>
<p><strong><code>instruments.ini</code> 文件结构示例：</strong></p>
<pre><code class="language-ini">[CustomWave_1]
fingerprint = 00010102...
midi_instrument = 80
source = 17_Battle.vgm
registered_at = 2025-09-23 19:33:12
graph =
;                                █
;                              ███
...
</code></pre>
<p><strong>内置波形图参考：</strong></p>
<p>以下是 WonderSwan 内置的几个核心波形及其在 <code>instruments.ini</code> 中对应的 ASCII 图，这有助于您直观地理解不同波形的外观。</p>
<ul>
<li>  <strong>脉冲波 (PULSE)</strong></li>
</ul>
<pre><code class="language- ```">    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████                
    ; ████████████████████████████████
</code></pre>
<ul>
<li>  <strong>三角波 (WAVE_BUILTIN_1)</strong></li>
</ul>
<pre><code class="language- ```">    ;                ██               
    ;               ████              
    ;              ██████             
    ;             ████████            
    ;            ██████████           
    ;           ████████████          
    ;          ██████████████         
    ;         ████████████████        
    ;        ██████████████████       
    ;       ████████████████████      
    ;      ██████████████████████     
    ;     ████████████████████████    
    ;    ██████████████████████████   
    ;   ████████████████████████████  
    ;  ██████████████████████████████ 
    ; ████████████████████████████████
</code></pre>
<ul>
<li>  <strong>锯齿波 (WAVE_BUILTIN_3)</strong></li>
</ul>
<pre><code class="language- ```">    ; █                              █
    ; ██                            ██
    ; ███                          ███
    ; ████                        ████
    ; █████                      █████
    ; ██████                    ██████
    ; ███████                  ███████
    ; ████████                ████████
    ; █████████              █████████
    ; ██████████            ██████████
    ; ███████████          ███████████
    ; ████████████        ████████████
    ; █████████████      █████████████
    ; ██████████████    ██████████████
    ; ███████████████  ███████████████
    ; ████████████████████████████████
</code></pre>
<ul>
<li>  <strong>噪声 (NOISE)</strong></li>
</ul>
<pre><code class="language- ```">    ;   █               █             
    ;   █            █  █            █
    ;   █       █    █  █       █    █
    ;   █ █     █    █  █ █     █    █
    ;   █ █   █ █    █  █ █   █ █    █
    ;   █ █   █ █  █ █  █ █   █ █  █ █
    ;   █ ██  █ █  █ █  █ ██  █ █  █ █
    ; █ █ ██  █ █  █ ██ █ ██  █ █  █ █
    ; █ █ ██ ██ █  █ ██ █ ██ ██ █  █ █
    ; █ █ ██ ██ █ ██ ██ █ ██ ██ █ ██ █
    ; █ ████ ██ █ ██ ██ ████ ██ █ ██ █
    ; █ ████ ████ ██ ██ ████ ████ ██ █
    ; █ ████ ████ █████ ████ ████ ████
    ; ██████ ████ ██████████ ████ ████
    ; ██████ ███████████████ █████████
    ; ████████████████████████████████
</code></pre>
<p>这个系统将波形识别的自动化与用户手动配置的灵活性完美结合，是本项目在可用性和用户体验上的一个巨大飞跃。</p>
<h3 id="2-11">2.11. 捕捉音乐表现力：为颤音实现弯音轮</h3>
<p>尽管转换器已经非常精确，但它在表现一种最常见的音乐技巧——颤音（Vibrato）时存在局限。快速且幅度较大的频率振荡被错误地解读为一系列非常短的、离散的音符，听起来断断续续，很不自然。本节详细说明了我们如何通过实现 MIDI 弯音轮（Pitch Bend）来解决这个问题，从而实现了平滑且富有表现力的颤音效果。</p>
<ul>
<li>  <strong>挑战</strong>:</li>
</ul>
<p>    现有的逻辑将任何导致 MIDI 音高编号发生变化的频率 <code>period</code> 改变都视为一个新音符的触发器。这意味着程序会为旧音符发送一个 <code>Note Off</code>，并为新音符发送一个 <code>Note On</code>。对于像颤音这样的快速振荡，这会产生一种不希望出现的“机关枪”效果，而不是连续、摇曳的音高。</p>
<ul>
<li>  <strong>突破过程：从“重触发”到“弯曲”</strong>:</li>
</ul>
<p>    核心思想是改变状态机的哲学：不再问“这是一个新音符吗？”，而是开始问“这还是<em>同一个</em>音符，只是音高有轻微偏移吗？”。</p>
<ol>
<li> <strong>建立基准</strong>: 我们引入了一个新的状态变量 <code>channel_base_note_freq</code>，用于在音符被触发（<code>Note On</code>）的瞬间，储存该音符的初始频率。这个频率对应于音符的“真实”音高。</li>
</ol>
<ol>
<li> <strong>以“音分”计算偏差</strong>: 每当一个活动通道的频率 <code>period</code> 发生变化时，我们计算出新的频率。但我们不再立即将其转换为新的 MIDI 音高编号，而是将其与 <code>channel_base_note_freq</code> 进行比较。我们使用<strong>音分 (cents)</strong>（1个半音的1/100）这个对数单位来计算两者之间的差异，它非常适合衡量音乐的音高间隔。</li>
</ol>
<p>        <code>cents_deviation = 1200.0 * log2(current_freq / base_freq);</code></p>
<ol>
<li> <strong>颤音/新音符的阈值判断</strong>: 我们建立了一条清晰的规则：</li>
</ol>
<ul>
<li>  <strong>如果偏差在一个定义的范围内</strong>（例如 +/- 200 音分，即2个半音），则该变化被归类为颤音或小的滑音 (portamento)。</li>
<li>  <strong>如果偏差超过了这个范围</strong>，则它被归类为一次真正的、到新音符的跳跃。</li>
</ul>
<ol>
<li> <strong>生成弯音事件</strong>:</li>
</ol>
<ul>
<li>  对于在范围内的偏差，我们将 <code>cents_deviation</code> 转换为一个14位的 MIDI 弯音值（0-16383，其中8192为中心/无弯音）。</li>
<li>  这个值随后作为一个弯音消息被发送出去。如果频率持续变化，一系列这样的消息就会被发送，从而在最终的 MIDI 中形成一条平滑的音高曲线。</li>
<li>  为确保此功能正常工作，我们还在每个轨道的开头发送了 MIDI RPN (Registered Parameter Number) 消息，以将合成器的弯音敏感度设置为我们期望的范围（+/- 2个半音）。</li>
</ul>
<ol>
<li> <strong>处理音高跳跃</strong>: 当偏差超过阈值时，逻辑回退到旧的行为：它为当前音符发送一个 <code>Note Off</code>，并立即为新音符触发一个 <code>Note On</code>，从而正确地捕捉了乐谱中跳跃而不是弯音的意图。</li>
</ol>
<ul>
<li>  <strong>技术实现</strong>:</li>
<li>  在 <code>MidiTrack</code> 类中增加了一个新的 <code>add_pitch_bend</code> 方法。</li>
<li>  <code>WonderSwanChip</code> 中的 <code>check_state_and_update_midi</code> 函数被大幅重构，以整合上述新的基准频率跟踪、偏差计算和阈值判断逻辑。</li>
<li>  <code>Note On</code> 逻辑被更新，以确保在每次音符开始时都将弯音轮重置到中心位置（<code>8192</code>）并储存音符的基准频率，保证每个新音符都从一个干净的状态开始。</li>
</ul>
<p>这次实现成功地将之前听起来像机器人一样的音符切换，转变成了流畅、富有表现力的颤音，为转换器的输出增添了至关重要的音乐性。</p>
<h2 id="3">3. 深入解析 WonderSwan 声音系统</h2>
<p>为了完全理解转换过程，深入了解 WonderSwan 硬件本身的声音生成能力至关重要。本节将详细技术性地分解每种声音生成方法、控制它们的I/O寄存器，以及它们是如何通过VGM命令来表示的。</p>
<h3 id="3-1">3.1. 声音通道概览</h3>
<p>WonderSwan 的声音系统功能惊人地多样，拥有四个可配置不同角色的主通道，外加一个专用的PCM音频机制。</p>
<table>
<thead>
<tr>
<th>通道</th>
<th>主要功能</th>
<th>特殊能力</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>通道 1</strong></td>
<td>可编程音调</td>
<td>可通过声音DMA用于PCM播放</td>
</tr>
<tr>
<td><strong>通道 2</strong></td>
<td>可编程音调</td>
<td>硬件扫描（音高滑动）</td>
</tr>
<tr>
<td><strong>通道 3</strong></td>
<td>可编程音调</td>
<td>噪声生成</td>
</tr>
<tr>
<td><strong>通道 4</strong></td>
<td>可编程音调</td>
<td>(无)</td>
</tr>
</tbody>
</table>
<p>在VGM文件中，与这些声音功能的所有交互主要通过 <strong><code>0x51 aa dd</code></strong> 命令处理，该命令意为“将数据 <code>dd</code> 写入I/O端口 <code>aa</code>”。</p>
<h3 id="3-2">3.2. 四个主要音频通道（可编程音调）</h3>
<p>这四个通道是 WonderSwan 音乐的支柱，负责生成旋律、和声和贝斯线。它们在音高、音量和波形选择上共享一个通用架构。</p>
<h4 id="3-2-1">3.2.1. 音高控制</h4>
<ul>
<li>  <strong>功能</strong>: 设置要播放音符的频率。</li>
<li>  <strong>寄存器</strong>: 每个通道使用一对8位寄存器来定义一个11位的频率周期值（从0到2047）。周期值越高，音高越低。</li>
<li>  通道 1: <code>0x80</code> (低位字节), <code>0x81</code> (高位字节)</li>
<li>  通道 2: <code>0x82</code> (低位字节), <code>0x83</code> (高位字节)</li>
<li>  通道 3: <code>0x84</code> (低位字节), <code>0x85</code> (高位字节)</li>
<li>  通道 4: <code>0x86</code> (低位字节), <code>0x87</code> (高位字节)</li>
<li>  <strong>VGM 示例</strong>: 要将通道2的周期设置为 <code>0x06B0</code>:</li>
<li>  <code>51 82 B0</code> (将 <code>0xB0</code> 写入低位字节寄存器)</li>
<li>  <code>51 83 06</code> (将 <code>0x06</code> 写入高位字节寄存器)</li>
<li>  <strong>转换逻辑</strong>: 转换器读取这些周期值，并使用公式 <code>freq = (3072000 / (2048 - period)) / 32</code> 来计算可听频率，然后将其转换为MIDI音高编号。</li>
</ul>
<h4 id="3-2-2">3.2.2. 音量与声相控制</h4>
<ul>
<li>  <strong>功能</strong>: 为每个通道独立设置左、右扬声器的音量。这允许进行整体音量控制和立体声声相效果。</li>
<li>  <strong>寄存器</strong>: 每个通道有一个8位寄存器，其中高4位控制左音量（0-15），低4位控制右音量（0-15）。</li>
<li>  通道 1: <code>0x88</code></li>
<li>  通道 2: <code>0x89</code></li>
<li>  通道 3: <code>0x8A</code></li>
<li>  通道 4: <code>0x8B</code></li>
<li>  <strong>VGM 示例</strong>: 要将通道2的左音量设为10 (<code>0xA</code>)，右音量设为15 (<code>0xF</code>):</li>
<li>  <code>51 89 AF</code> (将 <code>0xAF</code> 写入音量寄存器)</li>
<li>  <strong>转换逻辑</strong>:</li>
<li>  转换器读取左、右音量。两者中较高的一个用于计算整体的音符表情（MIDI CC#11）。</li>
<li>  左、右音量之间的比率用于计算立体声声相位置（MIDI CC#10）。</li>
</ul>
<h4 id="3-2-3">3.2.3. 波形选择与内存</h4>
<ul>
<li>  <strong>功能</strong>: 这是最独特的功能。WonderSwan的四个通道不是使用固定的波形（如方波、正弦波），而是直接从一块共享的内部RAM中读取它们的波形数据。这允许使用自定义的、动态的音色。</li>
<li>  <strong>内存布局</strong>: 声音芯片使用一块 <strong>2 KB大小的内部RAM（从地址 <code>0x0000</code> 到 <code>0x07FF</code>）</strong> 作为其波形内存。这块RAM被组织成128个插槽，每个插槽存放一个16字节的波形。</li>
<li>  <strong>寄存器</strong>:</li>
<li>  <strong>波形基地址 (<code>0x8F</code>)</strong>: 这个关键寄存器的值（乘以64）指向RAM中四个通道将寻找其波形数据的起始地址。例如，如果 <code>0x8F</code> 被设为 <code>2</code>，则波形数据从RAM的 <code>2 * 64 = 128</code> (<code>0x0080</code>) 地址开始。</li>
<li>  <strong>通道波形指针</strong>: 每个通道从相对于此基地址的特定偏移量处读取其16字节的波形：</li>
<li>  通道 1: <code>基地址 + 0</code></li>
<li>  通道 2: <code>基地址 + 16</code></li>
<li>  通道 3: <code>基地址 + 32</code></li>
<li>  通道 4: <code>基地址 + 48</code></li>
<li>  <strong>VGM 命令</strong>: 要创建一个自定义声音，游戏的音乐引擎首先将波形数据写入RAM。这是通过 <strong>声音DMA（直接内存访问）</strong> 机制完成的，它不能由简单的VGM端口写入直接表示。在VGM文件中，这种波形数据的预加载通常通过 <strong><code>0x67</code> (数据块)</strong> 命令后跟一系列RAM写入命令来完成。然而，对于我们的转换器来说，我们关注的是RAM加载<em>之后</em>发生的事情。</li>
<li>  <strong>转换逻辑 (<code>instruments.ini</code> 系统)</strong>:</li>
</ul>
<ol>
<li> 当一个通道上的音符被触发时，转换器读取寄存器 <code>0x8F</code> 的值以找到波形基地址。</li>
<li> 它计算该通道特定的16字节内存区域。</li>
<li> 它从其模拟的 <code>internal_ram</code> 中读取这16个字节。每个字节包含两个4位采样，因此它将其解包成一个32个采样的波形。</li>
<li> 这个32采样的数据成为该波形唯一的“指纹”。</li>
<li> 转换器在 <code>instruments.ini</code> 中查找此指纹。如果找到，它将使用用户指定的MIDI乐器。如果未找到，它会将其注册为一个新的自定义波形，并分配一个默认乐器。</li>
</ol>
<h4 id="3-2-4">3.2.4. 通道激活</h4>
<ul>
<li>  <strong>功能</strong>: 一个主开关，用于打开或关闭四个通道中的每一个。</li>
<li>  <strong>寄存器</strong>: <code>0x90</code> (通道启用寄存器)</li>
<li>  <strong>位</strong>:</li>
<li>  位 0: 启用通道 1</li>
<li>  位 1: 启用通道 2</li>
<li>  位 2: 启用通道 3</li>
<li>  位 3: 启用通道 4</li>
<li>  <strong>VGM 示例</strong>: 要启用通道2并禁用所有其他通道:</li>
<li>  <code>51 90 02</code> (将 <code>0b00000010</code> 写入端口 <code>0x90</code>)</li>
<li>  <strong>转换逻辑</strong>: 该寄存器是 <code>Note On</code> 和 <code>Note Off</code> 事件的主要触发器。当一个通道的位被设为1且其音量大于0时，会生成一个 <code>Note On</code>。当该位被清除为0时，会生成一个 <code>Note Off</code>。</li>
</ul>
<h3 id="3-3">3.3. 特殊通道功能</h3>
<p>一些通道除了基本的音调生成外，还具有独特的硬件功能。</p>
<h4 id="3-3-1">3.3.1. 硬件扫描 (通道 2)</h4>
<ul>
<li>  <strong>功能</strong>: 通道2具有硬件“扫描”功能，可以自动并周期性地调整通道的频率周期。这通常用于创建音高滑动效果、琶音或其他简单的调制，而无需CPU手动写入新的频率值。</li>
<li>  <strong>寄存器</strong>:</li>
<li>  <strong>扫描步长 (<code>0x8C</code>)</strong>: 一个8位有符号值，决定在每个扫描间隔加到通道周期值上的量。正值降低音高，负值提高音高。</li>
<li>  <strong>扫描时间 (<code>0x8D</code>)</strong>: 一个8位值，设置每个扫描步长之间的时间间隔。实际时间基于系统的水平消隐率计算。</li>
<li>  <strong>扫描启用 (在 <code>0x90</code> 中)</strong>: 通道启用寄存器 (<code>0x90</code>) 的位6作为通道2扫描功能的主开关。</li>
<li>  <strong>VGM 示例</strong>: 要在通道2上创建一个缓慢的向上音高滑动：</li>
<li>  <code>51 8C E0</code> (设置扫描步长为-32，一个负值以提高音高)</li>
<li>  <code>51 8D 10</code> (设置一个相对较长的步间间隔)</li>
<li>  <code>51 90 42</code> (通过位1启用通道2，并通过位6启用扫描)</li>
<li class="toc-level-1">  <strong>转换逻辑</strong>: 转换器完全模拟此行为。<code>process_sweep</code> 函数随每次时间推进而被调用。它维护一个 <code>sweep_count</code> 计时器。当计时器到期时，它将 <code>sweep_step</code> 值加到 <code>channel_periods[2]</code> 并重置计时器。<code>check_state_and_update_midi</code> 会检测到周期的这种变化，并相应地生成MIDI弯音事件，从而精确地再现滑动效果。</li>
</ul>
<h4 id="3-3-2">3.3.2. 噪声生成 (通道 3)</h4>
<ul>
<li>  <strong>功能</strong>: 通道3可以从普通的音调生成器切换为噪声生成器，这对于创建打击乐声音（如鼓、钹）或音效（如爆炸声）至关重要。</li>
<li>  <strong>寄存器</strong>:</li>
<li>  <strong>噪声控制 (<code>0x8E</code>)</strong>: 此寄存器控制噪声的类型。低3位（0-2）选择七种不同的噪声模式之一，这可能对应于不同的线性反馈移位寄存器（LFSR）配置，产生不同的噪声音色（例如，更具金属性 vs. 更“白”的噪声）。位3是一个复位标志。</li>
<li>  <strong>噪声启用 (在 <code>0x90</code> 中)</strong>: 通道启用寄存器 (<code>0x90</code>) 的位7是专门用于将通道3切换到噪声生成的主开关。当此位被设置时，通道3会忽略其波形和频率设置，转而输出噪声。</li>
<li>  <strong>VGM 示例</strong>: 要在通道3上播放标准的噪声声音：</li>
<li>  <code>51 8E 07</code> (选择噪声模式7)</li>
<li>  <code>51 90 88</code> (通过位3启用通道3，并通过位7启用噪声模式)</li>
<li class="toc-level-1">  <strong>转换逻辑</strong>: 当转换器检测到端口 <code>0x90</code> 的位7被激活时，它会将 <code>channel_is_noise[3]</code> 标记为true。在 <code>check_state_and_update_midi</code> 中，如果此标志被设置，它将覆盖正常的乐器选择，并分配一个打击乐MIDI乐器（例如 <code>127: Gunshot</code> 或 <code>instruments.ini</code> 中用户定义的鼓声）。噪声的音高在MIDI转换中通常是固定的或被忽略，因为其音色是最重要的特性。</li>
</ul>
<h4 id="3-3-3">3.3.3. 通过声音DMA播放PCM音频 (通道 1)</h4>
<ul>
<li>  <strong>功能</strong>: 这是最先进的声音功能。WonderSwan可以直接从RAM中播放原始的4位PCM音频采样。这用于复杂的声音效果、语音片段或无法由其他通道合成的高质量鼓声。此功能与通道1绑定，并使用声音DMA（直接内存访问）控制器。</li>
<li>  <strong>机制</strong>: CPU不是手动馈送采样数据，而是为DMA控制器配置一个起始地址和长度，然后硬件以指定的速率自动将数据从RAM流式传输到音频输出，并劫持通道1的音量控制。</li>
<li>  <strong>寄存器</strong>:</li>
<li>  <strong>DMA源地址 (<code>0x4A</code>, <code>0x4B</code>, <code>0x4C</code>)</strong>: 三个寄存器组合成一个24位地址，指向RAM中PCM采样数据的起始位置。</li>
<li>  <strong>DMA计数 (<code>0x4E</code>, <code>0x4F</code>)</strong>: 两个寄存器形成一个16位值，指示要播放的采样数量。</li>
<li>  <strong>DMA控制 (<code>0x52</code>)</strong>: 此寄存器控制DMA过程。位7启动或停止DMA，位0-1控制播放速率。</li>
<li>  <strong>PCM启用 (在 <code>0x90</code> 中)</strong>: 通道启用寄存器 (<code>0x90</code>) 的位5启用PCM输出。</li>
<li>  <strong>PCM直接音量 (<code>0x94</code>)</strong>: 一个专用于PCM播放的独立音量控制寄存器，绕过通道1的正常音量寄存器(<code>0x88</code>)。</li>
<li>  <strong>VGM 命令</strong>: VGM文件中的典型PCM播放序列包括：</li>
</ul>
<ol>
<li> 将采样数据写入RAM（通常通过 <code>0x67</code> 数据块）。</li>
<li> <code>51 4A..4C ..</code> (设置DMA源地址)。</li>
<li> <code>51 4E..4F ..</code> (设置DMA采样计数)。</li>
<li> <code>51 52 ..</code> (设置DMA速率并开始传输)。</li>
<li> <code>51 90 20</code> (启用PCM输出模式)。</li>
</ol>
<ul>
<li>  <strong>转换逻辑</strong>: 转换器模拟声音DMA过程。<code>process_s_dma</code> 函数随每次时间推进而被调用。它维护一个 <code>s_dma_timer</code>。当计时器到期时，它模拟硬件从其模拟RAM中的 <code>s_dma_source_addr</code> 获取一个字节的数据。然后将此字节写入端口 <code>0x89</code>（通道2的音量寄存器，一个硬件怪癖），并更新DMA计数器。<code>check_state_and_update_midi</code> 函数检测到PCM模式处于活动状态（通过端口 <code>0x90</code> 的位5），并将来自特殊PCM音量寄存器(<code>0x94</code>)的音量路由到通道1的MIDI输出，通常将其映射到一个鼓或基于采样的乐器。</li>
</ul>
<h2 id="4">4. 程序工作流程详解</h2>
<p><code>vgm_ws_to_mid</code> 的核心是一个状态机，它模拟 WonderSwan 声音芯片的行为，并将状态变化实时翻译为 MIDI 事件。</p>
<h3 id="4-1">4.1. 概览</h3>
<ol>
<li> <strong>读取 (Read)</strong>: <code>VgmReader</code> 负责加载整个VGM文件到内存中，并提供文件头信息（如循环偏移量、数据起始位置）的访问接口。</li>
<li> <strong>处理 (Process)</strong>: <code>main</code> 函数中的 <code>process_vgm_data</code> 是整个程序的核心驱动。它通过一个巨大的 <code>for</code> 循环遍历VGM数据块，并使用一个 <code>switch</code> 语句来分发处理每一个VGM命令：</li>
</ol>
<ul>
<li>  <strong><code>0x51 aa dd</code> (WonderSwan端口写入)</strong>: 将地址 <code>aa</code> 和数据 <code>dd</code> 传递给 <code>WonderSwanChip</code> 进行模拟。这是最核心的命令。</li>
<li>  <strong><code>0x61 nn nn</code> (等待)</strong>: 调用 <code>WonderSwanChip::advance_time</code>，将等待的采样数转换为MIDI ticks，推进时间轴。</li>
<li>  <strong><code>0x62</code> (等待735个采样)</strong>: 同上，但为固定值。</li>
<li>  <strong><code>0x63</code> (等待882个采样)</strong>: 同上，但为固定值。</li>
<li>  <strong><code>0x7n</code> (等待 n+1 个采样)</strong>: 同上，为短时等待。</li>
<li>  <strong><code>0x66</code> (数据块结束)</strong>: 标志着VGM数据流的正常结束，循环终止。</li>
<li>  <strong>其他已识别命令 (如 <code>0x4f</code>, <code>0x52-0x5f</code>, <code>0xa0</code> 等)</strong>: 这些是其他芯片的命令或VGM的扩展功能。当前转换器不需要使用它们，但为了保证解析的连续性，程序会根据命令规范，正确地跳过这些命令及其参数，确保文件指针指向下一条有效命令。这是程序稳定性的关键。</li>
</ul>
<ol>
<li> <strong>模拟与翻译 (Simulate & Translate)</strong>: <code>WonderSwanChip</code> 接收端口写入数据，更新内部寄存器状态（如频率、音量）。每次更新后，它会调用 <code>check_state_and_update_midi</code> 函数，检查通道状态是否发生变化（如音符开关、音高变化、音量变化）。</li>
<li> <strong>生成 (Generate)</strong>: 如果检测到有意义的状态变化，<code>WonderSwanChip</code> 会调用 <code>MidiWriter</code> 生成相应的 MIDI 事件（Note On/Off, Control Change），并附上当前精确的 MIDI tick 时间。</li>
<li> <strong>循环 (Loop)</strong>: 在处理完整个 VGM 文件后，如果检测到了循环点，<code>main</code> 函数会指示 <code>MidiWriter</code> 将记录下来的循环部分的 MIDI 事件复制一份，并附加到每个轨道的末尾，从而实现无缝循环。</li>
<li> <strong>写入 (Write)</strong>: 所有 VGM 命令处理完毕后，<code>MidiWriter</code> 将所有生成的事件（包括复制的循环部分）组装成一个标准的 MIDI 文件并保存到磁盘。</li>
</ol>
<h3 id="4-2">4.2. 关键组件</h3>
<ul>
<li>  <strong><code>main.cpp</code></strong>: 程序入口和总控制器。负责解析命令行参数，实例化 <code>VgmReader</code>, <code>MidiWriter</code>, 和 <code>WonderSwanChip</code>。其核心是 <code>process_vgm_data</code> 函数，该函数包含一个大型 <code>switch</code> 语句，作为VGM命令的“分发中心”，驱动整个转换流程，并实现循环逻辑。</li>
<li>  <strong><code>VgmReader.h/.cpp</code></strong>: VGM 文件加载器。它负责将VGM文件完整读入内存，并解析文件头（Header）以提取关键的元数据，如数据起始偏移量 (<code>0x34</code>) 和循环偏移量 (<code>0x1C</code>)。</li>
<li>  <strong><code>WonderSwanChip.h/.cpp</code></strong>: <strong>转换核心</strong>。</li>
<li>  内部维护一个 <code>io_ram</code> 数组来模拟芯片的 256 个 I/O 寄存器。</li>
<li>  <code>write_port()</code> 方法是关键入口，它根据写入的端口地址更新内部状态变量（如 <code>channel_periods</code>, <code>channel_volumes_left</code> 等）。</li>
<li>  <code>check_state_and_update_midi()</code> 是状态机的大脑。每次状态更新后，它会比较当前状态和上一状态，判断是否需要生成 MIDI 事件，从而智能地处理连奏（pitch bend）、重触发（re-trigger）和音量包络。它现在还会调用 <code>InstrumentConfig</code> 来获取或创建乐器。</li>
<li>  新增了 <code>get_channel_count()</code> 方法，用于动态返回芯片管理的音轨总数，解决了硬编码导致的越界访问问题。</li>
<li>  <strong><code>MidiWriter.h/.cpp</code></strong>: MIDI 文件生成器。它经过了重大重构，现在内部使用 <code>std::vector<MidiEvent></code> 来存储结构化的 MIDI 事件，而不是原始字节。这使得对事件的精确操作成为可能。它提供了一系列简单的 API（如 <code>add_note_on</code>, <code>add_control_change</code>）来构建轨道，并新增了 <code>copy_events_from</code> 方法，可以高效地从一个时间点复制事件到另一个时间点，这是实现无缝循环的关键。该方法现在还内置了逻辑，用于自动关闭在循环块边界处未闭合的音符。当转换结束时，<code>write_to_file()</code> 方法会动态地将事件列表序列化为标准的 MIDI 文件。</li>
<li>  <strong><code>InstrumentConfig.h/.cpp</code></strong>: <strong>智能乐器配置系统</strong>。这是最新的核心组件，负责管理 <code>instruments.ini</code> 文件。它实现了波形的自动发现、指纹生成、相似度比较和自动注册。它还负责加载用户的自定义乐器设置，并将最终确定的 MIDI 乐器编号提供给 <code>WonderSwanChip</code>。</li>
<li>  <strong><code>UsageLogger.h/.cpp</code></strong>: <strong>日志记录器</strong>。负责生成 <code>conversion_log.txt</code> 文件。它会报告本次转换中新注册的所有乐器，并按通道详细列出每个波形的使用频率，为用户提供了详尽的转换过程报告。</li>
</ul>
<h3 id="4-3">4.3. 关键公式与常量</h3>
<ul>
<li>  <strong>时序转换</strong>:</li>
</ul>
<p>    <code>const double SAMPLES_TO_TICKS = (480.0 <em> 120.0) / (44100.0 </em> 60.0);</code></p>
<ul>
<li>  <strong>音高转换</strong>:</li>
</ul>
<p>    <code>double freq = (3072000.0 / (2048.0 - period)) / 32.0;</code></p>
<p>    <code>int note = static_cast<int>(round(69 + 12 * log2(freq / 440.0)));</code></p>
<ul>
<li>  <strong>音量映射</strong>:</li>
</ul>
<p>    <code>double normalized_vol = vgm_vol / 15.0;</code></p>
<p>    <code>double curved_vol = pow(normalized_vol, 0.3);</code></p>
<p>    <code>int velocity = static_cast<int>(curved_vol * 127.0);</code></p>
<h3 id="4-4">4.4. 转换日志 (<code>conversion_log.txt</code>)</h3>
<p>为了最大化转换过程的透明度并提供深入的洞察，程序每次运行时都会生成一个名为 <code>conversion_log.txt</code> 的详细日志文件。该文件主要有两个目的：</p>
<ol>
<li> <strong>报告新发现</strong>: 它会明确列出在转换过程中于VGM文件中发现的任何新的自定义波形，以及为它们分配的默认MIDI乐器。这使得用户可以轻松识别哪些新条目已被添加到 <code>instruments.ini</code> 文件中，以便进行后续的自定义。</li>
<li> <strong>提供使用统计</strong>: 它详细地分类列出了WonderSwan的四个主要声音通道分别使用了哪些波形，以及使用的频率。这些数据对于理解特定乐曲的声音设计非常有价值。</li>
</ol>
<p><strong><code>conversion_log.txt</code> 示例:</strong></p>
<pre><code class="language-">--- Conversion Log ---
VGM File: 17_Battle.vgm
Timestamp: 2025-09-23 20:15:00

--- New Instruments Registered ---
A new instrument profile has been created and saved to instruments.ini:
[CustomWave_1]
- Fingerprint: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
- Assigned MIDI Instrument: 80 (Synth Lead)
- Source VGM: 17_Battle.vgm

--- Waveform Usage Statistics ---

Channel 1:
- WAVE_BUILTIN_1 (Triangle): 125 times
- CustomWave_1: 88 times

Channel 2:
- WAVE_BUILTIN_1 (Triangle): 210 times

Channel 3:
- PULSE: 340 times

Channel 4:
- NOISE: 56 times

--- End of Log ---
</code></pre>
<p>这个部分为转换过程提供了一个清晰的、由数据驱动的总结，弥合了原始VGM输入和最终MIDI输出之间的信息鸿沟。</p>
<h2 id="5">5. 使用方法</h2>
<p>转换器支持多种命令行参数，以提供灵活的文件转换和乐器管理方式。</p>
<h3 id="5-1">5.1. 单文件转换</h3>
<p>这是最基本的使用模式。您需要提供一个输入的VGM文件，并指定期望的输出MIDI文件名。</p>
<p><strong>语法:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe &lt;input.vgm&gt; &lt;output.mid&gt;
</code></pre>
<p><strong>示例:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe 04_Theme_of_Love.vgm 04_Theme_of_Love.mid
</code></pre>
<h3 id="5-2">5.2. 批量转换 (<code>-b</code>)</h3>
<p>此模式允许您一次性转换当前目录下的所有 <code>.vgm</code> 文件。对于每一个 <code>input.vgm</code>，程序将自动在同一目录下创建一个对应的 <code>input.mid</code> 文件。</p>
<p><strong>语法:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe -b
</code></pre>
<h3 id="5-3">5.3. 乐器排序 (<code>-s</code>)</h3>
<p>这是一个实用工具模式，用于对 <code>instruments.ini</code> 文件进行排序。排序基于波形的相似度，将视觉和结构上相似的波形分组在一起。这使得手动审查和管理自定义乐器变得更加容易。</p>
<p><strong>语法:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe -s
</code></pre>
<h3 id="5-4">5.4. 指定循环次数 (<code>-l</code>)</h3>
<p><code>-l</code> 选项允许您控制VGM文件中的循环部分在最终的MIDI文件中播放多少次。默认值为2次循环。此选项可以与单文件转换或批量转换模式结合使用。</p>
<p><strong>语法:</strong></p>
<pre><code class="language-bash">vgm_ws_to_mid/vgm2mid.exe -l &lt;循环次数&gt; &lt;input.vgm&gt; &lt;output.mid&gt;
vgm_ws_to_mid/vgm2mid.exe -l &lt;循环次数&gt; -b
</code></pre>
<p><strong>示例:</strong></p>
<pre><code class="language-bash"># 转换单个文件并循环4次
vgm_ws_to_mid/vgm2mid.exe -l 4 04_Theme_of_Love.vgm 04_Theme_of_Love.mid

# 批量转换所有文件，并且每个文件都不循环（即只播放一次）
vgm_ws_to_mid/vgm2mid.exe -l 0 -b
</code></pre>
<h2 id="6">6. 如何编译与运行</h2>
<p>本项目使用 g++ 编译器在 bash 环境下进行编译。</p>
<ul>
<li>  <strong>编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/vgm2mid.exe vgm_ws_to_mid/main.cpp vgm_ws_to_mid/VgmReader.cpp vgm_ws_to_mid/WonderSwanChip.cpp vgm_ws_to_mid/MidiWriter.cpp vgm_ws_to_mid/InstrumentConfig.cpp vgm_ws_to_mid/UsageLogger.cpp vgm_ws_to_mid/WaveformInfo.cpp -lstdc++fs
</code></pre>
<ul>
<li>  <strong>运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/vgm2mid.exe [input_vgm_file] [output_mid_file]
</code></pre>
<p>    例如:</p>
<pre><code class="language- ```bash">    vgm_ws_to_mid/vgm2mid.exe 02_Prelude.vgm vgm_ws_to_mid/output.mid
</code></pre>
<h2 id="7">7. 辅助工具</h2>
<p>在本项目开发过程中，我们创建了几个小而强大的辅助工具，用于协助调试、验证和文档编写。这些工具对于达成高质量的最终结果至关重要。</p>
<h3 id="7-1">7.1. MIDI 验证器 (<code>midi_validator.exe</code>)</h3>
<p>这可以说是整个项目中最重要的工具。它是一个定制的MIDI文件解析器和分析器，能够深入洞察生成的输出文件。</p>
<ul>
<li>  <strong>功能</strong>:</li>
</ul>
<ol>
<li> <strong>事件日志</strong>: 它按时间顺序列出MIDI文件中的每一个事件（如音符开、音符关、控制器变更、弯音轮等），并显示其精确的tick时间、通道和数据值。这对于验证时序、音高、音量和声相逻辑非常有价值。</li>
<li> <strong>挂起音符检测</strong>: 其最关键的特性是能够检测“挂起音符”——即那些有 <code>Note On</code> 事件但从未被相应的 <code>Note Off</code> 事件正确终止的音符。这在解决“音符卡死”的bug时起到了决定性作用，特别是与循环边界相关的那些。</li>
</ol>
<ul>
<li>  <strong>如何编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/midi_validator.exe vgm_ws_to_mid/midi_validator.cpp
</code></pre>
<ul>
<li>  <strong>如何运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/midi_validator.exe &lt;midi_file&gt;
</code></pre>
<h3 id="7-2">7.2. 专用VGM命令转储器 (<code>simple_hex_dump.exe</code>)</h3>
<p>虽然通用的十六进制编辑器很有用，但我们创建这个工具是为了提供一个更聚焦于我们正在处理的VGM文件的视图。</p>
<ul>
<li>  <strong>功能</strong>: 该工具不是转储整个文件，而是专门解析VGM文件，并只打印与WonderSwan相关的命令，如 <code>0xbc</code> (端口写入) 和 <code>0xc6</code> (RAM写入)，以及它们的地址和值。它智能地跳过不太相关的数据，为VGM流中的关键事件提供了一个干净、高层次的日志。这对于快速理解一首歌曲的结构而不迷失在原始十六进制数据中非常有帮助。</li>
<li>  <strong>如何编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/simple_hex_dump.exe vgm_ws_to_mid/simple_hex_dump.cpp
</code></pre>
<ul>
<li>  <strong>如何运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/simple_hex_dump.exe &lt;input.vgm&gt;
</code></pre>
<h3 id="7-3">7.3. 通用十六进制转储器 (<code>hex_dumper.exe</code>)</h3>
<p>这是一个更传统的文件分析工具。</p>
<ul>
<li>  <strong>功能</strong>: 它读取任何给定的文件，并以经典的十六进制转储格式打印其内容，将十六进制值与其ASCII表示并排显示。当专用转储器不足以满足需求时，我们用它来进行文件的底层逐字节检查。</li>
<li>  <strong>如何编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/hex_dumper.exe vgm_ws_to_mid/hex_dumper.cpp
</code></pre>
<ul>
<li>  <strong>如何运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/hex_dumper.exe &lt;filename&gt;
</code></pre>
<h3 id="7-4">7.4. Markdown 到 HTML 转换器 (<code>markdown_to_html.exe</code>)</h3>
<p>本文档本身是用Markdown编写的。我们创建了这个工具来自动将 <code>.md</code> 文件转换为带有样式的、易于阅读的HTML文件。</p>
<ul>
<li>  <strong>功能</strong>: 这是一个轻量级的转换器，支持如标题、列表、代码块、表格和内联格式等基本的Markdown功能。它将转换后的内容包装在一个带有简洁、现代CSS样式的基本HTML5模板中，使文档既美观又易于导航。</li>
<li>  <strong>如何编译</strong>:</li>
</ul>
<pre><code class="language- ```bash">    g++ -std=c++17 -o vgm_ws_to_mid/markdown_to_html.exe vgm_ws_to_mid/markdown_to_html.cpp
</code></pre>
<ul>
<li>  <strong>如何运行</strong>:</li>
</ul>
<pre><code class="language- ```bash">    vgm_ws_to_mid/markdown_to_html.exe &lt;input.md&gt; &lt;output.html&gt;
</code></pre>
<hr>
<p>这份文档全面总结了我们的工作。希望它能为后续的开发和维护提供清晰的指引。</p>
<h2 id="8">8. 项目背景</h2>
<h3 id="8-1">8.1. 致谢</h3>
<p>本项目是我们精诚合作的成果：</p>
<ul>
<li>  <strong>Denjhang</strong>: 负责声音测试，并对输出结果提供关键反馈。</li>
<li>  <strong>Cline</strong>: 负责根据反馈进行编程、调试和实现转换逻辑。</li>
</ul>
<h3 id="8-2">8.2. 参考</h3>
<p>本项目站在巨人的肩膀上，其成功源于对两个关键开源项目的借鉴与整合。以下详细说明了转换器的不同部分分别受到了哪些源文件的启发。</p>
<h4 id="8-2-1">8.2.1. <code>libvgm</code></h4>
<p><code>libvgm</code> 是本项目的基石，它为解析VGM文件格式本身提供了核心逻辑。没有 <code>libvgm</code>，读取和解释原始VGM数据流将是一项几乎不可能完成的任务。</p>
<ul>
<li>  <strong>核心贡献</strong>: VGM文件解析与命令分发。</li>
<li>  <strong>关键源文件</strong>: <code>libvgm/player/vgmplayer.cpp</code></li>
<li>  <strong>如何使用</strong>: 我们 <code>main.cpp</code> 中的主 <code>switch</code> 语句是 <code>vgmplayer.cpp</code> 中命令处理循环的直接改编。我们研究了 <code>libvgm</code> 如何处理不同的VGM命令（例如 <code>0x61</code>, <code>0x62</code>, <code>0x66</code>, <code>0x51</code>）并复制了该结构。这包括：</li>
<li>  根据命令长度推进文件指针的逻辑。</li>
<li>  处理等待命令（<code>0x61</code>, <code>0x62</code>, <code>0x63</code>, <code>0x7n</code>）的逻辑，这构成了我们时序系统的基础。</li>
<li>  对未使用或不支持的VGM命令的正确“跳过”逻辑，这对于确保解析器的稳定性至关重要（如2.9节所述）。</li>
</ul>
<h4 id="8-2-2">8.2.2. <code>modizer</code></h4>
<p>如果说 <code>libvgm</code> 教会了我们如何阅读地图（VGM文件），那么 <code>modizer</code> 则给了我们解密地图上最神秘符号（WonderSwan特定的音频寄存器）的钥匙。它提供了硬件级的模拟逻辑，这对于正确解释 <code>libvgm</code> 帮助我们解析出的数据流至关重要。</p>
<ul>
<li>  <strong>核心贡献</strong>: WonderSwan声音芯片模拟逻辑。</li>
<li>  <strong>关键源文件</strong>: <code>modizer-master/libs/libwonderswan/libwonderswan/oswan/audio.cpp</code></li>
<li>  <strong>如何使用</strong>: 我们的 <code>WonderSwanChip.cpp</code> 本质上是 <code>modizer</code> 的 <code>audio.cpp</code> 中逻辑的C++重新实现和改编。通过研究这个文件，我们取得了众多突破：</li>
<li>  <strong>音高计算</strong>: 神奇的公式 <code>freq = (3072000 / (2048 - period)) / 32</code> 直接源自 <code>modizer</code> 的频率计算代码。除以32（代表波形表大小）是实现正确音高的最重要发现。</li>
<li>  <strong>寄存器映射</strong>: 通过观察 <code>audio.cpp</code> 在写入这些端口时如何更新其内部状态变量，我们破译了从 <code>0x80</code> 到 <code>0x94</code> 的所有关键I/O端口的功能。这包括频率、音量、声相、扫描和噪声控制。</li>
<li>  <strong>硬件怪癖</strong>: <code>modizer</code> 的代码还揭示了非显而易见的硬件行为，例如声音DMA过程如何将其输出写入通道2的音量寄存器（<code>0x89</code>），我们忠实地模拟了这一点。</li>
</ul>
<p>总而言之，<code>libvgm</code> 提供了 <strong>读取数据的框架</strong>，而 <code>modizer</code> 提供了 <strong>理解数据的知识</strong>。这两个资源的结合是本项目成功的秘诀。</p>

<script>
    window.onscroll = function() {
        updateProgressBar();
    };

    document.getElementById("progress-container").onclick = function(event) {
        var rect = this.getBoundingClientRect();
        var clickX = event.clientX - rect.left;
        var percentage = clickX / this.offsetWidth;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        window.scrollTo(0, height * percentage);
    };

    function updateProgressBar() {
        var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        var scrolled = (winScroll / height) * 100;
        document.getElementById("progress-bar").style.width = scrolled + "%";
    }
</script>
</body>
</html>
